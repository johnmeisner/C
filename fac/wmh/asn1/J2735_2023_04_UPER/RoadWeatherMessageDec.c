/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "RoadWeatherMessage.h"
#include "ProbeVehicleData.h"
#include "Common.h"
#include "TravelerInformation.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PD_NTCIPEssAirTemperature (OSCTXT* pctxt, NTCIPEssAirTemperature* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 2002, range_bitcnt = 11 */
   stat = pd_ConsInt16(pctxt, pvalue, -1000, 1001);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_TemperatureMeasurementStdDev (OSCTXT* pctxt, TemperatureMeasurementStdDev* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 4);
   if (stat != 0) return stat;

   *pvalue += 1;

   return stat;
}

EXTERN int asn1PD_NTCIPEssTemperatureSensorHeight (OSCTXT* pctxt, NTCIPEssTemperatureSensorHeight* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 2002, range_bitcnt = 11 */
   stat = pd_ConsInt16(pctxt, pvalue, -1000, 1001);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_NtcipAirTemperature (OSCTXT* pctxt, NtcipAirTemperature* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode temperature */
   pctxt->level++;

   stat = asn1PD_NTCIPEssAirTemperature (pctxt, &pvalue->temperature);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode measurementStdDev */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.measurementStdDevPresent = 1;

      stat = asn1PD_TemperatureMeasurementStdDev (pctxt, &pvalue->measurementStdDev);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode tempSensorHeight */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.tempSensorHeightPresent = 1;

      stat = asn1PD_NTCIPEssTemperatureSensorHeight (pctxt, &pvalue->tempSensorHeight);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NTCIPEssPressureSensorAtmosphericPressure (OSCTXT* pctxt, NTCIPEssPressureSensorAtmosphericPressure* pvalue)
{
   PD_BYTE_ALIGN(pctxt);
   return rtxDecBitsToUInt16(pctxt, pvalue, 16);
}

EXTERN int asn1PD_AtmosPressureMeasurementStdDev (OSCTXT* pctxt, AtmosPressureMeasurementStdDev* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 4);
   if (stat != 0) return stat;

   *pvalue += 1;

   return stat;
}

EXTERN int asn1PD_NtcipAtmosphericPressure (OSCTXT* pctxt, NtcipAtmosphericPressure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode pressure */
   pctxt->level++;

   stat = asn1PD_NTCIPEssPressureSensorAtmosphericPressure (pctxt, &pvalue->pressure);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode measurementStdDev */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.measurementStdDevPresent = 1;

      stat = asn1PD_AtmosPressureMeasurementStdDev (pctxt, &pvalue->measurementStdDev);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NTCIPWindSensorAvgSpeed (OSCTXT* pctxt, NTCIPWindSensorAvgSpeed* pvalue)
{
   PD_BYTE_ALIGN(pctxt);
   return rtxDecBitsToUInt16(pctxt, pvalue, 16);
}

EXTERN int asn1PD_NTCIPWindSensorAvgDirection (OSCTXT* pctxt, NTCIPWindSensorAvgDirection* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 9);
   if (stat != 0) return stat;

   if (*pvalue > 361) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_NTCIPWindSensorSpotSpeed (OSCTXT* pctxt, NTCIPWindSensorSpotSpeed* pvalue)
{
   PD_BYTE_ALIGN(pctxt);
   return rtxDecBitsToUInt16(pctxt, pvalue, 16);
}

EXTERN int asn1PD_NTCIPWindSensorSpotDirection (OSCTXT* pctxt, NTCIPWindSensorSpotDirection* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 9);
   if (stat != 0) return stat;

   if (*pvalue > 361) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_NTCIPWindSensorGustSpeed (OSCTXT* pctxt, NTCIPWindSensorGustSpeed* pvalue)
{
   PD_BYTE_ALIGN(pctxt);
   return rtxDecBitsToUInt16(pctxt, pvalue, 16);
}

EXTERN int asn1PD_NTCIPWindSensorGustDirection (OSCTXT* pctxt, NTCIPWindSensorGustDirection* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 9);
   if (stat != 0) return stat;

   if (*pvalue > 361) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_NtcipWind (OSCTXT* pctxt, NtcipWind* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[6];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode avgSpeed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgSpeedPresent = 1;

            stat = asn1PD_NTCIPWindSensorAvgSpeed (pctxt, &pvalue->avgSpeed);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode avgDirection */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgDirectionPresent = 1;

            stat = asn1PD_NTCIPWindSensorAvgDirection (pctxt, &pvalue->avgDirection);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode currentSpeed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.currentSpeedPresent = 1;

            stat = asn1PD_NTCIPWindSensorSpotSpeed (pctxt, &pvalue->currentSpeed);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode curDirection */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.curDirectionPresent = 1;

            stat = asn1PD_NTCIPWindSensorSpotDirection (pctxt, &pvalue->curDirection);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode gustSpeed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.gustSpeedPresent = 1;

            stat = asn1PD_NTCIPWindSensorGustSpeed (pctxt, &pvalue->gustSpeed);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode gustDirection */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.gustDirectionPresent = 1;

            stat = asn1PD_NTCIPWindSensorGustDirection (pctxt, &pvalue->gustDirection);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NTCIPHumiditySensorRelativeHumidity (OSCTXT* pctxt, NTCIPHumiditySensorRelativeHumidity* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 7);
   if (stat != 0) return stat;

   if (*pvalue > 101) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_DataSourceInfo (OSCTXT* pctxt, DataSourceInfo* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(1));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_NtcipRelativeHumidity (OSCTXT* pctxt, NtcipRelativeHumidity* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode relHumidity */
   pctxt->level++;

   stat = asn1PD_NTCIPHumiditySensorRelativeHumidity (pctxt, &pvalue->relHumidity);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode source */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.sourcePresent = 1;

      stat = asn1PD_DataSourceInfo (pctxt, &pvalue->source);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NTCIPEssDewpointTemp (OSCTXT* pctxt, NTCIPEssDewpointTemp* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 2002, range_bitcnt = 11 */
   stat = pd_ConsInt16(pctxt, pvalue, -1000, 1001);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_DewPointTempMeasurementStdDev (OSCTXT* pctxt, DewPointTempMeasurementStdDev* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 4);
   if (stat != 0) return stat;

   *pvalue += 1;

   return stat;
}

EXTERN int asn1PD_NtcipDewPoint (OSCTXT* pctxt, NtcipDewPoint* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode dewTemp */
   pctxt->level++;

   stat = asn1PD_NTCIPEssDewpointTemp (pctxt, &pvalue->dewTemp);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode source */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.sourcePresent = 1;

      stat = asn1PD_DataSourceInfo (pctxt, &pvalue->source);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode measurementStdDev */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.measurementStdDevPresent = 1;

      stat = asn1PD_DewPointTempMeasurementStdDev (pctxt, &pvalue->measurementStdDev);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NTCIPEssSurfaceTemperature (OSCTXT* pctxt, NTCIPEssSurfaceTemperature* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 2002, range_bitcnt = 11 */
   stat = pd_ConsInt16(pctxt, pvalue, -1000, 1001);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_SurfaceTempMeasurementStdDev (OSCTXT* pctxt, SurfaceTempMeasurementStdDev* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 4);
   if (stat != 0) return stat;

   *pvalue += 1;

   return stat;
}

EXTERN int asn1PD_NTCIPPavementSensorSurfaceCondition (OSCTXT* pctxt, NTCIPPavementSensorSurfaceCondition* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(12));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 12) {
         return RTERR_CONSVIO;
      }
      *pvalue += 1;
   }

   return (stat);
}

EXTERN int asn1PD_NTCIPEssSurfaceIceOrWaterDepth (OSCTXT* pctxt, NTCIPEssSurfaceIceOrWaterDepth* pvalue)
{
   PD_BYTE_ALIGN(pctxt);
   return rtxDecBitsToUInt16(pctxt, pvalue, 16);
}

EXTERN int asn1PD_NtcipPavement (OSCTXT* pctxt, NtcipPavement* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode surfaceTemp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.surfaceTempPresent = 1;

            stat = asn1PD_NTCIPEssSurfaceTemperature (pctxt, &pvalue->surfaceTemp);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode tempStdDev */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.tempStdDevPresent = 1;

            stat = asn1PD_SurfaceTempMeasurementStdDev (pctxt, &pvalue->tempStdDev);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode condition */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.conditionPresent = 1;

            stat = asn1PD_NTCIPPavementSensorSurfaceCondition (pctxt, &pvalue->condition);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode moistureDepth */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.moistureDepthPresent = 1;

            stat = asn1PD_NTCIPEssSurfaceIceOrWaterDepth (pctxt, &pvalue->moistureDepth);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode roadRoughness */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.roadRoughnessPresent = 1;

            pvalue->roadRoughness = rtxMemAllocType (pctxt, RoadRoughness);

            if (pvalue->roadRoughness == NULL)
               return RTERR_NOMEM;

            asn1Init_RoadRoughness ((RoadRoughness*)pvalue->roadRoughness);

            stat = asn1PD_RoadRoughness (pctxt, (RoadRoughness*)pvalue->roadRoughness);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NTCIPEssVisibility (OSCTXT* pctxt, NTCIPEssVisibility* pvalue)
{
   return pd_ConsUnsigned(pctxt, pvalue,  0,  1000001);
}

EXTERN int asn1PD_NtcipVisibility (OSCTXT* pctxt, NtcipVisibility* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode visibility */
   pctxt->level++;

   stat = asn1PD_NTCIPEssVisibility (pctxt, &pvalue->visibility);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NTCIPEssVisibilitySituation (OSCTXT* pctxt, NTCIPEssVisibilitySituation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(11));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 11) {
         return RTERR_CONSVIO;
      }
      *pvalue += 1;
   }

   return (stat);
}

EXTERN int asn1PD_NtcipVisibilitySituation (OSCTXT* pctxt, NtcipVisibilitySituation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode situation */
   pctxt->level++;

   stat = asn1PD_NTCIPEssVisibilitySituation (pctxt, &pvalue->situation);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NTCIPEssCloudSituationV4 (OSCTXT* pctxt, NTCIPEssCloudSituationV4* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 4);
   if (stat != 0) return stat;

   if (*pvalue > 8) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_NtcipCloudSituation (OSCTXT* pctxt, NtcipCloudSituation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode situation */
   pctxt->level++;

   stat = asn1PD_NTCIPEssCloudSituationV4 (pctxt, &pvalue->situation);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NTCIPPrecipitationSensorPrecipSituation (OSCTXT* pctxt, NTCIPPrecipitationSensorPrecipSituation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(14));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 14) {
         return RTERR_CONSVIO;
      }
      *pvalue += 1;
   }

   return (stat);
}

EXTERN int asn1PD_NtcipPrecipitation (OSCTXT* pctxt, NtcipPrecipitation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode precipitation */
   pctxt->level++;

   stat = asn1PD_NTCIPPrecipitationSensorPrecipSituation (pctxt, &pvalue->precipitation);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NTCIPEssTotalRadiationV4 (OSCTXT* pctxt, NTCIPEssTotalRadiationV4* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 4098, range_bitcnt = 13 */
   stat = pd_ConsInt16(pctxt, pvalue, -2048, 2049);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_NTCIPEssTotalRadiationPeriod (OSCTXT* pctxt, NTCIPEssTotalRadiationPeriod* pvalue)
{
   return pd_ConsUnsigned(pctxt, pvalue,  0,  86400);
}

EXTERN int asn1PD_NtcipSolarRadiation (OSCTXT* pctxt, NtcipSolarRadiation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode solarRadiation */
   pctxt->level++;

   stat = asn1PD_NTCIPEssTotalRadiationV4 (pctxt, &pvalue->solarRadiation);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode measurementPeriod */
   pctxt->level++;

   stat = asn1PD_NTCIPEssTotalRadiationPeriod (pctxt, &pvalue->measurementPeriod);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NtcipEssData (OSCTXT* pctxt, NtcipEssData* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[11];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 11; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 11; i_++) {
      switch (i_) {
         case 0:
         /* decode airTemp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.airTempPresent = 1;

            stat = asn1PD_NtcipAirTemperature (pctxt, &pvalue->airTemp);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode atmosphere */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.atmospherePresent = 1;

            stat = asn1PD_NtcipAtmosphericPressure (pctxt, &pvalue->atmosphere);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode wind */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.windPresent = 1;

            stat = asn1PD_NtcipWind (pctxt, &pvalue->wind);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode humidity */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.humidityPresent = 1;

            stat = asn1PD_NtcipRelativeHumidity (pctxt, &pvalue->humidity);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode dewpoint */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.dewpointPresent = 1;

            stat = asn1PD_NtcipDewPoint (pctxt, &pvalue->dewpoint);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode pavement */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.pavementPresent = 1;

            stat = asn1PD_NtcipPavement (pctxt, &pvalue->pavement);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode visibility */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.visibilityPresent = 1;

            stat = asn1PD_NtcipVisibility (pctxt, &pvalue->visibility);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode visSituation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.visSituationPresent = 1;

            stat = asn1PD_NtcipVisibilitySituation (pctxt, &pvalue->visSituation);

            pctxt->level--;
         }
         break;

         case 8:
         /* decode cloudSitiation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.cloudSitiationPresent = 1;

            stat = asn1PD_NtcipCloudSituation (pctxt, &pvalue->cloudSitiation);

            pctxt->level--;
         }
         break;

         case 9:
         /* decode precipitation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.precipitationPresent = 1;

            stat = asn1PD_NtcipPrecipitation (pctxt, &pvalue->precipitation);

            pctxt->level--;
         }
         break;

         case 10:
         /* decode solarRadiation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.solarRadiationPresent = 1;

            stat = asn1PD_NtcipSolarRadiation (pctxt, &pvalue->solarRadiation);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NTCIPEssPavementTreatmentLatitude (OSCTXT* pctxt, NTCIPEssPavementTreatmentLatitude* pvalue)
{
   return pd_ConsInteger(pctxt, pvalue,  -90000000,  90000001);
}

EXTERN int asn1PD_NTCIPEssPavementTreatmentLongitude (OSCTXT* pctxt, NTCIPEssPavementTreatmentLongitude* pvalue)
{
   return pd_ConsInteger(pctxt, pvalue,  -180000000,  180000001);
}

EXTERN int asn1PD_NTCIPEssPavementTreatmentLocation (OSCTXT* pctxt, NTCIPEssPavementTreatmentLocation* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pd_ConstrainedStringEx (pctxt, pvalue, 0, 8, 7, 7);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_NTCIPEssPaveTreatProductType (OSCTXT* pctxt, NTCIPEssPaveTreatProductType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(13));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 13) {
         return RTERR_CONSVIO;
      }
      *pvalue += 1;
   }

   return (stat);
}

EXTERN int asn1PD_NTCIPEssPaveTreatProductForm (OSCTXT* pctxt, NTCIPEssPaveTreatProductForm* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(3));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
      *pvalue += 1;
   }

   return (stat);
}

EXTERN int asn1PD_NTCIPEssPercentProductMix (OSCTXT* pctxt, NTCIPEssPercentProductMix* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 7);
   if (stat != 0) return stat;

   if (*pvalue > 100) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_NTCIPEssPaveTreatmentAmount (OSCTXT* pctxt, NTCIPEssPaveTreatmentAmount* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_NTCIPEssPaveTreatmentWidth (OSCTXT* pctxt, NTCIPEssPaveTreatmentWidth* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_SnapShot (OSCTXT* pctxt, SnapShot* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode thePosition */
   pctxt->level++;

   pvalue->thePosition = rtxMemAllocType (pctxt, FullPositionVector);

   if (pvalue->thePosition == NULL)
      return RTERR_NOMEM;

   asn1Init_FullPositionVector ((FullPositionVector*)pvalue->thePosition);

   stat = asn1PD_FullPositionVector (pctxt, (FullPositionVector*)pvalue->thePosition);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode safetyExt */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.safetyExtPresent = 1;

      pvalue->safetyExt = rtxMemAllocType (pctxt, VehicleSafetyExtensions);

      if (pvalue->safetyExt == NULL)
         return RTERR_NOMEM;

      asn1Init_VehicleSafetyExtensions ((VehicleSafetyExtensions*)pvalue->safetyExt);

      stat = asn1PD_VehicleSafetyExtensions (pctxt, (VehicleSafetyExtensions*)pvalue->safetyExt);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode dataSet */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.dataSetPresent = 1;

      pvalue->dataSet = rtxMemAllocType (pctxt, VehicleStatus);

      if (pvalue->dataSet == NULL)
         return RTERR_NOMEM;

      asn1Init_VehicleStatus ((VehicleStatus*)pvalue->dataSet);

      stat = asn1PD_VehicleStatus (pctxt, (VehicleStatus*)pvalue->dataSet);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            if (i_ < 1) {  /* known element */
               OSUINT32 openTypeLen;
               size_t bitStartOffset, bitLength;
               size_t bitEndOffset, bitsConsumed;

               stat = pd_UnconsLength (pctxt, &openTypeLen);
               if (stat < 0) {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return stat;
               }
               else if (stat == RT_OK_FRAG) {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return RTERR_NOTSUPP;
               }
               bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
               bitLength = openTypeLen * 8;

               if (openTypeLen > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.weatherDataPresent = 1;
                        pctxt->level++;

                        stat = asn1PD_NtcipEssData (pctxt, &pvalue->weatherData);

                        if (stat != 0) break;

                        pctxt->level--;

                        break;

                  }
               }

               if (0 == stat) {
                  bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
                  bitsConsumed = bitEndOffset - bitStartOffset;
                  if (bitsConsumed < bitLength) {
                     stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
                  }
                  else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
               }
            }
            else {
               stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

               if (0 == stat) {
                  pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
                  if (0 != pOpenType) {
                     pOpenType->numocts = openType.numocts;
                     pOpenType->data = openType.data;
                     rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
                  }
                  else stat = RTERR_NOMEM;
               }
               else {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return stat;
               }
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NtcipPavementTreatment (OSCTXT* pctxt, NtcipPavementTreatment* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 8; i_++) {
      switch (i_) {
         case 0:
         /* decode latitude */
         pctxt->level++;

         stat = asn1PD_NTCIPEssPavementTreatmentLatitude (pctxt, &pvalue->latitude);

         pctxt->level--;
         break;

         case 1:
         /* decode longitude */
         pctxt->level++;

         stat = asn1PD_NTCIPEssPavementTreatmentLongitude (pctxt, &pvalue->longitude);

         pctxt->level--;
         break;

         case 2:
         /* decode location */
         pctxt->level++;

         stat = asn1PD_NTCIPEssPavementTreatmentLocation (pctxt, &pvalue->location);

         pctxt->level--;
         break;

         case 3:
         /* decode productType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.productTypePresent = 1;

            stat = asn1PD_NTCIPEssPaveTreatProductType (pctxt, &pvalue->productType);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode form */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.formPresent = 1;

            stat = asn1PD_NTCIPEssPaveTreatProductForm (pctxt, &pvalue->form);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode percentage */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.percentagePresent = 1;

            stat = asn1PD_NTCIPEssPercentProductMix (pctxt, &pvalue->percentage);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode amount */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.amountPresent = 1;

            stat = asn1PD_NTCIPEssPaveTreatmentAmount (pctxt, &pvalue->amount);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode width */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.widthPresent = 1;

            stat = asn1PD_NTCIPEssPaveTreatmentWidth (pctxt, &pvalue->width);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_WDMSFleetData (OSCTXT* pctxt, WDMSFleetData* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode pavementTreat */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.pavementTreatPresent = 1;

      stat = asn1PD_NtcipPavementTreatment (pctxt, &pvalue->pavementTreat);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode routingAdvice */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.routingAdvicePresent = 1;

      stat = asn1PD_ITIStext (pctxt, &pvalue->routingAdvice);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_VehicleReport (OSCTXT* pctxt, VehicleReport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode snapShot */
   pctxt->level++;

   stat = asn1PD_SnapShot (pctxt, &pvalue->snapShot);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode wdmsFleetData */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.wdmsFleetDataPresent = 1;

      stat = asn1PD_WDMSFleetData (pctxt, &pvalue->wdmsFleetData);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RoadWeatherUpload_vehicleReport (OSCTXT* pctxt, RoadWeatherUpload_vehicleReport* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      VehicleReport* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, VehicleReport);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_VehicleReport (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_VehicleReport (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_RoadWeatherUpload (OSCTXT* pctxt, RoadWeatherUpload* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      {
         OSBOOL b_ = 0;
         DEC_BIT (pctxt, &b_);
         ui = b_;
      }
      pvalue->t = ui + 1;

      switch (ui) {
         /* vehicleReport */
         case 0:
            pctxt->level++;

            pvalue->u.vehicleReport = rtxMemAllocType (pctxt, 
               RoadWeatherUpload_vehicleReport);

            if (pvalue->u.vehicleReport == NULL)
               return RTERR_NOMEM;

            asn1Init_RoadWeatherUpload_vehicleReport (pvalue->u.vehicleReport);

            stat = asn1PD_RoadWeatherUpload_vehicleReport (pctxt, pvalue->u.vehicleReport);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* citizenReport */
         case 1:
            pctxt->level++;

            pvalue->u.citizenReport = rtxMemAllocType (pctxt, SnapShot);

            if (pvalue->u.citizenReport == NULL)
               return RTERR_NOMEM;

            asn1Init_SnapShot (pvalue->u.citizenReport);

            stat = asn1PD_SnapShot (pctxt, pvalue->u.citizenReport);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_RoadWeatherDownload (OSCTXT* pctxt, RoadWeatherDownload* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode travelerData */
   pctxt->level++;

   stat = asn1PD_TravelerDataFrameList (pctxt, (TravelerDataFrameList*)&pvalue->travelerData);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode wdmsFleetData */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.wdmsFleetDataPresent = 1;

      stat = asn1PD_WDMSFleetData (pctxt, &pvalue->wdmsFleetData);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RoadWeatherMessage (OSCTXT* pctxt, RoadWeatherMessage* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      {
         OSBOOL b_ = 0;
         DEC_BIT (pctxt, &b_);
         ui = b_;
      }
      pvalue->t = ui + 1;

      switch (ui) {
         /* upload */
         case 0:
            pctxt->level++;

            pvalue->u.upload = rtxMemAllocType (pctxt, RoadWeatherUpload);

            if (pvalue->u.upload == NULL)
               return RTERR_NOMEM;

            asn1Init_RoadWeatherUpload (pvalue->u.upload);

            stat = asn1PD_RoadWeatherUpload (pctxt, pvalue->u.upload);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* download */
         case 1:
            pctxt->level++;

            pvalue->u.download = rtxMemAllocType (pctxt, RoadWeatherDownload);

            if (pvalue->u.download == NULL)
               return RTERR_NOMEM;

            asn1Init_RoadWeatherDownload (pvalue->u.download);

            stat = asn1PD_RoadWeatherDownload (pctxt, pvalue->u.download);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

