/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "RoadWeatherMessage.h"
#include "ProbeVehicleData.h"
#include "Common.h"
#include "TravelerInformation.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PE_NTCIPEssAirTemperature (OSCTXT* pctxt, NTCIPEssAirTemperature value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -1000,  1001);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_TemperatureMeasurementStdDev (OSCTXT* pctxt, TemperatureMeasurementStdDev value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  1,  16);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPEssTemperatureSensorHeight (OSCTXT* pctxt, NTCIPEssTemperatureSensorHeight value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -1000,  1001);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NtcipAirTemperature (OSCTXT* pctxt, NtcipAirTemperature* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.measurementStdDevPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.tempSensorHeightPresent);

   /* encode temperature */

   stat = asn1PE_NTCIPEssAirTemperature (pctxt, pvalue->temperature);
   if (stat != 0) return stat;

   /* encode measurementStdDev */

   if (pvalue->m.measurementStdDevPresent) {
      stat = asn1PE_TemperatureMeasurementStdDev (pctxt, pvalue->measurementStdDev);
      if (stat != 0) return stat;
   }

   /* encode tempSensorHeight */

   if (pvalue->m.tempSensorHeightPresent) {
      stat = asn1PE_NTCIPEssTemperatureSensorHeight (pctxt, pvalue->tempSensorHeight);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NTCIPEssPressureSensorAtmosphericPressure (OSCTXT* pctxt, NTCIPEssPressureSensorAtmosphericPressure value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  65535);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_AtmosPressureMeasurementStdDev (OSCTXT* pctxt, AtmosPressureMeasurementStdDev value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  1,  16);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NtcipAtmosphericPressure (OSCTXT* pctxt, NtcipAtmosphericPressure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.measurementStdDevPresent);

   /* encode pressure */

   stat = asn1PE_NTCIPEssPressureSensorAtmosphericPressure (pctxt, pvalue->pressure);
   if (stat != 0) return stat;

   /* encode measurementStdDev */

   if (pvalue->m.measurementStdDevPresent) {
      stat = asn1PE_AtmosPressureMeasurementStdDev (pctxt, pvalue->measurementStdDev);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NTCIPWindSensorAvgSpeed (OSCTXT* pctxt, NTCIPWindSensorAvgSpeed value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  65535);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPWindSensorAvgDirection (OSCTXT* pctxt, NTCIPWindSensorAvgDirection value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  361);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPWindSensorSpotSpeed (OSCTXT* pctxt, NTCIPWindSensorSpotSpeed value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  65535);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPWindSensorSpotDirection (OSCTXT* pctxt, NTCIPWindSensorSpotDirection value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  361);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPWindSensorGustSpeed (OSCTXT* pctxt, NTCIPWindSensorGustSpeed value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  65535);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPWindSensorGustDirection (OSCTXT* pctxt, NTCIPWindSensorGustDirection value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  361);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NtcipWind (OSCTXT* pctxt, NtcipWind* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgSpeedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgDirectionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.currentSpeedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.curDirectionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.gustSpeedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.gustDirectionPresent);

   /* encode avgSpeed */

   if (pvalue->m.avgSpeedPresent) {
      stat = asn1PE_NTCIPWindSensorAvgSpeed (pctxt, pvalue->avgSpeed);
      if (stat != 0) return stat;
   }

   /* encode avgDirection */

   if (pvalue->m.avgDirectionPresent) {
      stat = asn1PE_NTCIPWindSensorAvgDirection (pctxt, pvalue->avgDirection);
      if (stat != 0) return stat;
   }

   /* encode currentSpeed */

   if (pvalue->m.currentSpeedPresent) {
      stat = asn1PE_NTCIPWindSensorSpotSpeed (pctxt, pvalue->currentSpeed);
      if (stat != 0) return stat;
   }

   /* encode curDirection */

   if (pvalue->m.curDirectionPresent) {
      stat = asn1PE_NTCIPWindSensorSpotDirection (pctxt, pvalue->curDirection);
      if (stat != 0) return stat;
   }

   /* encode gustSpeed */

   if (pvalue->m.gustSpeedPresent) {
      stat = asn1PE_NTCIPWindSensorGustSpeed (pctxt, pvalue->gustSpeed);
      if (stat != 0) return stat;
   }

   /* encode gustDirection */

   if (pvalue->m.gustDirectionPresent) {
      stat = asn1PE_NTCIPWindSensorGustDirection (pctxt, pvalue->gustDirection);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NTCIPHumiditySensorRelativeHumidity (OSCTXT* pctxt, NTCIPHumiditySensorRelativeHumidity value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  101);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DataSourceInfo (OSCTXT* pctxt, DataSourceInfo value)
{
   int stat = 0;

   if (value >= 2) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 1);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NtcipRelativeHumidity (OSCTXT* pctxt, NtcipRelativeHumidity* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.sourcePresent);

   /* encode relHumidity */

   stat = asn1PE_NTCIPHumiditySensorRelativeHumidity (pctxt, pvalue->relHumidity);
   if (stat != 0) return stat;

   /* encode source */

   if (pvalue->m.sourcePresent) {
      stat = asn1PE_DataSourceInfo (pctxt, pvalue->source);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NTCIPEssDewpointTemp (OSCTXT* pctxt, NTCIPEssDewpointTemp value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -1000,  1001);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DewPointTempMeasurementStdDev (OSCTXT* pctxt, DewPointTempMeasurementStdDev value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  1,  16);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NtcipDewPoint (OSCTXT* pctxt, NtcipDewPoint* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.sourcePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.measurementStdDevPresent);

   /* encode dewTemp */

   stat = asn1PE_NTCIPEssDewpointTemp (pctxt, pvalue->dewTemp);
   if (stat != 0) return stat;

   /* encode source */

   if (pvalue->m.sourcePresent) {
      stat = asn1PE_DataSourceInfo (pctxt, pvalue->source);
      if (stat != 0) return stat;
   }

   /* encode measurementStdDev */

   if (pvalue->m.measurementStdDevPresent) {
      stat = asn1PE_DewPointTempMeasurementStdDev (pctxt, pvalue->measurementStdDev);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NTCIPEssSurfaceTemperature (OSCTXT* pctxt, NTCIPEssSurfaceTemperature value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -1000,  1001);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SurfaceTempMeasurementStdDev (OSCTXT* pctxt, SurfaceTempMeasurementStdDev value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  1,  16);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPPavementSensorSurfaceCondition (OSCTXT* pctxt, NTCIPPavementSensorSurfaceCondition value)
{
   int stat = 0;

   if (value >= 14) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value - 1, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPEssSurfaceIceOrWaterDepth (OSCTXT* pctxt, NTCIPEssSurfaceIceOrWaterDepth value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  65535);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NtcipPavement (OSCTXT* pctxt, NtcipPavement* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.surfaceTempPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.tempStdDevPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.conditionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.moistureDepthPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.roadRoughnessPresent);

   /* encode surfaceTemp */

   if (pvalue->m.surfaceTempPresent) {
      stat = asn1PE_NTCIPEssSurfaceTemperature (pctxt, pvalue->surfaceTemp);
      if (stat != 0) return stat;
   }

   /* encode tempStdDev */

   if (pvalue->m.tempStdDevPresent) {
      stat = asn1PE_SurfaceTempMeasurementStdDev (pctxt, pvalue->tempStdDev);
      if (stat != 0) return stat;
   }

   /* encode condition */

   if (pvalue->m.conditionPresent) {
      stat = asn1PE_NTCIPPavementSensorSurfaceCondition (pctxt, pvalue->condition);
      if (stat != 0) return stat;
   }

   /* encode moistureDepth */

   if (pvalue->m.moistureDepthPresent) {
      stat = asn1PE_NTCIPEssSurfaceIceOrWaterDepth (pctxt, pvalue->moistureDepth);
      if (stat != 0) return stat;
   }

   /* encode roadRoughness */

   if (pvalue->m.roadRoughnessPresent) {
      stat = asn1PE_RoadRoughness (pctxt, (RoadRoughness*)pvalue->roadRoughness);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NTCIPEssVisibility (OSCTXT* pctxt, NTCIPEssVisibility value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  1000001);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NtcipVisibility (OSCTXT* pctxt, NtcipVisibility* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode visibility */

   stat = asn1PE_NTCIPEssVisibility (pctxt, pvalue->visibility);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NTCIPEssVisibilitySituation (OSCTXT* pctxt, NTCIPEssVisibilitySituation value)
{
   int stat = 0;

   if (value >= 13) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value - 1, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NtcipVisibilitySituation (OSCTXT* pctxt, NtcipVisibilitySituation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode situation */

   stat = asn1PE_NTCIPEssVisibilitySituation (pctxt, pvalue->situation);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NTCIPEssCloudSituationV4 (OSCTXT* pctxt, NTCIPEssCloudSituationV4 value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  8);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NtcipCloudSituation (OSCTXT* pctxt, NtcipCloudSituation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode situation */

   stat = asn1PE_NTCIPEssCloudSituationV4 (pctxt, pvalue->situation);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NTCIPPrecipitationSensorPrecipSituation (OSCTXT* pctxt, NTCIPPrecipitationSensorPrecipSituation value)
{
   int stat = 0;

   if (value >= 16) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value - 1, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NtcipPrecipitation (OSCTXT* pctxt, NtcipPrecipitation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode precipitation */

   stat = asn1PE_NTCIPPrecipitationSensorPrecipSituation (pctxt, pvalue->precipitation);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NTCIPEssTotalRadiationV4 (OSCTXT* pctxt, NTCIPEssTotalRadiationV4 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -2048,  2049);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPEssTotalRadiationPeriod (OSCTXT* pctxt, NTCIPEssTotalRadiationPeriod value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  86400);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NtcipSolarRadiation (OSCTXT* pctxt, NtcipSolarRadiation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode solarRadiation */

   stat = asn1PE_NTCIPEssTotalRadiationV4 (pctxt, pvalue->solarRadiation);
   if (stat != 0) return stat;

   /* encode measurementPeriod */

   stat = asn1PE_NTCIPEssTotalRadiationPeriod (pctxt, pvalue->measurementPeriod);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NtcipEssData (OSCTXT* pctxt, NtcipEssData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.airTempPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.atmospherePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.windPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.humidityPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dewpointPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pavementPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.visibilityPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.visSituationPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.cloudSitiationPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.precipitationPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.solarRadiationPresent);

   /* encode airTemp */

   if (pvalue->m.airTempPresent) {
      stat = asn1PE_NtcipAirTemperature (pctxt, &pvalue->airTemp);
      if (stat != 0) return stat;
   }

   /* encode atmosphere */

   if (pvalue->m.atmospherePresent) {
      stat = asn1PE_NtcipAtmosphericPressure (pctxt, &pvalue->atmosphere);
      if (stat != 0) return stat;
   }

   /* encode wind */

   if (pvalue->m.windPresent) {
      stat = asn1PE_NtcipWind (pctxt, &pvalue->wind);
      if (stat != 0) return stat;
   }

   /* encode humidity */

   if (pvalue->m.humidityPresent) {
      stat = asn1PE_NtcipRelativeHumidity (pctxt, &pvalue->humidity);
      if (stat != 0) return stat;
   }

   /* encode dewpoint */

   if (pvalue->m.dewpointPresent) {
      stat = asn1PE_NtcipDewPoint (pctxt, &pvalue->dewpoint);
      if (stat != 0) return stat;
   }

   /* encode pavement */

   if (pvalue->m.pavementPresent) {
      stat = asn1PE_NtcipPavement (pctxt, &pvalue->pavement);
      if (stat != 0) return stat;
   }

   /* encode visibility */

   if (pvalue->m.visibilityPresent) {
      stat = asn1PE_NtcipVisibility (pctxt, &pvalue->visibility);
      if (stat != 0) return stat;
   }

   /* encode visSituation */

   if (pvalue->m.visSituationPresent) {
      stat = asn1PE_NtcipVisibilitySituation (pctxt, &pvalue->visSituation);
      if (stat != 0) return stat;
   }

   /* encode cloudSitiation */

   if (pvalue->m.cloudSitiationPresent) {
      stat = asn1PE_NtcipCloudSituation (pctxt, &pvalue->cloudSitiation);
      if (stat != 0) return stat;
   }

   /* encode precipitation */

   if (pvalue->m.precipitationPresent) {
      stat = asn1PE_NtcipPrecipitation (pctxt, &pvalue->precipitation);
      if (stat != 0) return stat;
   }

   /* encode solarRadiation */

   if (pvalue->m.solarRadiationPresent) {
      stat = asn1PE_NtcipSolarRadiation (pctxt, &pvalue->solarRadiation);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NTCIPEssPavementTreatmentLatitude (OSCTXT* pctxt, NTCIPEssPavementTreatmentLatitude value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -90000000,  90000001);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPEssPavementTreatmentLongitude (OSCTXT* pctxt, NTCIPEssPavementTreatmentLongitude value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -180000000,  180000001);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPEssPavementTreatmentLocation (OSCTXT* pctxt, NTCIPEssPavementTreatmentLocation value)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pe_ConstrainedStringEx (pctxt, value, 0, 8, 7, 7);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPEssPaveTreatProductType (OSCTXT* pctxt, NTCIPEssPaveTreatProductType value)
{
   int stat = 0;

   if (value >= 15) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value - 1, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPEssPaveTreatProductForm (OSCTXT* pctxt, NTCIPEssPaveTreatProductForm value)
{
   int stat = 0;

   if (value >= 5) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value - 1, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPEssPercentProductMix (OSCTXT* pctxt, NTCIPEssPercentProductMix value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  100);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPEssPaveTreatmentAmount (OSCTXT* pctxt, NTCIPEssPaveTreatmentAmount value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NTCIPEssPaveTreatmentWidth (OSCTXT* pctxt, NTCIPEssPaveTreatmentWidth value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SnapShot (OSCTXT* pctxt, SnapShot* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   extbit = (OSBOOL)(pvalue->m.weatherDataPresent ||
   pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.safetyExtPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataSetPresent);

   /* encode thePosition */

   stat = asn1PE_FullPositionVector (pctxt, (FullPositionVector*)pvalue->thePosition);
   if (stat != 0) return stat;

   /* encode safetyExt */

   if (pvalue->m.safetyExtPresent) {
      stat = asn1PE_VehicleSafetyExtensions (pctxt, (VehicleSafetyExtensions*)pvalue->safetyExt);
      if (stat != 0) return stat;
   }

   /* encode dataSet */

   if (pvalue->m.dataSetPresent) {
      stat = asn1PE_VehicleStatus (pctxt, (VehicleStatus*)pvalue->dataSet);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return stat;

      /* encode optional bits */

      rtxEncBit (pctxt, (OSBOOL)pvalue->m.weatherDataPresent);

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->m.weatherDataPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return stat;

         stat = asn1PE_NtcipEssData (pctxt, &pvalue->weatherData);
         if (stat != 0) return stat;

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return stat;
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NtcipPavementTreatment (OSCTXT* pctxt, NtcipPavementTreatment* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.productTypePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.formPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.percentagePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.amountPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.widthPresent);

   /* encode latitude */

   stat = asn1PE_NTCIPEssPavementTreatmentLatitude (pctxt, pvalue->latitude);
   if (stat != 0) return stat;

   /* encode longitude */

   stat = asn1PE_NTCIPEssPavementTreatmentLongitude (pctxt, pvalue->longitude);
   if (stat != 0) return stat;

   /* encode location */

   stat = asn1PE_NTCIPEssPavementTreatmentLocation (pctxt, pvalue->location);
   if (stat != 0) return stat;

   /* encode productType */

   if (pvalue->m.productTypePresent) {
      stat = asn1PE_NTCIPEssPaveTreatProductType (pctxt, pvalue->productType);
      if (stat != 0) return stat;
   }

   /* encode form */

   if (pvalue->m.formPresent) {
      stat = asn1PE_NTCIPEssPaveTreatProductForm (pctxt, pvalue->form);
      if (stat != 0) return stat;
   }

   /* encode percentage */

   if (pvalue->m.percentagePresent) {
      stat = asn1PE_NTCIPEssPercentProductMix (pctxt, pvalue->percentage);
      if (stat != 0) return stat;
   }

   /* encode amount */

   if (pvalue->m.amountPresent) {
      stat = asn1PE_NTCIPEssPaveTreatmentAmount (pctxt, pvalue->amount);
      if (stat != 0) return stat;
   }

   /* encode width */

   if (pvalue->m.widthPresent) {
      stat = asn1PE_NTCIPEssPaveTreatmentWidth (pctxt, pvalue->width);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_WDMSFleetData (OSCTXT* pctxt, WDMSFleetData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pavementTreatPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.routingAdvicePresent);

   /* encode pavementTreat */

   if (pvalue->m.pavementTreatPresent) {
      stat = asn1PE_NtcipPavementTreatment (pctxt, &pvalue->pavementTreat);
      if (stat != 0) return stat;
   }

   /* encode routingAdvice */

   if (pvalue->m.routingAdvicePresent) {
      stat = asn1PE_ITIStext (pctxt, pvalue->routingAdvice);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_VehicleReport (OSCTXT* pctxt, VehicleReport* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.wdmsFleetDataPresent);

   /* encode snapShot */

   stat = asn1PE_SnapShot (pctxt, &pvalue->snapShot);
   if (stat != 0) return stat;

   /* encode wdmsFleetData */

   if (pvalue->m.wdmsFleetDataPresent) {
      stat = asn1PE_WDMSFleetData (pctxt, &pvalue->wdmsFleetData);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RoadWeatherUpload_vehicleReport (OSCTXT* pctxt, RoadWeatherUpload_vehicleReport* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_VehicleReport (pctxt, ((VehicleReport*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_RoadWeatherUpload (OSCTXT* pctxt, RoadWeatherUpload* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 2);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* vehicleReport */
         case 1:
            stat = asn1PE_RoadWeatherUpload_vehicleReport (pctxt, pvalue->u.vehicleReport);
            if (stat != 0) return stat;
            break;

         /* citizenReport */
         case 2:
            stat = asn1PE_SnapShot (pctxt, pvalue->u.citizenReport);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_RoadWeatherDownload (OSCTXT* pctxt, RoadWeatherDownload* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.wdmsFleetDataPresent);

   /* encode travelerData */

   stat = asn1PE_TravelerDataFrameList (pctxt, (TravelerDataFrameList*)&pvalue->travelerData);
   if (stat != 0) return stat;

   /* encode wdmsFleetData */

   if (pvalue->m.wdmsFleetDataPresent) {
      stat = asn1PE_WDMSFleetData (pctxt, &pvalue->wdmsFleetData);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RoadWeatherMessage (OSCTXT* pctxt, RoadWeatherMessage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 2);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* upload */
         case 1:
            stat = asn1PE_RoadWeatherUpload (pctxt, pvalue->u.upload);
            if (stat != 0) return stat;
            break;

         /* download */
         case 2:
            stat = asn1PE_RoadWeatherDownload (pctxt, pvalue->u.download);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

