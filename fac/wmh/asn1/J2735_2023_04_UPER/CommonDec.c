/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "Common.h"
#include "MessageFrame.h"
#include "REGION.h"
#include "BasicSafetyMessage.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PD_StationID (OSCTXT* pctxt, StationID* pvalue)
{
   return pd_ConsUnsigned(pctxt, pvalue,  0,  OSUINT32_MAX);
}

EXTERN int asn1PD_PrioritizationResponseStatus (OSCTXT* pctxt, PrioritizationResponseStatus* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(7));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_SignalGroupID (OSCTXT* pctxt, SignalGroupID* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_LaneID (OSCTXT* pctxt, LaneID* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_Offset_B10 (OSCTXT* pctxt, Offset_B10* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 1024, range_bitcnt = 10 */
   stat = pd_ConsInt16(pctxt, pvalue, -512, 511);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_Node_XY_20b (OSCTXT* pctxt, Node_XY_20b* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode x */
   pctxt->level++;

   stat = asn1PD_Offset_B10 (pctxt, &pvalue->x);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode y */
   pctxt->level++;

   stat = asn1PD_Offset_B10 (pctxt, &pvalue->y);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_Offset_B11 (OSCTXT* pctxt, Offset_B11* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 2048, range_bitcnt = 11 */
   stat = pd_ConsInt16(pctxt, pvalue, -1024, 1023);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_Node_XY_22b (OSCTXT* pctxt, Node_XY_22b* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode x */
   pctxt->level++;

   stat = asn1PD_Offset_B11 (pctxt, &pvalue->x);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode y */
   pctxt->level++;

   stat = asn1PD_Offset_B11 (pctxt, &pvalue->y);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_Offset_B12 (OSCTXT* pctxt, Offset_B12* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 4096, range_bitcnt = 12 */
   stat = pd_ConsInt16(pctxt, pvalue, -2048, 2047);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_Node_XY_24b (OSCTXT* pctxt, Node_XY_24b* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode x */
   pctxt->level++;

   stat = asn1PD_Offset_B12 (pctxt, &pvalue->x);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode y */
   pctxt->level++;

   stat = asn1PD_Offset_B12 (pctxt, &pvalue->y);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_Offset_B13 (OSCTXT* pctxt, Offset_B13* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 8192, range_bitcnt = 13 */
   stat = pd_ConsInt16(pctxt, pvalue, -4096, 4095);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_Node_XY_26b (OSCTXT* pctxt, Node_XY_26b* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode x */
   pctxt->level++;

   stat = asn1PD_Offset_B13 (pctxt, &pvalue->x);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode y */
   pctxt->level++;

   stat = asn1PD_Offset_B13 (pctxt, &pvalue->y);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_Offset_B14 (OSCTXT* pctxt, Offset_B14* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 16384, range_bitcnt = 14 */
   stat = pd_ConsInt16(pctxt, pvalue, -8192, 8191);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_Node_XY_28b (OSCTXT* pctxt, Node_XY_28b* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode x */
   pctxt->level++;

   stat = asn1PD_Offset_B14 (pctxt, &pvalue->x);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode y */
   pctxt->level++;

   stat = asn1PD_Offset_B14 (pctxt, &pvalue->y);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_Offset_B16 (OSCTXT* pctxt, Offset_B16* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 65536, range_bitcnt = 16 */
   stat = pd_ConsInt16(pctxt, pvalue, -32768, 32767);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_Node_XY_32b (OSCTXT* pctxt, Node_XY_32b* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode x */
   pctxt->level++;

   stat = asn1PD_Offset_B16 (pctxt, &pvalue->x);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode y */
   pctxt->level++;

   stat = asn1PD_Offset_B16 (pctxt, &pvalue->y);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_Longitude (OSCTXT* pctxt, Longitude* pvalue)
{
   return pd_ConsInteger(pctxt, pvalue,  -1799999999,  1800000001);
}

EXTERN int asn1PD_Latitude (OSCTXT* pctxt, Latitude* pvalue)
{
   return pd_ConsInteger(pctxt, pvalue,  -900000000,  900000001);
}

EXTERN int asn1PD_Node_LLmD_64b (OSCTXT* pctxt, Node_LLmD_64b* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode lon */
   pctxt->level++;

   stat = asn1PD_Longitude (pctxt, &pvalue->lon);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode lat */
   pctxt->level++;

   stat = asn1PD_Latitude (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_RegionId (OSCTXT* pctxt, RegionId* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_RegionalExtension (OSCTXT* pctxt, RegionalExtension* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode regionId */
   pctxt->level++;

   stat = asn1PD_RegionId (pctxt, &pvalue->regionId);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode regExtValue */
   pctxt->level++;

   stat = pd_OpenType (pctxt, &pvalue->regExtValue.data, &pvalue->regExtValue.numocts);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_NodeOffsetPointXY (OSCTXT* pctxt, NodeOffsetPointXY* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = rtxDecBits(pctxt, &ui, 3);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* node_XY1 */
      case 0:
         pctxt->level++;

         pvalue->u.node_XY1 = rtxMemAllocTypeZ (pctxt, Node_XY_20b);

         if (pvalue->u.node_XY1 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_XY_20b (pctxt, pvalue->u.node_XY1);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* node_XY2 */
      case 1:
         pctxt->level++;

         pvalue->u.node_XY2 = rtxMemAllocTypeZ (pctxt, Node_XY_22b);

         if (pvalue->u.node_XY2 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_XY_22b (pctxt, pvalue->u.node_XY2);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* node_XY3 */
      case 2:
         pctxt->level++;

         pvalue->u.node_XY3 = rtxMemAllocTypeZ (pctxt, Node_XY_24b);

         if (pvalue->u.node_XY3 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_XY_24b (pctxt, pvalue->u.node_XY3);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* node_XY4 */
      case 3:
         pctxt->level++;

         pvalue->u.node_XY4 = rtxMemAllocTypeZ (pctxt, Node_XY_26b);

         if (pvalue->u.node_XY4 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_XY_26b (pctxt, pvalue->u.node_XY4);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* node_XY5 */
      case 4:
         pctxt->level++;

         pvalue->u.node_XY5 = rtxMemAllocTypeZ (pctxt, Node_XY_28b);

         if (pvalue->u.node_XY5 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_XY_28b (pctxt, pvalue->u.node_XY5);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* node_XY6 */
      case 5:
         pctxt->level++;

         pvalue->u.node_XY6 = rtxMemAllocTypeZ (pctxt, Node_XY_32b);

         if (pvalue->u.node_XY6 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_XY_32b (pctxt, pvalue->u.node_XY6);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* node_LatLon */
      case 6:
         pctxt->level++;

         pvalue->u.node_LatLon = rtxMemAllocTypeZ (pctxt, Node_LLmD_64b);

         if (pvalue->u.node_LatLon == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LLmD_64b (pctxt, pvalue->u.node_LatLon);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* regional */
      case 7:
         pctxt->level++;

         pvalue->u.regional = rtxMemAllocType (pctxt, RegionalExtension);

         if (pvalue->u.regional == NULL)
            return RTERR_NOMEM;

         asn1Init_RegionalExtension (pvalue->u.regional);

         stat = asn1PD_RegionalExtension (pctxt, pvalue->u.regional);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_Common_Angle (OSCTXT* pctxt, Common_Angle* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 28800) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_GrossSpeed (OSCTXT* pctxt, GrossSpeed* pvalue)
{
   return rtxDecBitsToByte(pctxt, pvalue, 5);
}

EXTERN int asn1PD_Common_MsgCount (OSCTXT* pctxt, Common_MsgCount* pvalue)
{
   return rtxDecBitsToByte(pctxt, pvalue, 7);
}

EXTERN int asn1PD_TemporaryID (OSCTXT* pctxt, TemporaryID* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_DSecond (OSCTXT* pctxt, DSecond* pvalue)
{
   PD_BYTE_ALIGN(pctxt);
   return rtxDecBitsToUInt16(pctxt, pvalue, 16);
}

EXTERN int asn1PD_Common_Elevation (OSCTXT* pctxt, Common_Elevation* pvalue)
{
   return pd_ConsInteger(pctxt, pvalue,  -4096,  61439);
}

EXTERN int asn1PD_SemiMajorAxisAccuracy (OSCTXT* pctxt, SemiMajorAxisAccuracy* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_SemiMinorAxisAccuracy (OSCTXT* pctxt, SemiMinorAxisAccuracy* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_SemiMajorAxisOrientation (OSCTXT* pctxt, SemiMajorAxisOrientation* pvalue)
{
   PD_BYTE_ALIGN(pctxt);
   return rtxDecBitsToUInt16(pctxt, pvalue, 16);
}

EXTERN int asn1PD_PositionalAccuracy (OSCTXT* pctxt, PositionalAccuracy* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode semiMajor */
   pctxt->level++;

   stat = asn1PD_SemiMajorAxisAccuracy (pctxt, &pvalue->semiMajor);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode semiMinor */
   pctxt->level++;

   stat = asn1PD_SemiMinorAxisAccuracy (pctxt, &pvalue->semiMinor);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode orientation */
   pctxt->level++;

   stat = asn1PD_SemiMajorAxisOrientation (pctxt, &pvalue->orientation);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_TransmissionState (OSCTXT* pctxt, TransmissionState* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 3);
   return stat;
}

EXTERN int asn1PD_Speed (OSCTXT* pctxt, Speed* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 13);
   if (stat != 0) return stat;

   if (*pvalue > 8191) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_Heading (OSCTXT* pctxt, Heading* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 28800) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_SteeringWheelAngle (OSCTXT* pctxt, SteeringWheelAngle* pvalue)
{
   int stat;

   /* range_value = 254, range_bitcnt = 8 */
   stat = pd_ConsInt8(pctxt, pvalue, -126, 127);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_Acceleration (OSCTXT* pctxt, Acceleration* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 4002, range_bitcnt = 12 */
   stat = pd_ConsInt16(pctxt, pvalue, -2000, 2001);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_VerticalAcceleration (OSCTXT* pctxt, VerticalAcceleration* pvalue)
{
   int stat;

   /* range_value = 255, range_bitcnt = 8 */
   stat = pd_ConsInt8(pctxt, pvalue, -127, 127);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_YawRate (OSCTXT* pctxt, YawRate* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 65535, range_bitcnt = 16 */
   stat = pd_ConsInt16(pctxt, pvalue, -32767, 32767);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_AccelerationSet4Way (OSCTXT* pctxt, AccelerationSet4Way* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode long_ */
   pctxt->level++;

   stat = asn1PD_Acceleration (pctxt, &pvalue->long_);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode lat */
   pctxt->level++;

   stat = asn1PD_Acceleration (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode vert */
   pctxt->level++;

   stat = asn1PD_VerticalAcceleration (pctxt, &pvalue->vert);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode yaw */
   pctxt->level++;

   stat = asn1PD_YawRate (pctxt, &pvalue->yaw);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_BrakeAppliedStatus (OSCTXT* pctxt, BrakeAppliedStatus* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_TractionControlStatus (OSCTXT* pctxt, TractionControlStatus* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 2);
   return stat;
}

EXTERN int asn1PD_AntiLockBrakeStatus (OSCTXT* pctxt, AntiLockBrakeStatus* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 2);
   return stat;
}

EXTERN int asn1PD_StabilityControlStatus (OSCTXT* pctxt, StabilityControlStatus* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 2);
   return stat;
}

EXTERN int asn1PD_BrakeBoostApplied (OSCTXT* pctxt, BrakeBoostApplied* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 2);
   if (stat != 0) return stat;

   if (*pvalue > 2) {
      return RTERR_CONSVIO;
   }
   return stat;
}

EXTERN int asn1PD_AuxiliaryBrakeStatus (OSCTXT* pctxt, AuxiliaryBrakeStatus* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 2);
   return stat;
}

EXTERN int asn1PD_BrakeSystemStatus (OSCTXT* pctxt, BrakeSystemStatus* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode wheelBrakes */
   pctxt->level++;

   stat = asn1PD_BrakeAppliedStatus (pctxt, &pvalue->wheelBrakes);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode traction */
   pctxt->level++;

   stat = asn1PD_TractionControlStatus (pctxt, &pvalue->traction);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode abs_ */
   pctxt->level++;

   stat = asn1PD_AntiLockBrakeStatus (pctxt, &pvalue->abs_);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode scs */
   pctxt->level++;

   stat = asn1PD_StabilityControlStatus (pctxt, &pvalue->scs);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode brakeBoost */
   pctxt->level++;

   stat = asn1PD_BrakeBoostApplied (pctxt, &pvalue->brakeBoost);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode auxBrakes */
   pctxt->level++;

   stat = asn1PD_AuxiliaryBrakeStatus (pctxt, &pvalue->auxBrakes);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_VehicleWidth (OSCTXT* pctxt, VehicleWidth* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 10);
   if (stat != 0) return stat;

   if (*pvalue > 1023) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_VehicleLength (OSCTXT* pctxt, VehicleLength* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 12);
   if (stat != 0) return stat;

   if (*pvalue > 4095) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_VehicleSize (OSCTXT* pctxt, VehicleSize* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode width */
   pctxt->level++;

   stat = asn1PD_VehicleWidth (pctxt, &pvalue->width);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode length */
   pctxt->level++;

   stat = asn1PD_VehicleLength (pctxt, &pvalue->length);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_BSMcoreData (OSCTXT* pctxt, BSMcoreData* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode msgCnt */
   pctxt->level++;

   stat = asn1PD_Common_MsgCount (pctxt, &pvalue->msgCnt);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode id */
   pctxt->level++;

   stat = asn1PD_TemporaryID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode secMark */
   pctxt->level++;

   stat = asn1PD_DSecond (pctxt, &pvalue->secMark);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode lat */
   pctxt->level++;

   stat = asn1PD_Latitude (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode long_ */
   pctxt->level++;

   stat = asn1PD_Longitude (pctxt, &pvalue->long_);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode elev */
   pctxt->level++;

   stat = asn1PD_Common_Elevation (pctxt, &pvalue->elev);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode accuracy */
   pctxt->level++;

   stat = asn1PD_PositionalAccuracy (pctxt, &pvalue->accuracy);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode transmission */
   pctxt->level++;

   stat = asn1PD_TransmissionState (pctxt, &pvalue->transmission);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode speed */
   pctxt->level++;

   stat = asn1PD_Speed (pctxt, &pvalue->speed);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode heading */
   pctxt->level++;

   stat = asn1PD_Heading (pctxt, &pvalue->heading);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode angle */
   pctxt->level++;

   stat = asn1PD_SteeringWheelAngle (pctxt, &pvalue->angle);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode accelSet */
   pctxt->level++;

   stat = asn1PD_AccelerationSet4Way (pctxt, &pvalue->accelSet);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode brakes */
   pctxt->level++;

   stat = asn1PD_BrakeSystemStatus (pctxt, &pvalue->brakes);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode size */
   pctxt->level++;

   stat = asn1PD_VehicleSize (pctxt, &pvalue->size);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_Priority (OSCTXT* pctxt, Priority* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_HeadingSlice (OSCTXT* pctxt, HeadingSlice* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_Extent (OSCTXT* pctxt, Extent* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 4);
   return stat;
}

EXTERN int asn1PD_ObstacleDistance (OSCTXT* pctxt, ObstacleDistance* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 32767) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_DYear (OSCTXT* pctxt, DYear* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 12);
   if (stat != 0) return stat;

   if (*pvalue > 4095) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_DMonth (OSCTXT* pctxt, DMonth* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 4);
   if (stat != 0) return stat;

   if (*pvalue > 12) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_DDay (OSCTXT* pctxt, DDay* pvalue)
{
   return rtxDecBitsToByte(pctxt, pvalue, 5);
}

EXTERN int asn1PD_DHour (OSCTXT* pctxt, DHour* pvalue)
{
   return rtxDecBitsToByte(pctxt, pvalue, 5);
}

EXTERN int asn1PD_DMinute (OSCTXT* pctxt, DMinute* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 6);
   if (stat != 0) return stat;

   if (*pvalue > 60) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_DOffset (OSCTXT* pctxt, DOffset* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 1681, range_bitcnt = 11 */
   stat = pd_ConsInt16(pctxt, pvalue, -840, 840);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_DDateTime (OSCTXT* pctxt, DDateTime* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[7];
   OSUINT32 j_ = 0;

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode year */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.yearPresent = 1;

            stat = asn1PD_DYear (pctxt, &pvalue->year);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode month */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.monthPresent = 1;

            stat = asn1PD_DMonth (pctxt, &pvalue->month);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode day */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.dayPresent = 1;

            stat = asn1PD_DDay (pctxt, &pvalue->day);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode hour */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.hourPresent = 1;

            stat = asn1PD_DHour (pctxt, &pvalue->hour);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode minute */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.minutePresent = 1;

            stat = asn1PD_DMinute (pctxt, &pvalue->minute);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode second */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.secondPresent = 1;

            stat = asn1PD_DSecond (pctxt, &pvalue->second);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode offset */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.offsetPresent = 1;

            stat = asn1PD_DOffset (pctxt, &pvalue->offset);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   return (stat);
}

EXTERN int asn1PD_VerticalAccelerationThreshold (OSCTXT* pctxt, VerticalAccelerationThreshold* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_GNSSstatus (OSCTXT* pctxt, GNSSstatus* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_Offset_B09 (OSCTXT* pctxt, Offset_B09* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 512, range_bitcnt = 9 */
   stat = pd_ConsInt16(pctxt, pvalue, -256, 255);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_AntennaOffsetSet (OSCTXT* pctxt, AntennaOffsetSet* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode antOffsetX */
   pctxt->level++;

   stat = asn1PD_Offset_B12 (pctxt, &pvalue->antOffsetX);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode antOffsetY */
   pctxt->level++;

   stat = asn1PD_Offset_B09 (pctxt, &pvalue->antOffsetY);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode antOffsetZ */
   pctxt->level++;

   stat = asn1PD_Offset_B10 (pctxt, &pvalue->antOffsetZ);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_RTCMheader (OSCTXT* pctxt, RTCMheader* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode status */
   pctxt->level++;

   stat = asn1PD_GNSSstatus (pctxt, &pvalue->status);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode offsetSet */
   pctxt->level++;

   stat = asn1PD_AntennaOffsetSet (pctxt, &pvalue->offsetSet);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_RTCMmessage (OSCTXT* pctxt, RTCMmessage* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1023), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_RTCMmessageList (OSCTXT* pctxt, RTCMmessageList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 5) {
      return RTERR_CONSVIO;
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      pctxt->level++;

      asn1Init_RTCMmessage (&pvalue->elem[xx1]);

      stat = asn1PD_RTCMmessage (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_SSPindex (OSCTXT* pctxt, SSPindex* pvalue)
{
   return rtxDecBitsToByte(pctxt, pvalue, 5);
}

EXTERN int asn1PD_SirenInUse (OSCTXT* pctxt, SirenInUse* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 2);
   return stat;
}

EXTERN int asn1PD_LightbarInUse (OSCTXT* pctxt, LightbarInUse* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 3);
   return stat;
}

EXTERN int asn1PD_MultiVehicleResponse (OSCTXT* pctxt, MultiVehicleResponse* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 2);
   return stat;
}

EXTERN int asn1PD_PrivilegedEventFlags (OSCTXT* pctxt, PrivilegedEventFlags* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_PrivilegedEvents (OSCTXT* pctxt, PrivilegedEvents* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode notUsed */
   pctxt->level++;

   stat = asn1PD_SSPindex (pctxt, &pvalue->notUsed);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode event */
   pctxt->level++;

   stat = asn1PD_PrivilegedEventFlags (pctxt, &pvalue->event);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_ResponseType (OSCTXT* pctxt, ResponseType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(6));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 6) {
         return RTERR_CONSVIO;
      }
   }

   return (stat);
}

EXTERN int asn1PD_EmergencyDetails (OSCTXT* pctxt, EmergencyDetails* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode notUsed */
   pctxt->level++;

   stat = asn1PD_SSPindex (pctxt, &pvalue->notUsed);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode sirenUse */
   pctxt->level++;

   stat = asn1PD_SirenInUse (pctxt, &pvalue->sirenUse);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode lightsUse */
   pctxt->level++;

   stat = asn1PD_LightbarInUse (pctxt, &pvalue->lightsUse);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode multi */
   pctxt->level++;

   stat = asn1PD_MultiVehicleResponse (pctxt, &pvalue->multi);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode events */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.eventsPresent = 1;

      stat = asn1PD_PrivilegedEvents (pctxt, &pvalue->events);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode responseType */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.responseTypePresent = 1;

      stat = asn1PD_ResponseType (pctxt, &pvalue->responseType);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_VehicleHeight (OSCTXT* pctxt, VehicleHeight* pvalue)
{
   return rtxDecBitsToByte(pctxt, pvalue, 7);
}

EXTERN int asn1PD_BumperHeight (OSCTXT* pctxt, BumperHeight* pvalue)
{
   return rtxDecBitsToByte(pctxt, pvalue, 7);
}

EXTERN int asn1PD_BumperHeights (OSCTXT* pctxt, BumperHeights* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode front */
   pctxt->level++;

   stat = asn1PD_BumperHeight (pctxt, &pvalue->front);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode rear */
   pctxt->level++;

   stat = asn1PD_BumperHeight (pctxt, &pvalue->rear);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_TimeOffset (OSCTXT* pctxt, TimeOffset* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, 16);
   if (stat != 0) return stat;

   if (*pvalue > 65534) {
      return RTERR_CONSVIO;
   }

   *pvalue += 1;

   return stat;
}

EXTERN int asn1PD_CoarseHeading (OSCTXT* pctxt, CoarseHeading* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 240) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_BasicVehicleClass (OSCTXT* pctxt, BasicVehicleClass* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_BasicVehicleRole (OSCTXT* pctxt, BasicVehicleRole* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(22));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 22) {
         return RTERR_CONSVIO;
      }
   }

   return (stat);
}

EXTERN int asn1PD_Iso3833VehicleType (OSCTXT* pctxt, Iso3833VehicleType* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 7);
   if (stat != 0) return stat;

   if (*pvalue > 100) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_VehicleType (OSCTXT* pctxt, VehicleType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(15));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_FuelType (OSCTXT* pctxt, FuelType* pvalue)
{
   return rtxDecBitsToByte(pctxt, pvalue, 4);
}

EXTERN int asn1PD_VehicleClassification_regional (OSCTXT* pctxt, VehicleClassification_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_VehicleClassification (OSCTXT* pctxt, VehicleClassification* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[9];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 9; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 9; i_++) {
      switch (i_) {
         case 0:
         /* decode keyType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.keyTypePresent = 1;

            stat = asn1PD_BasicVehicleClass (pctxt, &pvalue->keyType);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode role */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.rolePresent = 1;

            stat = asn1PD_BasicVehicleRole (pctxt, &pvalue->role);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode iso3883 */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.iso3883Present = 1;

            stat = asn1PD_Iso3833VehicleType (pctxt, &pvalue->iso3883);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode hpmsType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.hpmsTypePresent = 1;

            stat = asn1PD_VehicleType (pctxt, &pvalue->hpmsType);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode vehicleType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vehicleTypePresent = 1;

            stat = asn1PD_VehicleGroupAffected (pctxt, &pvalue->vehicleType);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode responseEquip */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.responseEquipPresent = 1;

            stat = asn1PD_IncidentResponseEquipment (pctxt, &pvalue->responseEquip);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode responderType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.responderTypePresent = 1;

            stat = asn1PD_ResponderGroupAffected (pctxt, &pvalue->responderType);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode fuelType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.fuelTypePresent = 1;

            stat = asn1PD_FuelType (pctxt, &pvalue->fuelType);

            pctxt->level--;
         }
         break;

         case 8:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_VehicleClassification_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_VehicleMass (OSCTXT* pctxt, VehicleMass* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_Axles (OSCTXT* pctxt, Axles* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode totalAxles */
   pctxt->level++;

   {
      OSBOOL extbit1;
      /* extension bit */

      rtxDecBit(pctxt, &extbit1);

      if (!extbit1) {
         stat = pd_ConsUnsigned(pctxt, &pvalue->totalAxles,  1,  10);
         if (stat != 0) return stat;
      }
      else {
         stat = pd_UnconsUnsigned (pctxt, &pvalue->totalAxles);
      }
   }

   pctxt->level--;

   /* decode frontAxles */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.frontAxlesPresent = 1;

      {
         OSBOOL extbit1;
         /* extension bit */

         rtxDecBit(pctxt, &extbit1);

         if (!extbit1) {
            stat = pd_ConsUnsigned(pctxt, &pvalue->frontAxles,  0,  10);
            if (stat != 0) return stat;
         }
         else {
            stat = pd_UnconsUnsigned (pctxt, &pvalue->frontAxles);
         }
      }

      pctxt->level--;
   }

   /* decode rearAxles */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.rearAxlesPresent = 1;

      {
         OSBOOL extbit1;
         /* extension bit */

         rtxDecBit(pctxt, &extbit1);

         if (!extbit1) {
            stat = pd_ConsUnsigned(pctxt, &pvalue->rearAxles,  0,  10);
            if (stat != 0) return stat;
         }
         else {
            stat = pd_UnconsUnsigned (pctxt, &pvalue->rearAxles);
         }
      }

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_TrailerWeight (OSCTXT* pctxt, TrailerWeight* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, 16);
   if (stat != 0) return stat;

   if (*pvalue > 64255) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_CoefficientOfFriction (OSCTXT* pctxt, CoefficientOfFriction* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 6);
   if (stat != 0) return stat;

   if (*pvalue > 50) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_AmbientAirTemperature (OSCTXT* pctxt, AmbientAirTemperature* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 191) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_AmbientAirPressure (OSCTXT* pctxt, AmbientAirPressure* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_WiperStatus (OSCTXT* pctxt, WiperStatus* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(6));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 6) {
         return RTERR_CONSVIO;
      }
   }

   return (stat);
}

EXTERN int asn1PD_WiperRate (OSCTXT* pctxt, WiperRate* pvalue)
{
   return rtxDecBitsToByte(pctxt, pvalue, 7);
}

EXTERN int asn1PD_WiperSet (OSCTXT* pctxt, WiperSet* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode statusFront */
   pctxt->level++;

   stat = asn1PD_WiperStatus (pctxt, &pvalue->statusFront);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode rateFront */
   pctxt->level++;

   stat = asn1PD_WiperRate (pctxt, &pvalue->rateFront);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode statusRear */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.statusRearPresent = 1;

      stat = asn1PD_WiperStatus (pctxt, &pvalue->statusRear);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode rateRear */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.rateRearPresent = 1;

      stat = asn1PD_WiperRate (pctxt, &pvalue->rateRear);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_TrailerUnitDescJ2945Slash1B (OSCTXT* pctxt, TrailerUnitDescJ2945Slash1B* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 8; i_++) {
      switch (i_) {
         case 0:
         /* decode width */
         pctxt->level++;

         stat = asn1PD_VehicleWidth (pctxt, &pvalue->width);

         pctxt->level--;
         break;

         case 1:
         /* decode length */
         pctxt->level++;

         stat = asn1PD_VehicleLength (pctxt, &pvalue->length);

         pctxt->level--;
         break;

         case 2:
         /* decode height */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.heightPresent = 1;

            stat = asn1PD_VehicleHeight (pctxt, &pvalue->height);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode weight */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.weightPresent = 1;

            stat = asn1PD_TrailerWeight (pctxt, &pvalue->weight);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode frontPivot */
         pctxt->level++;

         pvalue->frontPivot = rtxMemAllocType (pctxt, PivotPointDescription);

         if (pvalue->frontPivot == NULL)
            return RTERR_NOMEM;

         asn1Init_PivotPointDescription ((PivotPointDescription*)pvalue->frontPivot);

         stat = asn1PD_PivotPointDescription (pctxt, (PivotPointDescription*)pvalue->frontPivot);

         pctxt->level--;
         break;

         case 5:
         /* decode rearPivot */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.rearPivotPresent = 1;

            pvalue->rearPivot = rtxMemAllocType (pctxt, 
               PivotPointDescription);

            if (pvalue->rearPivot == NULL)
               return RTERR_NOMEM;

            asn1Init_PivotPointDescription ((PivotPointDescription*)pvalue->rearPivot);

            stat = asn1PD_PivotPointDescription (pctxt, (PivotPointDescription*)pvalue->rearPivot);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode bumpers */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.bumpersPresent = 1;

            stat = asn1PD_BumperHeights (pctxt, &pvalue->bumpers);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode axles */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.axlesPresent = 1;

            stat = asn1PD_Axles (pctxt, &pvalue->axles);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_TrailersJ2945Slash1B (OSCTXT* pctxt, TrailersJ2945Slash1B* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TrailerUnitDescJ2945Slash1B* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, TrailerUnitDescJ2945Slash1B);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_TrailerUnitDescJ2945Slash1B (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TrailerUnitDescJ2945Slash1B (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_MinuteOfTheYear (OSCTXT* pctxt, MinuteOfTheYear* pvalue)
{
   return pd_ConsUnsigned(pctxt, pvalue,  0,  527040);
}

EXTERN int asn1PD_ApproachID (OSCTXT* pctxt, ApproachID* pvalue)
{
   return rtxDecBitsToByte(pctxt, pvalue, 4);
}

EXTERN int asn1PD_CodeWord (OSCTXT* pctxt, CodeWord* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_Confidence (OSCTXT* pctxt, Confidence* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 200) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_Count (OSCTXT* pctxt, Count* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 6);
   if (stat != 0) return stat;

   if (*pvalue > 32) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_DeltaAngle (OSCTXT* pctxt, DeltaAngle* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 301, range_bitcnt = 9 */
   stat = pd_ConsInt16(pctxt, pvalue, -150, 150);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_DescriptiveName (OSCTXT* pctxt, DescriptiveName* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(63), 0, 0);

   stat = pd_ConstrainedStringEx (pctxt, pvalue, 0, 8, 7, 7);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_DrivenLineOffsetLg (OSCTXT* pctxt, DrivenLineOffsetLg* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 65535, range_bitcnt = 16 */
   stat = pd_ConsInt16(pctxt, pvalue, -32767, 32767);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_DrivenLineOffsetSm (OSCTXT* pctxt, DrivenLineOffsetSm* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 4095, range_bitcnt = 12 */
   stat = pd_ConsInt16(pctxt, pvalue, -2047, 2047);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_Duration (OSCTXT* pctxt, Duration* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 12);
   if (stat != 0) return stat;

   if (*pvalue > 3600) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_ElevationConfidence (OSCTXT* pctxt, ElevationConfidence* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 4);
   return stat;
}

EXTERN int asn1PD_ExteriorLights (OSCTXT* pctxt, ExteriorLights* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(9), OSUINTCONST(9), 
      OSUINTCONST(0), OSUINT32_MAX);

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         PD_BYTE_ALIGN(pctxt);

      }

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return RTERR_NOMEM;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   return (stat);
}

EXTERN int asn1PD_PortlandCementType (OSCTXT* pctxt, PortlandCementType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(2));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 2) {
         return RTERR_CONSVIO;
      }
   }

   return (stat);
}

EXTERN int asn1PD_AsphaltOrTarType (OSCTXT* pctxt, AsphaltOrTarType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(3));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_GravelType (OSCTXT* pctxt, GravelType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(1));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_GrassType (OSCTXT* pctxt, GrassType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      *pvalue = lessThan30Mph;
   }

   return (stat);
}

EXTERN int asn1PD_CindersType (OSCTXT* pctxt, CindersType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      *pvalue = packed;
   }

   return (stat);
}

EXTERN int asn1PD_RockType (OSCTXT* pctxt, RockType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      *pvalue = crushed;
   }

   return (stat);
}

EXTERN int asn1PD_IceType (OSCTXT* pctxt, IceType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      *pvalue = smooth;
   }

   return (stat);
}

EXTERN int asn1PD_SnowType (OSCTXT* pctxt, SnowType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(1));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_RoadSurfaceCondition (OSCTXT* pctxt, RoadSurfaceCondition* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(1));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_MeanVariation (OSCTXT* pctxt, MeanVariation* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 25000) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_VariationStdDev (OSCTXT* pctxt, VariationStdDev* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 12);
   if (stat != 0) return stat;

   if (*pvalue > 2500) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_FurtherInfoID (OSCTXT* pctxt, FurtherInfoID* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_HeadingConfidence (OSCTXT* pctxt, HeadingConfidence* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 3);
   return stat;
}

EXTERN int asn1PD_IntersectionID (OSCTXT* pctxt, IntersectionID* pvalue)
{
   PD_BYTE_ALIGN(pctxt);
   return rtxDecBitsToUInt16(pctxt, pvalue, 16);
}

EXTERN int asn1PD_LaneConnectionID (OSCTXT* pctxt, LaneConnectionID* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_LaneWidth (OSCTXT* pctxt, LaneWidth* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 32767) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_Location_quality (OSCTXT* pctxt, Location_quality* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 3);
   return stat;
}

EXTERN int asn1PD_Location_tech (OSCTXT* pctxt, Location_tech* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(9));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 9) {
         return RTERR_CONSVIO;
      }
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_MergeDivergeNodeAngle (OSCTXT* pctxt, MergeDivergeNodeAngle* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 361, range_bitcnt = 9 */
   stat = pd_ConsInt16(pctxt, pvalue, -180, 180);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_MessageBLOB (OSCTXT* pctxt, MessageBLOB* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(2000), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_NodeAttributeXY (OSCTXT* pctxt, NodeAttributeXY* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(11));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 11) {
         return RTERR_CONSVIO;
      }
   }

   return (stat);
}

EXTERN int asn1PD_OffsetLL_B18 (OSCTXT* pctxt, OffsetLL_B18* pvalue)
{
   return pd_ConsInteger(pctxt, pvalue,  -131072,  131071);
}

EXTERN int asn1PD_PayloadData (OSCTXT* pctxt, PayloadData* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2048), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_PositionConfidence (OSCTXT* pctxt, PositionConfidence* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 4);
   return stat;
}

EXTERN int asn1PD_RadiusOfCurvature (OSCTXT* pctxt, RadiusOfCurvature* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 65535, range_bitcnt = 16 */
   stat = pd_ConsInt16(pctxt, pvalue, -32767, 32767);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_RequestID (OSCTXT* pctxt, RequestID* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_RequestImportanceLevel (OSCTXT* pctxt, RequestImportanceLevel* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 4);
   return stat;
}

EXTERN int asn1PD_RequestSubRole (OSCTXT* pctxt, RequestSubRole* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 4);
   return stat;
}

EXTERN int asn1PD_RestrictionClassID (OSCTXT* pctxt, RestrictionClassID* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_FullRoadAuthorityID (OSCTXT* pctxt, FullRoadAuthorityID* pvalue)
{
   int stat = 0;

   stat = pd_ObjectIdentifier (pctxt, pvalue);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_RelativeRoadAuthorityID (OSCTXT* pctxt, RelativeRoadAuthorityID* pvalue)
{
   int stat = 0;

   stat = pd_RelativeOID (pctxt, pvalue);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_RoadRegulatorID (OSCTXT* pctxt, RoadRegulatorID* pvalue)
{
   PD_BYTE_ALIGN(pctxt);
   return rtxDecBitsToUInt16(pctxt, pvalue, 16);
}

EXTERN int asn1PD_RoadSegmentID (OSCTXT* pctxt, RoadSegmentID* pvalue)
{
   PD_BYTE_ALIGN(pctxt);
   return rtxDecBitsToUInt16(pctxt, pvalue, 16);
}

EXTERN int asn1PD_RoadwayCrownAngle (OSCTXT* pctxt, RoadwayCrownAngle* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 256, range_bitcnt = 8 */
   stat = pd_ConsInt8(pctxt, pvalue, -128, 127);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_Scale_B12 (OSCTXT* pctxt, Scale_B12* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 4096, range_bitcnt = 12 */
   stat = pd_ConsInt16(pctxt, pvalue, -2048, 2047);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_SegmentAttributeXY (OSCTXT* pctxt, SegmentAttributeXY* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(37));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 37) {
         return RTERR_CONSVIO;
      }
   }

   return (stat);
}

EXTERN int asn1PD_SignalReqScheme (OSCTXT* pctxt, SignalReqScheme* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_SpeedConfidence (OSCTXT* pctxt, SpeedConfidence* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 3);
   return stat;
}

EXTERN int asn1PD_SpeedLimitType (OSCTXT* pctxt, SpeedLimitType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(12));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 12) {
         return RTERR_CONSVIO;
      }
   }

   return (stat);
}

EXTERN int asn1PD_ThrottleConfidence (OSCTXT* pctxt, ThrottleConfidence* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 2);
   return stat;
}

EXTERN int asn1PD_TimeConfidence (OSCTXT* pctxt, TimeConfidence* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 6);
   if (stat != 0) return stat;

   if (*pvalue > 39) {
      return RTERR_CONSVIO;
   }
   return stat;
}

EXTERN int asn1PD_TransitStatus (OSCTXT* pctxt, TransitStatus* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_URL_Link (OSCTXT* pctxt, URL_Link* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pd_ConstrainedStringEx (pctxt, pvalue, 0, 8, 7, 7);
   if (stat != 0) return stat;

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_VehicleEventFlags (OSCTXT* pctxt, VehicleEventFlags* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(13), OSUINTCONST(13), 
      OSUINTCONST(14), OSUINTCONST(14));

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         PD_BYTE_ALIGN(pctxt);

      }

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return RTERR_NOMEM;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   return (stat);
}

EXTERN int asn1PD_Velocity (OSCTXT* pctxt, Velocity* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 13);
   if (stat != 0) return stat;

   if (*pvalue > 8191) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_VertOffset_B08 (OSCTXT* pctxt, VertOffset_B08* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 256, range_bitcnt = 8 */
   stat = pd_ConsInt8(pctxt, pvalue, -128, 127);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_VertOffset_B09 (OSCTXT* pctxt, VertOffset_B09* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 512, range_bitcnt = 9 */
   stat = pd_ConsInt16(pctxt, pvalue, -256, 255);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_VertOffset_B10 (OSCTXT* pctxt, VertOffset_B10* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 1024, range_bitcnt = 10 */
   stat = pd_ConsInt16(pctxt, pvalue, -512, 511);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_VertOffset_B11 (OSCTXT* pctxt, VertOffset_B11* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 2048, range_bitcnt = 11 */
   stat = pd_ConsInt16(pctxt, pvalue, -1024, 1023);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_VertOffset_B12 (OSCTXT* pctxt, VertOffset_B12* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 4096, range_bitcnt = 12 */
   stat = pd_ConsInt16(pctxt, pvalue, -2048, 2047);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_ComputedLane_offsetXaxis (OSCTXT* pctxt, ComputedLane_offsetXaxis* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   {
      OSBOOL b_ = 0;
      DEC_BIT (pctxt, &b_);
      ui = b_;
   }
   pvalue->t = ui + 1;

   switch (ui) {
      /* small_ */
      case 0:
         pctxt->level++;

         stat = asn1PD_DrivenLineOffsetSm (pctxt, &pvalue->u.small_);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* large_ */
      case 1:
         pctxt->level++;

         stat = asn1PD_DrivenLineOffsetLg (pctxt, &pvalue->u.large_);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_ComputedLane_offsetYaxis (OSCTXT* pctxt, ComputedLane_offsetYaxis* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   {
      OSBOOL b_ = 0;
      DEC_BIT (pctxt, &b_);
      ui = b_;
   }
   pvalue->t = ui + 1;

   switch (ui) {
      /* small_ */
      case 0:
         pctxt->level++;

         stat = asn1PD_DrivenLineOffsetSm (pctxt, &pvalue->u.small_);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* large_ */
      case 1:
         pctxt->level++;

         stat = asn1PD_DrivenLineOffsetLg (pctxt, &pvalue->u.large_);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_ComputedLane_regional (OSCTXT* pctxt, ComputedLane_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_ComputedLane (OSCTXT* pctxt, ComputedLane* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode referenceLaneId */
         pctxt->level++;

         stat = asn1PD_LaneID (pctxt, &pvalue->referenceLaneId);

         pctxt->level--;
         break;

         case 1:
         /* decode offsetXaxis */
         pctxt->level++;

         stat = asn1PD_ComputedLane_offsetXaxis (pctxt, &pvalue->offsetXaxis);

         pctxt->level--;
         break;

         case 2:
         /* decode offsetYaxis */
         pctxt->level++;

         stat = asn1PD_ComputedLane_offsetYaxis (pctxt, &pvalue->offsetYaxis);

         pctxt->level--;
         break;

         case 3:
         /* decode rotateXY */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.rotateXYPresent = 1;

            stat = asn1PD_Common_Angle (pctxt, &pvalue->rotateXY);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode scaleXaxis */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.scaleXaxisPresent = 1;

            stat = asn1PD_Scale_B12 (pctxt, &pvalue->scaleXaxis);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode scaleYaxis */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.scaleYaxisPresent = 1;

            stat = asn1PD_Scale_B12 (pctxt, &pvalue->scaleYaxis);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_ComputedLane_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_DDate (OSCTXT* pctxt, DDate* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode year */
   pctxt->level++;

   stat = asn1PD_DYear (pctxt, &pvalue->year);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode month */
   pctxt->level++;

   stat = asn1PD_DMonth (pctxt, &pvalue->month);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode day */
   pctxt->level++;

   stat = asn1PD_DDay (pctxt, &pvalue->day);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_DFullTime (OSCTXT* pctxt, DFullTime* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode year */
   pctxt->level++;

   stat = asn1PD_DYear (pctxt, &pvalue->year);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode month */
   pctxt->level++;

   stat = asn1PD_DMonth (pctxt, &pvalue->month);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode day */
   pctxt->level++;

   stat = asn1PD_DDay (pctxt, &pvalue->day);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode hour */
   pctxt->level++;

   stat = asn1PD_DHour (pctxt, &pvalue->hour);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode minute */
   pctxt->level++;

   stat = asn1PD_DMinute (pctxt, &pvalue->minute);
   if (stat != 0) return stat;

   pctxt->level--;

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_DMonthDay (OSCTXT* pctxt, DMonthDay* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode month */
   pctxt->level++;

   stat = asn1PD_DMonth (pctxt, &pvalue->month);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode day */
   pctxt->level++;

   stat = asn1PD_DDay (pctxt, &pvalue->day);
   if (stat != 0) return stat;

   pctxt->level--;

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_DTime (OSCTXT* pctxt, DTime* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode hour */
   pctxt->level++;

   stat = asn1PD_DHour (pctxt, &pvalue->hour);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode minute */
   pctxt->level++;

   stat = asn1PD_DMinute (pctxt, &pvalue->minute);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode second */
   pctxt->level++;

   stat = asn1PD_DSecond (pctxt, &pvalue->second);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode offset */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.offsetPresent = 1;

      stat = asn1PD_DOffset (pctxt, &pvalue->offset);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_DYearMonth (OSCTXT* pctxt, DYearMonth* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode year */
   pctxt->level++;

   stat = asn1PD_DYear (pctxt, &pvalue->year);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode month */
   pctxt->level++;

   stat = asn1PD_DMonth (pctxt, &pvalue->month);
   if (stat != 0) return stat;

   pctxt->level--;

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_TransmissionAndSpeed (OSCTXT* pctxt, TransmissionAndSpeed* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode transmisson */
   pctxt->level++;

   stat = asn1PD_TransmissionState (pctxt, &pvalue->transmisson);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode speed */
   pctxt->level++;

   stat = asn1PD_Velocity (pctxt, &pvalue->speed);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_PositionConfidenceSet (OSCTXT* pctxt, PositionConfidenceSet* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode pos */
   pctxt->level++;

   stat = asn1PD_PositionConfidence (pctxt, &pvalue->pos);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode elevation */
   pctxt->level++;

   stat = asn1PD_ElevationConfidence (pctxt, &pvalue->elevation);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_SpeedandHeadingandThrottleConfidence (OSCTXT* pctxt, SpeedandHeadingandThrottleConfidence* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode heading */
   pctxt->level++;

   stat = asn1PD_HeadingConfidence (pctxt, &pvalue->heading);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode speed */
   pctxt->level++;

   stat = asn1PD_SpeedConfidence (pctxt, &pvalue->speed);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode throttle */
   pctxt->level++;

   stat = asn1PD_ThrottleConfidence (pctxt, &pvalue->throttle);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_FullPositionVector (OSCTXT* pctxt, FullPositionVector* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[8];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 8; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 10; i_++) {
      switch (i_) {
         case 0:
         /* decode utcTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.utcTimePresent = 1;

            stat = asn1PD_DDateTime (pctxt, &pvalue->utcTime);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode long_ */
         pctxt->level++;

         stat = asn1PD_Longitude (pctxt, &pvalue->long_);

         pctxt->level--;
         break;

         case 2:
         /* decode lat */
         pctxt->level++;

         stat = asn1PD_Latitude (pctxt, &pvalue->lat);

         pctxt->level--;
         break;

         case 3:
         /* decode elevation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.elevationPresent = 1;

            stat = asn1PD_Common_Elevation (pctxt, &pvalue->elevation);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode heading */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.headingPresent = 1;

            stat = asn1PD_Heading (pctxt, &pvalue->heading);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode speed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.speedPresent = 1;

            stat = asn1PD_TransmissionAndSpeed (pctxt, &pvalue->speed);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode posAccuracy */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.posAccuracyPresent = 1;

            stat = asn1PD_PositionalAccuracy (pctxt, &pvalue->posAccuracy);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode timeConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.timeConfidencePresent = 1;

            stat = asn1PD_TimeConfidence (pctxt, &pvalue->timeConfidence);

            pctxt->level--;
         }
         break;

         case 8:
         /* decode posConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.posConfidencePresent = 1;

            stat = asn1PD_PositionConfidenceSet (pctxt, &pvalue->posConfidence);

            pctxt->level--;
         }
         break;

         case 9:
         /* decode speedConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.speedConfidencePresent = 1;

            stat = asn1PD_SpeedandHeadingandThrottleConfidence (pctxt, &pvalue->speedConfidence);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_Header (OSCTXT* pctxt, Header* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode year */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.yearPresent = 1;

            stat = asn1PD_DYear (pctxt, &pvalue->year);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->timeStamp);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode secMark */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.secMarkPresent = 1;

            stat = asn1PD_DSecond (pctxt, &pvalue->secMark);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode msgIssueRevision */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.msgIssueRevisionPresent = 1;

            stat = asn1PD_Common_MsgCount (pctxt, &pvalue->msgIssueRevision);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_IntersectionAccessPoint (OSCTXT* pctxt, IntersectionAccessPoint* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      stat = rtxDecBits(pctxt, &ui, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* lane */
         case 0:
            pctxt->level++;

            stat = asn1PD_LaneID (pctxt, &pvalue->u.lane);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* approach */
         case 1:
            pctxt->level++;

            stat = asn1PD_ApproachID (pctxt, &pvalue->u.approach);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* connection */
         case 2:
            pctxt->level++;

            stat = asn1PD_LaneConnectionID (pctxt, &pvalue->u.connection);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_IntersectionReferenceID (OSCTXT* pctxt, IntersectionReferenceID* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode region */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.regionPresent = 1;

      stat = asn1PD_RoadRegulatorID (pctxt, &pvalue->region);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode id */
   pctxt->level++;

   stat = asn1PD_IntersectionID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_RegulatorySpeedLimit (OSCTXT* pctxt, RegulatorySpeedLimit* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode type */
   pctxt->level++;

   stat = asn1PD_SpeedLimitType (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode speed */
   pctxt->level++;

   stat = asn1PD_Velocity (pctxt, &pvalue->speed);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_SpeedLimitList (OSCTXT* pctxt, SpeedLimitList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(9), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegulatorySpeedLimit* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegulatorySpeedLimit);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegulatorySpeedLimit (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_LaneDataAttribute_regional (OSCTXT* pctxt, LaneDataAttribute_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_LaneDataAttribute (OSCTXT* pctxt, LaneDataAttribute* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      stat = rtxDecBits(pctxt, &ui, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* pathEndPointAngle */
         case 0:
            pctxt->level++;

            stat = asn1PD_DeltaAngle (pctxt, &pvalue->u.pathEndPointAngle);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* laneCrownPointCenter */
         case 1:
            pctxt->level++;

            stat = asn1PD_RoadwayCrownAngle (pctxt, &pvalue->u.laneCrownPointCenter);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* laneCrownPointLeft */
         case 2:
            pctxt->level++;

            stat = asn1PD_RoadwayCrownAngle (pctxt, &pvalue->u.laneCrownPointLeft);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* laneCrownPointRight */
         case 3:
            pctxt->level++;

            stat = asn1PD_RoadwayCrownAngle (pctxt, &pvalue->u.laneCrownPointRight);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* laneAngle */
         case 4:
            pctxt->level++;

            stat = asn1PD_MergeDivergeNodeAngle (pctxt, &pvalue->u.laneAngle);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* speedLimits */
         case 5:
            pctxt->level++;

            pvalue->u.speedLimits = rtxMemAllocType (pctxt, SpeedLimitList);

            if (pvalue->u.speedLimits == NULL)
               return RTERR_NOMEM;

            asn1Init_SpeedLimitList (pvalue->u.speedLimits);

            stat = asn1PD_SpeedLimitList (pctxt, pvalue->u.speedLimits);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* regional */
         case 6:
            pctxt->level++;

            pvalue->u.regional = rtxMemAllocType (pctxt, 
               LaneDataAttribute_regional);

            if (pvalue->u.regional == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneDataAttribute_regional (pvalue->u.regional);

            stat = asn1PD_LaneDataAttribute_regional (pctxt, pvalue->u.regional);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 8;

      if (pvalue->t < 8) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_LaneDataAttributeList (OSCTXT* pctxt, LaneDataAttributeList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      LaneDataAttribute* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, LaneDataAttribute);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_LaneDataAttribute (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_LaneDataAttribute (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_NodeAttributeXYList (OSCTXT* pctxt, NodeAttributeXYList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 8) {
      return RTERR_CONSVIO;
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      pctxt->level++;

      stat = asn1PD_NodeAttributeXY (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_SegmentAttributeXYList (OSCTXT* pctxt, SegmentAttributeXYList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 8) {
      return RTERR_CONSVIO;
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      pctxt->level++;

      stat = asn1PD_SegmentAttributeXY (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_NodeAttributeSetXY_regional (OSCTXT* pctxt, NodeAttributeSetXY_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_NodeAttributeSetXY (OSCTXT* pctxt, NodeAttributeSetXY* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[7];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode localNode */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.localNodePresent = 1;

            stat = asn1PD_NodeAttributeXYList (pctxt, &pvalue->localNode);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode disabled */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.disabledPresent = 1;

            stat = asn1PD_SegmentAttributeXYList (pctxt, &pvalue->disabled);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode enabled */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.enabledPresent = 1;

            stat = asn1PD_SegmentAttributeXYList (pctxt, &pvalue->enabled);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode data */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.dataPresent = 1;

            stat = asn1PD_LaneDataAttributeList (pctxt, &pvalue->data);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode dWidth */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.dWidthPresent = 1;

            stat = asn1PD_Offset_B10 (pctxt, &pvalue->dWidth);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode dElevation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.dElevationPresent = 1;

            stat = asn1PD_Offset_B10 (pctxt, &pvalue->dElevation);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_NodeAttributeSetXY_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NodeXY (OSCTXT* pctxt, NodeXY* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode delta */
   pctxt->level++;

   stat = asn1PD_NodeOffsetPointXY (pctxt, &pvalue->delta);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode attributes */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.attributesPresent = 1;

      stat = asn1PD_NodeAttributeSetXY (pctxt, &pvalue->attributes);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NodeSetXY (OSCTXT* pctxt, NodeSetXY* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(63), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NodeXY* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, NodeXY);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_NodeXY (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NodeXY (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_NodeListXY (OSCTXT* pctxt, NodeListXY* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      {
         OSBOOL b_ = 0;
         DEC_BIT (pctxt, &b_);
         ui = b_;
      }
      pvalue->t = ui + 1;

      switch (ui) {
         /* nodes */
         case 0:
            pctxt->level++;

            pvalue->u.nodes = rtxMemAllocType (pctxt, NodeSetXY);

            if (pvalue->u.nodes == NULL)
               return RTERR_NOMEM;

            asn1Init_NodeSetXY (pvalue->u.nodes);

            stat = asn1PD_NodeSetXY (pctxt, pvalue->u.nodes);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* computed */
         case 1:
            pctxt->level++;

            pvalue->u.computed = rtxMemAllocType (pctxt, ComputedLane);

            if (pvalue->u.computed == NULL)
               return RTERR_NOMEM;

            asn1Init_ComputedLane (pvalue->u.computed);

            stat = asn1PD_ComputedLane (pctxt, pvalue->u.computed);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_PathHistoryPoint (OSCTXT* pctxt, PathHistoryPoint* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode latOffset */
         pctxt->level++;

         stat = asn1PD_OffsetLL_B18 (pctxt, &pvalue->latOffset);

         pctxt->level--;
         break;

         case 1:
         /* decode lonOffset */
         pctxt->level++;

         stat = asn1PD_OffsetLL_B18 (pctxt, &pvalue->lonOffset);

         pctxt->level--;
         break;

         case 2:
         /* decode elevationOffset */
         pctxt->level++;

         stat = asn1PD_VertOffset_B12 (pctxt, &pvalue->elevationOffset);

         pctxt->level--;
         break;

         case 3:
         /* decode timeOffset */
         pctxt->level++;

         stat = asn1PD_TimeOffset (pctxt, &pvalue->timeOffset);

         pctxt->level--;
         break;

         case 4:
         /* decode speed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.speedPresent = 1;

            stat = asn1PD_Speed (pctxt, &pvalue->speed);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode posAccuracy */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.posAccuracyPresent = 1;

            stat = asn1PD_PositionalAccuracy (pctxt, &pvalue->posAccuracy);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode heading */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.headingPresent = 1;

            stat = asn1PD_CoarseHeading (pctxt, &pvalue->heading);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_PathHistoryPointList (OSCTXT* pctxt, PathHistoryPointList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(23), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PathHistoryPoint* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, PathHistoryPoint);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_PathHistoryPoint (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PathHistoryPoint (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_PathHistory (OSCTXT* pctxt, PathHistory* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode initialPosition */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.initialPositionPresent = 1;

      stat = asn1PD_FullPositionVector (pctxt, &pvalue->initialPosition);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode currGNSSstatus */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.currGNSSstatusPresent = 1;

      stat = asn1PD_GNSSstatus (pctxt, &pvalue->currGNSSstatus);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode crumbData */
   pctxt->level++;

   stat = asn1PD_PathHistoryPointList (pctxt, &pvalue->crumbData);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_PathPrediction (OSCTXT* pctxt, PathPrediction* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode radiusOfCurve */
   pctxt->level++;

   stat = asn1PD_RadiusOfCurvature (pctxt, &pvalue->radiusOfCurve);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode confidence */
   pctxt->level++;

   stat = asn1PD_Confidence (pctxt, &pvalue->confidence);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_Position3D_regional (OSCTXT* pctxt, Position3D_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_Position3D (OSCTXT* pctxt, Position3D* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode lat */
   pctxt->level++;

   stat = asn1PD_Latitude (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode long_ */
   pctxt->level++;

   stat = asn1PD_Longitude (pctxt, &pvalue->long_);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode elevation */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.elevationPresent = 1;

      stat = asn1PD_Common_Elevation (pctxt, &pvalue->elevation);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode regional */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.regionalPresent = 1;

      stat = asn1PD_Position3D_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RequestorType (OSCTXT* pctxt, RequestorType* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode role */
         pctxt->level++;

         stat = asn1PD_BasicVehicleRole (pctxt, &pvalue->role);

         pctxt->level--;
         break;

         case 1:
         /* decode subrole */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.subrolePresent = 1;

            stat = asn1PD_RequestSubRole (pctxt, &pvalue->subrole);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode request */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.requestPresent = 1;

            stat = asn1PD_RequestImportanceLevel (pctxt, &pvalue->request);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode iso3883 */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.iso3883Present = 1;

            stat = asn1PD_Iso3833VehicleType (pctxt, &pvalue->iso3883);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode hpmsType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.hpmsTypePresent = 1;

            stat = asn1PD_VehicleType (pctxt, &pvalue->hpmsType);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RoadSegmentReferenceID (OSCTXT* pctxt, RoadSegmentReferenceID* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode region */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.regionPresent = 1;

      stat = asn1PD_RoadRegulatorID (pctxt, &pvalue->region);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode id */
   pctxt->level++;

   stat = asn1PD_RoadSegmentID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_VehicleID (OSCTXT* pctxt, VehicleID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   {
      OSBOOL b_ = 0;
      DEC_BIT (pctxt, &b_);
      ui = b_;
   }
   pvalue->t = ui + 1;

   switch (ui) {
      /* entityID */
      case 0:
         pctxt->level++;

         pvalue->u.entityID = rtxMemAllocType (pctxt, TemporaryID);

         if (pvalue->u.entityID == NULL)
            return RTERR_NOMEM;

         asn1Init_TemporaryID (pvalue->u.entityID);

         stat = asn1PD_TemporaryID (pctxt, pvalue->u.entityID);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* stationID */
      case 1:
         pctxt->level++;

         stat = asn1PD_StationID (pctxt, &pvalue->u.stationID);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_VehicleSafetyExtensions (OSCTXT* pctxt, VehicleSafetyExtensions* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode events */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.eventsPresent = 1;

            stat = asn1PD_VehicleEventFlags (pctxt, &pvalue->events);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode pathHistory */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.pathHistoryPresent = 1;

            stat = asn1PD_PathHistory (pctxt, &pvalue->pathHistory);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode pathPrediction */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.pathPredictionPresent = 1;

            stat = asn1PD_PathPrediction (pctxt, &pvalue->pathPrediction);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode lights */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.lightsPresent = 1;

            stat = asn1PD_ExteriorLights (pctxt, &pvalue->lights);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            if (i_ < 2) {  /* known element */
               OSUINT32 openTypeLen;
               size_t bitStartOffset, bitLength;
               size_t bitEndOffset, bitsConsumed;

               stat = pd_UnconsLength (pctxt, &openTypeLen);
               if (stat < 0) {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return stat;
               }
               else if (stat == RT_OK_FRAG) {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return RTERR_NOTSUPP;
               }
               bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
               bitLength = openTypeLen * 8;

               if (openTypeLen > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.timestampPresent = 1;
                        pctxt->level++;

                        stat = asn1PD_DDateTime (pctxt, &pvalue->timestamp);

                        if (stat != 0) break;

                        pctxt->level--;

                        break;

                     case 1:
                        pvalue->m.heightPresent = 1;
                        pctxt->level++;

                        stat = asn1PD_VehicleHeight (pctxt, &pvalue->height);

                        if (stat != 0) break;

                        pctxt->level--;

                        break;

                  }
               }

               if (0 == stat) {
                  bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
                  bitsConsumed = bitEndOffset - bitStartOffset;
                  if (bitsConsumed < bitLength) {
                     stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
                  }
                  else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
               }
            }
            else {
               stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

               if (0 == stat) {
                  pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
                  if (0 != pOpenType) {
                     pOpenType->numocts = openType.numocts;
                     pOpenType->data = openType.data;
                     rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
                  }
                  else stat = RTERR_NOMEM;
               }
               else {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return stat;
               }
            }
         }
         else if (i_ >= 2) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_VerticalOffset (OSCTXT* pctxt, VerticalOffset* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = rtxDecBits(pctxt, &ui, 3);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* offset1 */
      case 0:
         pctxt->level++;

         stat = asn1PD_VertOffset_B07 (pctxt, (VertOffset_B07*)&pvalue->u.offset1);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* offset2 */
      case 1:
         pctxt->level++;

         stat = asn1PD_VertOffset_B08 (pctxt, &pvalue->u.offset2);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* offset3 */
      case 2:
         pctxt->level++;

         stat = asn1PD_VertOffset_B09 (pctxt, &pvalue->u.offset3);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* offset4 */
      case 3:
         pctxt->level++;

         stat = asn1PD_VertOffset_B10 (pctxt, &pvalue->u.offset4);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* offset5 */
      case 4:
         pctxt->level++;

         stat = asn1PD_VertOffset_B11 (pctxt, &pvalue->u.offset5);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* offset6 */
      case 5:
         pctxt->level++;

         stat = asn1PD_VertOffset_B12 (pctxt, &pvalue->u.offset6);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* elevation */
      case 6:
         pctxt->level++;

         stat = asn1PD_Common_Elevation (pctxt, &pvalue->u.elevation);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* regional */
      case 7:
         pctxt->level++;

         pvalue->u.regional = rtxMemAllocType (pctxt, RegionalExtension);

         if (pvalue->u.regional == NULL)
            return RTERR_NOMEM;

         asn1Init_RegionalExtension (pvalue->u.regional);

         stat = asn1PD_RegionalExtension (pctxt, pvalue->u.regional);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      default:
         return RTERR_INVOPT;
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_PortlandCement (OSCTXT* pctxt, PortlandCement* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode type */
   pctxt->level++;

   stat = asn1PD_PortlandCementType (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_AsphaltOrTar (OSCTXT* pctxt, AsphaltOrTar* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode type */
   pctxt->level++;

   stat = asn1PD_AsphaltOrTarType (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_Gravel (OSCTXT* pctxt, Gravel* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode type */
   pctxt->level++;

   stat = asn1PD_GravelType (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_Grass (OSCTXT* pctxt, Grass* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode type */
   pctxt->level++;

   stat = asn1PD_GrassType (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_Cinders (OSCTXT* pctxt, Cinders* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode type */
   pctxt->level++;

   stat = asn1PD_CindersType (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_Rock (OSCTXT* pctxt, Rock* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode type */
   pctxt->level++;

   stat = asn1PD_RockType (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_Ice (OSCTXT* pctxt, Ice* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode type */
   pctxt->level++;

   stat = asn1PD_IceType (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_Snow (OSCTXT* pctxt, Snow* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode type */
   pctxt->level++;

   stat = asn1PD_SnowType (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_DescriptionOfRoadSurface (OSCTXT* pctxt, DescriptionOfRoadSurface* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      stat = rtxDecBits(pctxt, &ui, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* portlandCement */
         case 0:
            pctxt->level++;

            pvalue->u.portlandCement = rtxMemAllocType (pctxt, 
               PortlandCement);

            if (pvalue->u.portlandCement == NULL)
               return RTERR_NOMEM;

            asn1Init_PortlandCement (pvalue->u.portlandCement);

            stat = asn1PD_PortlandCement (pctxt, pvalue->u.portlandCement);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* asphaltOrTar */
         case 1:
            pctxt->level++;

            pvalue->u.asphaltOrTar = rtxMemAllocType (pctxt, AsphaltOrTar);

            if (pvalue->u.asphaltOrTar == NULL)
               return RTERR_NOMEM;

            asn1Init_AsphaltOrTar (pvalue->u.asphaltOrTar);

            stat = asn1PD_AsphaltOrTar (pctxt, pvalue->u.asphaltOrTar);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* gravel */
         case 2:
            pctxt->level++;

            pvalue->u.gravel = rtxMemAllocType (pctxt, Gravel);

            if (pvalue->u.gravel == NULL)
               return RTERR_NOMEM;

            asn1Init_Gravel (pvalue->u.gravel);

            stat = asn1PD_Gravel (pctxt, pvalue->u.gravel);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* grass */
         case 3:
            pctxt->level++;

            pvalue->u.grass = rtxMemAllocType (pctxt, Grass);

            if (pvalue->u.grass == NULL)
               return RTERR_NOMEM;

            asn1Init_Grass (pvalue->u.grass);

            stat = asn1PD_Grass (pctxt, pvalue->u.grass);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* cinders */
         case 4:
            pctxt->level++;

            pvalue->u.cinders = rtxMemAllocType (pctxt, Cinders);

            if (pvalue->u.cinders == NULL)
               return RTERR_NOMEM;

            asn1Init_Cinders (pvalue->u.cinders);

            stat = asn1PD_Cinders (pctxt, pvalue->u.cinders);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* rock */
         case 5:
            pctxt->level++;

            pvalue->u.rock = rtxMemAllocType (pctxt, Rock);

            if (pvalue->u.rock == NULL)
               return RTERR_NOMEM;

            asn1Init_Rock (pvalue->u.rock);

            stat = asn1PD_Rock (pctxt, pvalue->u.rock);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* ice */
         case 6:
            pctxt->level++;

            pvalue->u.ice = rtxMemAllocType (pctxt, Ice);

            if (pvalue->u.ice == NULL)
               return RTERR_NOMEM;

            asn1Init_Ice (pvalue->u.ice);

            stat = asn1PD_Ice (pctxt, pvalue->u.ice);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* snow */
         case 7:
            pctxt->level++;

            pvalue->u.snow = rtxMemAllocType (pctxt, Snow);

            if (pvalue->u.snow == NULL)
               return RTERR_NOMEM;

            asn1Init_Snow (pvalue->u.snow);

            stat = asn1PD_Snow (pctxt, pvalue->u.snow);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 9;

      if (pvalue->t < 9) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_RoadRoughness (OSCTXT* pctxt, RoadRoughness* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode meanVerticalVariation */
         pctxt->level++;

         stat = asn1PD_MeanVariation (pctxt, &pvalue->meanVerticalVariation);

         pctxt->level--;
         break;

         case 1:
         /* decode verticalVariationStdDev */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.verticalVariationStdDevPresent = 1;

            stat = asn1PD_VariationStdDev (pctxt, &pvalue->verticalVariationStdDev);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode meanHorizontalVariation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.meanHorizontalVariationPresent = 1;

            stat = asn1PD_MeanVariation (pctxt, &pvalue->meanHorizontalVariation);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode horizontalVariationStdDev */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.horizontalVariationStdDevPresent = 1;

            stat = asn1PD_VariationStdDev (pctxt, &pvalue->horizontalVariationStdDev);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_FrictionInformation (OSCTXT* pctxt, FrictionInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode roadSurfaceDescription */
   pctxt->level++;

   stat = asn1PD_DescriptionOfRoadSurface (pctxt, &pvalue->roadSurfaceDescription);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode dryOrWet */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.dryOrWetPresent = 1;

      stat = asn1PD_RoadSurfaceCondition (pctxt, &pvalue->dryOrWet);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode roadRoughness */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.roadRoughnessPresent = 1;

      stat = asn1PD_RoadRoughness (pctxt, &pvalue->roadRoughness);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RoadAuthorityID (OSCTXT* pctxt, RoadAuthorityID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      {
         OSBOOL b_ = 0;
         DEC_BIT (pctxt, &b_);
         ui = b_;
      }
      pvalue->t = ui + 1;

      switch (ui) {
         /* fullRdAuthID */
         case 0:
            pctxt->level++;

            pvalue->u.fullRdAuthID = rtxMemAllocType (pctxt, 
               FullRoadAuthorityID);

            if (pvalue->u.fullRdAuthID == NULL)
               return RTERR_NOMEM;

            asn1Init_FullRoadAuthorityID (pvalue->u.fullRdAuthID);

            stat = asn1PD_FullRoadAuthorityID (pctxt, pvalue->u.fullRdAuthID);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* relRdAuthID */
         case 1:
            pctxt->level++;

            pvalue->u.relRdAuthID = rtxMemAllocType (pctxt, 
               RelativeRoadAuthorityID);

            if (pvalue->u.relRdAuthID == NULL)
               return RTERR_NOMEM;

            asn1Init_RelativeRoadAuthorityID (pvalue->u.relRdAuthID);

            stat = asn1PD_RelativeRoadAuthorityID (pctxt, pvalue->u.relRdAuthID);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

