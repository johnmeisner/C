/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "SignalRequestMessage.h"
#include "REGION.h"
#include "Common.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PD_DeltaTime (OSCTXT* pctxt, DeltaTime* pvalue)
{
   int stat;

   /* range_value = 244, range_bitcnt = 8 */
   stat = pd_ConsInt8(pctxt, pvalue, -122, 121);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_PriorityRequestType (OSCTXT* pctxt, PriorityRequestType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(3));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_TransitVehicleOccupancy (OSCTXT* pctxt, TransitVehicleOccupancy* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 3);
   return stat;
}

EXTERN int asn1PD_TransitVehicleStatus (OSCTXT* pctxt, TransitVehicleStatus* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_SignalRequest_regional (OSCTXT* pctxt, SignalRequest_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_SignalRequest (OSCTXT* pctxt, SignalRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode id */
   pctxt->level++;

   pvalue->id = rtxMemAllocType (pctxt, IntersectionReferenceID);

   if (pvalue->id == NULL)
      return RTERR_NOMEM;

   asn1Init_IntersectionReferenceID ((IntersectionReferenceID*)pvalue->id);

   stat = asn1PD_IntersectionReferenceID (pctxt, (IntersectionReferenceID*)pvalue->id);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode requestID */
   pctxt->level++;

   stat = asn1PD_RequestID (pctxt, (RequestID*)&pvalue->requestID);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode requestType */
   pctxt->level++;

   stat = asn1PD_PriorityRequestType (pctxt, &pvalue->requestType);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode inBoundLane */
   pctxt->level++;

   pvalue->inBoundLane = rtxMemAllocType (pctxt, IntersectionAccessPoint);

   if (pvalue->inBoundLane == NULL)
      return RTERR_NOMEM;

   asn1Init_IntersectionAccessPoint ((IntersectionAccessPoint*)pvalue->inBoundLane);

   stat = asn1PD_IntersectionAccessPoint (pctxt, (IntersectionAccessPoint*)pvalue->inBoundLane);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode outBoundLane */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.outBoundLanePresent = 1;

      pvalue->outBoundLane = rtxMemAllocType (pctxt, IntersectionAccessPoint);

      if (pvalue->outBoundLane == NULL)
         return RTERR_NOMEM;

      asn1Init_IntersectionAccessPoint ((IntersectionAccessPoint*)pvalue->outBoundLane);

      stat = asn1PD_IntersectionAccessPoint (pctxt, (IntersectionAccessPoint*)pvalue->outBoundLane);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode regional */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.regionalPresent = 1;

      stat = asn1PD_SignalRequest_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_SignalRequestPackage_regional (OSCTXT* pctxt, SignalRequestPackage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_SignalRequestPackage (OSCTXT* pctxt, SignalRequestPackage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode request */
         pctxt->level++;

         stat = asn1PD_SignalRequest (pctxt, &pvalue->request);

         pctxt->level--;
         break;

         case 1:
         /* decode minute */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.minutePresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, (MinuteOfTheYear*)&pvalue->minute);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode second */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.secondPresent = 1;

            stat = asn1PD_DSecond (pctxt, (DSecond*)&pvalue->second);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode duration */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.durationPresent = 1;

            stat = asn1PD_DSecond (pctxt, (DSecond*)&pvalue->duration);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_SignalRequestPackage_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_SignalRequestList (OSCTXT* pctxt, SignalRequestList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SignalRequestPackage* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, SignalRequestPackage);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_SignalRequestPackage (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SignalRequestPackage (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_RequestorPositionVector (OSCTXT* pctxt, RequestorPositionVector* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode position */
   pctxt->level++;

   pvalue->position = rtxMemAllocType (pctxt, Position3D);

   if (pvalue->position == NULL)
      return RTERR_NOMEM;

   asn1Init_Position3D ((Position3D*)pvalue->position);

   stat = asn1PD_Position3D (pctxt, (Position3D*)pvalue->position);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode heading */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.headingPresent = 1;

      stat = asn1PD_Common_Angle (pctxt, (Common_Angle*)&pvalue->heading);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode speed */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.speedPresent = 1;

      pvalue->speed = rtxMemAllocTypeZ (pctxt, TransmissionAndSpeed);

      if (pvalue->speed == NULL)
         return RTERR_NOMEM;

      stat = asn1PD_TransmissionAndSpeed (pctxt, (TransmissionAndSpeed*)pvalue->speed);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RequestorDescription_regional (OSCTXT* pctxt, RequestorDescription_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_RequestorDescription (OSCTXT* pctxt, RequestorDescription* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[8];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 8; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 9; i_++) {
      switch (i_) {
         case 0:
         /* decode id */
         pctxt->level++;

         pvalue->id = rtxMemAllocType (pctxt, VehicleID);

         if (pvalue->id == NULL)
            return RTERR_NOMEM;

         asn1Init_VehicleID ((VehicleID*)pvalue->id);

         stat = asn1PD_VehicleID (pctxt, (VehicleID*)pvalue->id);

         pctxt->level--;
         break;

         case 1:
         /* decode type */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.typePresent = 1;

            pvalue->type = rtxMemAllocType (pctxt, RequestorType);

            if (pvalue->type == NULL)
               return RTERR_NOMEM;

            asn1Init_RequestorType ((RequestorType*)pvalue->type);

            stat = asn1PD_RequestorType (pctxt, (RequestorType*)pvalue->type);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode position */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.positionPresent = 1;

            stat = asn1PD_RequestorPositionVector (pctxt, &pvalue->position);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, (DescriptiveName*)&pvalue->name);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode routeName */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.routeNamePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, (DescriptiveName*)&pvalue->routeName);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode transitStatus */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.transitStatusPresent = 1;

            stat = asn1PD_TransitVehicleStatus (pctxt, &pvalue->transitStatus);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode transitOccupancy */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.transitOccupancyPresent = 1;

            stat = asn1PD_TransitVehicleOccupancy (pctxt, &pvalue->transitOccupancy);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode transitSchedule */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.transitSchedulePresent = 1;

            stat = asn1PD_DeltaTime (pctxt, &pvalue->transitSchedule);

            pctxt->level--;
         }
         break;

         case 8:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_RequestorDescription_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_SignalRequestMessage_regional (OSCTXT* pctxt, SignalRequestMessage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_SignalRequestMessage (OSCTXT* pctxt, SignalRequestMessage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, (MinuteOfTheYear*)&pvalue->timeStamp);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode second */
         pctxt->level++;

         stat = asn1PD_DSecond (pctxt, (DSecond*)&pvalue->second);

         pctxt->level--;
         break;

         case 2:
         /* decode sequenceNumber */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.sequenceNumberPresent = 1;

            stat = asn1PD_Common_MsgCount (pctxt, (Common_MsgCount*)&pvalue->sequenceNumber);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode requests */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.requestsPresent = 1;

            stat = asn1PD_SignalRequestList (pctxt, &pvalue->requests);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode requestor */
         pctxt->level++;

         stat = asn1PD_RequestorDescription (pctxt, &pvalue->requestor);

         pctxt->level--;
         break;

         case 5:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_SignalRequestMessage_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

