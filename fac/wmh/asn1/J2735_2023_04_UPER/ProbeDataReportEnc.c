/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "ProbeDataReport.h"
#include "Common.h"
#include "RoadWeatherMessage.h"
#include "ProbeDataConfig.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PE_RptVehicleClass (OSCTXT* pctxt, RptVehicleClass value)
{
   int stat = 0;

   if (value >= 14) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value - 1, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_ProbeDataReport_MeanVariation (OSCTXT* pctxt, ProbeDataReport_MeanVariation value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  25000);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_StdDev (OSCTXT* pctxt, StdDev value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  10000);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RptWiperStatus (OSCTXT* pctxt, RptWiperStatus value)
{
   int stat = 0;

   if (value >= 4) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RptCommSysPerfEvents_rfDataRsuInfo (OSCTXT* pctxt, RptCommSysPerfEvents_rfDataRsuInfo* pvalue)
{
   int stat = 0;

   if (pvalue->numocts != 6) {
      return RTERR_CONSVIO;
   }
   stat = pe_byte_align (pctxt);
   if (stat != 0) return stat;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 48);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RptVelocity (OSCTXT* pctxt, RptVelocity* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedStdDevPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headingPresent);

   /* encode speed */

   stat = asn1PE_Speed (pctxt, pvalue->speed);
   if (stat != 0) return stat;

   /* encode speedStdDev */

   if (pvalue->m.speedStdDevPresent) {
      stat = asn1PE_StdDev (pctxt, pvalue->speedStdDev);
      if (stat != 0) return stat;
   }

   /* encode heading */

   if (pvalue->m.headingPresent) {
      stat = asn1PE_Heading (pctxt, pvalue->heading);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RptDevType (OSCTXT* pctxt, RptDevType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.mcoCapablePresent);

   /* encode oemOrAftermarket */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->oemOrAftermarket);
   if (stat != 0) return stat;

   /* encode canOrIvnConnected */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->canOrIvnConnected);
   if (stat != 0) return stat;

   /* encode mcoCapable */

   if (pvalue->m.mcoCapablePresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->mcoCapable);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_ReportCharacteristics (OSCTXT* pctxt, ReportCharacteristics* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehicleClassPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.devTypePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehicleSizePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehicleMassPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehPassengerCountPresent);

   /* encode timeStamp */

   stat = asn1PE_DDateTime (pctxt, (DDateTime*)pvalue->timeStamp);
   if (stat != 0) return stat;

   /* encode position */

   stat = asn1PE_Position3D (pctxt, (Position3D*)pvalue->position);
   if (stat != 0) return stat;

   /* encode posAccuracy */

   stat = asn1PE_PositionalAccuracy (pctxt, (PositionalAccuracy*)pvalue->posAccuracy);
   if (stat != 0) return stat;

   /* encode velocity */

   stat = asn1PE_RptVelocity (pctxt, &pvalue->velocity);
   if (stat != 0) return stat;

   /* encode vehicleClass */

   if (pvalue->m.vehicleClassPresent) {
      stat = asn1PE_RptVehicleClass (pctxt, pvalue->vehicleClass);
      if (stat != 0) return stat;
   }

   /* encode devType */

   if (pvalue->m.devTypePresent) {
      stat = asn1PE_RptDevType (pctxt, &pvalue->devType);
      if (stat != 0) return stat;
   }

   /* encode vehicleSize */

   if (pvalue->m.vehicleSizePresent) {
      stat = asn1PE_VehicleSize (pctxt, (VehicleSize*)pvalue->vehicleSize);
      if (stat != 0) return stat;
   }

   /* encode vehicleMass */

   if (pvalue->m.vehicleMassPresent) {
      stat = asn1PE_VehicleMass (pctxt, pvalue->vehicleMass);
      if (stat != 0) return stat;
   }

   /* encode vehPassengerCount */

   if (pvalue->m.vehPassengerCountPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->vehPassengerCount,  1,  255);
      if (stat != 0) return stat;

   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RptVehicleReport (OSCTXT* pctxt, RptVehicleReport* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_NtcipEssData (pctxt, (NtcipEssData*)((NtcipEssData*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_RptTransitVehData (OSCTXT* pctxt, RptTransitVehData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.currNumPasngersPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgNumPasngersPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.trnstVehSchAdhPresent);

   /* encode currNumPasngers */

   if (pvalue->m.currNumPasngersPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->currNumPasngers,  0,  255);
      if (stat != 0) return stat;

   }

   /* encode avgNumPasngers */

   if (pvalue->m.avgNumPasngersPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->avgNumPasngers,  0,  255);
      if (stat != 0) return stat;

   }

   /* encode trnstVehSchAdh */

   if (pvalue->m.trnstVehSchAdhPresent) {
      stat = pe_ConsInteger(pctxt, pvalue->trnstVehSchAdh,  -200,  55);
      if (stat != 0) return stat;

   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RptIntervalEvents (OSCTXT* pctxt, RptIntervalEvents* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.wiperStatusPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehCountPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.weatherDataPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.transitVehDataPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.numOfOccupantsPresent);

   /* encode wiperStatus */

   if (pvalue->m.wiperStatusPresent) {
      stat = asn1PE_RptWiperStatus (pctxt, pvalue->wiperStatus);
      if (stat != 0) return stat;
   }

   /* encode vehCount */

   if (pvalue->m.vehCountPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->vehCount,  0,  10000);
      if (stat != 0) return stat;

   }

   /* encode weatherData */

   if (pvalue->m.weatherDataPresent) {
      stat = asn1PE_RptVehicleReport (pctxt, &pvalue->weatherData);
      if (stat != 0) return stat;
   }

   /* encode transitVehData */

   if (pvalue->m.transitVehDataPresent) {
      stat = asn1PE_RptTransitVehData (pctxt, &pvalue->transitVehData);
      if (stat != 0) return stat;
   }

   /* encode numOfOccupants */

   if (pvalue->m.numOfOccupantsPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->numOfOccupants,  0,  255);
      if (stat != 0) return stat;

   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RptEvents (OSCTXT* pctxt, RptEvents* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 5);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 3);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* absActive */
         case 1:
            stat = rtxEncBit (pctxt, (OSBOOL)pvalue->u.absActive);
            if (stat != 0) return stat;
            break;

         /* tractionCtlLoss */
         case 2:
            stat = rtxEncBit (pctxt, (OSBOOL)pvalue->u.tractionCtlLoss);
            if (stat != 0) return stat;
            break;

         /* stabilityCtlActive */
         case 3:
            stat = rtxEncBit (pctxt, (OSBOOL)pvalue->u.stabilityCtlActive);
            if (stat != 0) return stat;
            break;

         /* hardBraking */
         case 4:
            stat = rtxEncBit (pctxt, (OSBOOL)pvalue->u.hardBraking);
            if (stat != 0) return stat;
            break;

         /* swerve */
         case 5:
            stat = rtxEncBit (pctxt, (OSBOOL)pvalue->u.swerve);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 6);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_RptHysteresis (OSCTXT* pctxt, RptHysteresis* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.positionalAccuracyPresent);

   /* encode time_ */

   stat = asn1PE_DTime (pctxt, (DTime*)pvalue->time_);
   if (stat != 0) return stat;

   /* encode position */

   stat = asn1PE_Position3D (pctxt, (Position3D*)pvalue->position);
   if (stat != 0) return stat;

   /* encode positionalAccuracy */

   if (pvalue->m.positionalAccuracyPresent) {
      stat = asn1PE_PositionalAccuracy (pctxt, (PositionalAccuracy*)pvalue->positionalAccuracy);
      if (stat != 0) return stat;
   }

   /* encode velocity */

   stat = asn1PE_RptVelocity (pctxt, &pvalue->velocity);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RptHysteresisRecord (OSCTXT* pctxt, RptHysteresisRecord* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(20), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RptHysteresis (pctxt, ((RptHysteresis*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_RptKinematicEvents (OSCTXT* pctxt, RptKinematicEvents* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.hysteresisPresent);

   /* encode events */

   stat = asn1PE_RptEvents (pctxt, &pvalue->events);
   if (stat != 0) return stat;

   /* encode hysteresis */

   if (pvalue->m.hysteresisPresent) {
      stat = asn1PE_RptHysteresisRecord (pctxt, &pvalue->hysteresis);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RptDriverAlertsAndWarnings (OSCTXT* pctxt, RptDriverAlertsAndWarnings* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 10);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 4);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* j2945Slash1Eebl */
         case 1:
            /* NULL */
            break;

         /* j2945Slash1Fcw */
         case 2:
            /* NULL */
            break;

         /* j2945Slash1BswLcw */
         case 3:
            /* NULL */
            break;

         /* j2945Slash1Ima */
         case 4:
            /* NULL */
            break;

         /* j2945Slash1Lta */
         case 5:
            /* NULL */
            break;

         /* j2945Slash1Clw */
         case 6:
            /* NULL */
            break;

         /* redLightViolationWarn */
         case 7:
            /* NULL */
            break;

         /* emerVehAlert */
         case 8:
            /* NULL */
            break;

         /* otherAlert */
         case 9:
            /* NULL */
            break;

         /* otherWarning */
         case 10:
            /* NULL */
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 11);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_RptVehicleEvents (OSCTXT* pctxt, RptVehicleEvents* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 15);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 4);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* headLights */
         case 1:
            /* NULL */
            break;

         /* fogLights */
         case 2:
            /* NULL */
            break;

         /* hazardLights */
         case 3:
            /* NULL */
            break;

         /* kinematicEvents */
         case 4:
            stat = asn1PE_RptKinematicEvents (pctxt, pvalue->u.kinematicEvents);
            if (stat != 0) return stat;
            break;

         /* wiperStatusChange */
         case 5:
            /* NULL */
            break;

         /* lowSpeed */
         case 6:
            /* NULL */
            break;

         /* resumedSpeed */
         case 7:
            /* NULL */
            break;

         /* vehEntrsExitsRegion */
         case 8:
            /* NULL */
            break;

         /* emerVehDetect */
         case 9:
            /* NULL */
            break;

         /* emerVehLightBar */
         case 10:
            /* NULL */
            break;

         /* reqTspEvp */
         case 11:
            /* NULL */
            break;

         /* transitVehPassCnt */
         case 12:
            /* NULL */
            break;

         /* transitVehDoor */
         case 13:
            /* NULL */
            break;

         /* v2xMsgRecption */
         case 14:
            /* NULL */
            break;

         /* driverAlertsAndWarnings */
         case 15:
            stat = asn1PE_RptDriverAlertsAndWarnings (pctxt, pvalue->u.driverAlertsAndWarnings);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 16);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_RptRoadRoughness (OSCTXT* pctxt, RptRoadRoughness* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.verticalVariationStdDevPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.meanHorizontalVariationPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.horizontalVariationStdDevPresent);

   /* encode meanVerticalVariation */

   stat = asn1PE_ProbeDataReport_MeanVariation (pctxt, pvalue->meanVerticalVariation);
   if (stat != 0) return stat;

   /* encode verticalVariationStdDev */

   if (pvalue->m.verticalVariationStdDevPresent) {
      stat = asn1PE_StdDev (pctxt, pvalue->verticalVariationStdDev);
      if (stat != 0) return stat;
   }

   /* encode meanHorizontalVariation */

   if (pvalue->m.meanHorizontalVariationPresent) {
      stat = asn1PE_ProbeDataReport_MeanVariation (pctxt, pvalue->meanHorizontalVariation);
      if (stat != 0) return stat;
   }

   /* encode horizontalVariationStdDev */

   if (pvalue->m.horizontalVariationStdDevPresent) {
      stat = asn1PE_StdDev (pctxt, pvalue->horizontalVariationStdDev);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RptTrafficMetrics (OSCTXT* pctxt, RptTrafficMetrics* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 7);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 3);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* trfsigApproachDelay */
         case 1:
            /* NULL */
            break;

         /* trfsigApproachSpeed */
         case 2:
            /* NULL */
            break;

         /* trfsigArrivalGreen */
         case 3:
            /* NULL */
            break;

         /* trfsigArrivalRed */
         case 4:
            /* NULL */
            break;

         /* trfsigPedDelay */
         case 5:
            /* NULL */
            break;

         /* trfsigSpatMismatch */
         case 6:
            /* NULL */
            break;

         /* trfsigSpatTimingError */
         case 7:
            /* NULL */
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 8);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_RptTrafficSigEncounters (OSCTXT* pctxt, RptTrafficSigEncounters* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.intersectionIDPresent);

   /* encode intersectionID */

   if (pvalue->m.intersectionIDPresent) {
      stat = asn1PE_IntersectionID (pctxt, pvalue->intersectionID);
      if (stat != 0) return stat;
   }

   /* encode trafficMetrics */

   stat = asn1PE_RptTrafficMetrics (pctxt, &pvalue->trafficMetrics);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RptRoadwayEvents (OSCTXT* pctxt, RptRoadwayEvents* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 15);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 4);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* obstacleDetected */
         case 1:
            /* NULL */
            break;

         /* adverseRoadSurface */
         case 2:
            stat = asn1PE_RptRoadRoughness (pctxt, pvalue->u.adverseRoadSurface);
            if (stat != 0) return stat;
            break;

         /* trfsigEncounters */
         case 3:
            stat = asn1PE_RptTrafficSigEncounters (pctxt, pvalue->u.trfsigEncounters);
            if (stat != 0) return stat;
            break;

         /* trfsigLightOut */
         case 4:
            /* NULL */
            break;

         /* trfsigRoadGeoMismatch */
         case 5:
            /* NULL */
            break;

         /* roadsignDetection */
         case 6:
            /* NULL */
            break;

         /* lowRoadsignReflect */
         case 7:
            /* NULL */
            break;

         /* lowLaneMarkReflect */
         case 8:
            /* NULL */
            break;

         /* roadsignIncnstncy */
         case 9:
            /* NULL */
            break;

         /* laneGeoIncnstncy */
         case 10:
            /* NULL */
            break;

         /* incidentDetect */
         case 11:
            /* NULL */
            break;

         /* workZoneCharDetect */
         case 12:
            /* NULL */
            break;

         /* inclWeatherDetect */
         case 13:
            /* NULL */
            break;

         /* railrdCrossActiv */
         case 14:
            /* NULL */
            break;

         /* drawBridgeActiv */
         case 15:
            /* NULL */
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 16);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_RptCommSysPerfEvents (OSCTXT* pctxt, RptCommSysPerfEvents* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 11);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 4);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* j2945_1ChanBusy */
         case 1:
            /* NULL */
            break;

         /* rfDataRsuInfo */
         case 2:
            stat = asn1PE_RptCommSysPerfEvents_rfDataRsuInfo (pctxt, pvalue->u.rfDataRsuInfo);
            if (stat != 0) return stat;
            break;

         /* numOfRsusObserved */
         case 3:
            stat = pe_ConsUnsigned(pctxt, pvalue->u.numOfRsusObserved,  1,  255);
            if (stat != 0) return stat;

            break;

         /* rfV2xJamDetect */
         case 4:
            /* NULL */
            break;

         /* j2945_1VehDens */
         case 5:
            /* NULL */
            break;

         /* j2945_1CqiBelow */
         case 6:
            /* NULL */
            break;

         /* j2945_1TrackingError */
         case 7:
            /* NULL */
            break;

         /* gnssHdopExceeds */
         case 8:
            /* NULL */
            break;

         /* gnssErrElipse */
         case 9:
            /* NULL */
            break;

         /* gnssSatsBelow */
         case 10:
            /* NULL */
            break;

         /* jammingDetect */
         case 11:
            /* NULL */
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 12);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_RptInstantaneousRecordData (OSCTXT* pctxt, RptInstantaneousRecordData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 4);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 2);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* intervalEvents */
         case 1:
            stat = asn1PE_RptIntervalEvents (pctxt, pvalue->u.intervalEvents);
            if (stat != 0) return stat;
            break;

         /* vehEvents */
         case 2:
            stat = asn1PE_RptVehicleEvents (pctxt, pvalue->u.vehEvents);
            if (stat != 0) return stat;
            break;

         /* roadwayEvents */
         case 3:
            stat = asn1PE_RptRoadwayEvents (pctxt, pvalue->u.roadwayEvents);
            if (stat != 0) return stat;
            break;

         /* commSysPerfEvents */
         case 4:
            stat = asn1PE_RptCommSysPerfEvents (pctxt, pvalue->u.commSysPerfEvents);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 5);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_RptInstantaneousRecord (OSCTXT* pctxt, RptInstantaneousRecord* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.recordPresent);

   /* encode timeOfInstantRec */

   stat = asn1PE_DDateTime (pctxt, (DDateTime*)pvalue->timeOfInstantRec);
   if (stat != 0) return stat;

   /* encode locOfInstantRec */

   stat = asn1PE_Position3D (pctxt, (Position3D*)pvalue->locOfInstantRec);
   if (stat != 0) return stat;

   /* encode accOfPosition */

   stat = asn1PE_PositionalAccuracy (pctxt, (PositionalAccuracy*)pvalue->accOfPosition);
   if (stat != 0) return stat;

   /* encode velOfInstantRec */

   stat = asn1PE_RptVelocity (pctxt, &pvalue->velOfInstantRec);
   if (stat != 0) return stat;

   /* encode record */

   if (pvalue->m.recordPresent) {
      stat = asn1PE_RptInstantaneousRecordData (pctxt, &pvalue->record);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RptInstantaneousRecords (OSCTXT* pctxt, RptInstantaneousRecords* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), OSUINTCONST(0), OSUINT32_MAX);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RptInstantaneousRecord (pctxt, ((RptInstantaneousRecord*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_RptEmissions (OSCTXT* pctxt, RptEmissions* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.hydrocarbonsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.coPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.co2Present);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.noPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.no2Present);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.so2Present);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.o3Present);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pm10Present);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pm25Present);

   /* encode hydrocarbons */

   if (pvalue->m.hydrocarbonsPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->hydrocarbons,  1,  1000);
      if (stat != 0) return stat;

   }

   /* encode co */

   if (pvalue->m.coPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->co,  1,  1000);
      if (stat != 0) return stat;

   }

   /* encode co2 */

   if (pvalue->m.co2Present) {
      stat = pe_ConsUnsigned(pctxt, pvalue->co2,  1,  1000);
      if (stat != 0) return stat;

   }

   /* encode no */

   if (pvalue->m.noPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->no,  1,  1000);
      if (stat != 0) return stat;

   }

   /* encode no2 */

   if (pvalue->m.no2Present) {
      stat = pe_ConsUnsigned(pctxt, pvalue->no2,  1,  1000);
      if (stat != 0) return stat;

   }

   /* encode so2 */

   if (pvalue->m.so2Present) {
      stat = pe_ConsUnsigned(pctxt, pvalue->so2,  1,  1000);
      if (stat != 0) return stat;

   }

   /* encode o3 */

   if (pvalue->m.o3Present) {
      stat = pe_ConsUnsigned(pctxt, pvalue->o3,  1,  1000);
      if (stat != 0) return stat;

   }

   /* encode pm10 */

   if (pvalue->m.pm10Present) {
      stat = pe_ConsUnsigned(pctxt, pvalue->pm10,  1,  1000);
      if (stat != 0) return stat;

   }

   /* encode pm25 */

   if (pvalue->m.pm25Present) {
      stat = pe_ConsUnsigned(pctxt, pvalue->pm25,  1,  1000);
      if (stat != 0) return stat;

   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RptAveragedRecord (OSCTXT* pctxt, RptAveragedRecord* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgSpeedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedStdDevPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgStopDurationPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgStopStdDevPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgFuelConsumptionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgEmissionsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgNumOfOccupantsPresent);

   /* encode avgSpeed */

   if (pvalue->m.avgSpeedPresent) {
      stat = asn1PE_Speed (pctxt, pvalue->avgSpeed);
      if (stat != 0) return stat;
   }

   /* encode speedStdDev */

   if (pvalue->m.speedStdDevPresent) {
      stat = asn1PE_StdDev (pctxt, pvalue->speedStdDev);
      if (stat != 0) return stat;
   }

   /* encode avgStopDuration */

   if (pvalue->m.avgStopDurationPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->avgStopDuration,  1,  36000);
      if (stat != 0) return stat;

   }

   /* encode avgStopStdDev */

   if (pvalue->m.avgStopStdDevPresent) {
      stat = asn1PE_StdDev (pctxt, pvalue->avgStopStdDev);
      if (stat != 0) return stat;
   }

   /* encode avgFuelConsumption */

   if (pvalue->m.avgFuelConsumptionPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->avgFuelConsumption,  1,  255);
      if (stat != 0) return stat;

   }

   /* encode avgEmissions */

   if (pvalue->m.avgEmissionsPresent) {
      stat = asn1PE_RptEmissions (pctxt, &pvalue->avgEmissions);
      if (stat != 0) return stat;
   }

   /* encode avgNumOfOccupants */

   if (pvalue->m.avgNumOfOccupantsPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->avgNumOfOccupants,  1,  255);
      if (stat != 0) return stat;

   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RptLocOfStops (OSCTXT* pctxt, RptLocOfStops* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode locationOfStop */

   stat = asn1PE_Position3D (pctxt, (Position3D*)pvalue->locationOfStop);
   if (stat != 0) return stat;

   /* encode locAccOfStop */

   stat = asn1PE_PositionalAccuracy (pctxt, (PositionalAccuracy*)pvalue->locAccOfStop);
   if (stat != 0) return stat;

   /* encode durationOfStop */

   stat = pe_ConsUnsigned(pctxt, pvalue->durationOfStop,  1,  36000);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RptSummaryRecord (OSCTXT* pctxt, RptSummaryRecord* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regTravelTimePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regVehDistTraveledPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regVehTimeTraveledPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.fuelConsumptionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.totalVehEmissionsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.numOfLowSpeedEventsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStoppedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.numOfStoppedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.locOfStopsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regNumOfVehPassedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regNumOfSurpassedVehPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.totalMsgsReceivedPresent);

   /* encode regTravelTime */

   if (pvalue->m.regTravelTimePresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->regTravelTime,  1,  3600);
      if (stat != 0) return stat;

   }

   /* encode regVehDistTraveled */

   if (pvalue->m.regVehDistTraveledPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->regVehDistTraveled,  1,  500);
      if (stat != 0) return stat;

   }

   /* encode regVehTimeTraveled */

   if (pvalue->m.regVehTimeTraveledPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->regVehTimeTraveled,  1,  3600);
      if (stat != 0) return stat;

   }

   /* encode fuelConsumption */

   if (pvalue->m.fuelConsumptionPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->fuelConsumption,  1,  255);
      if (stat != 0) return stat;

   }

   /* encode totalVehEmissions */

   if (pvalue->m.totalVehEmissionsPresent) {
      stat = asn1PE_RptEmissions (pctxt, &pvalue->totalVehEmissions);
      if (stat != 0) return stat;
   }

   /* encode numOfLowSpeedEvents */

   if (pvalue->m.numOfLowSpeedEventsPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->numOfLowSpeedEvents,  1,  255);
      if (stat != 0) return stat;

   }

   /* encode timeStopped */

   if (pvalue->m.timeStoppedPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->timeStopped,  1,  36000);
      if (stat != 0) return stat;

   }

   /* encode numOfStopped */

   if (pvalue->m.numOfStoppedPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->numOfStopped,  1,  255);
      if (stat != 0) return stat;

   }

   /* encode locOfStops */

   if (pvalue->m.locOfStopsPresent) {
      stat = asn1PE_RptLocOfStops (pctxt, &pvalue->locOfStops);
      if (stat != 0) return stat;
   }

   /* encode regNumOfVehPassed */

   if (pvalue->m.regNumOfVehPassedPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->regNumOfVehPassed,  1,  255);
      if (stat != 0) return stat;

   }

   /* encode regNumOfSurpassedVeh */

   if (pvalue->m.regNumOfSurpassedVehPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->regNumOfSurpassedVeh,  1,  255);
      if (stat != 0) return stat;

   }

   /* encode totalMsgsReceived */

   if (pvalue->m.totalMsgsReceivedPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->totalMsgsReceived,  1,  255);
      if (stat != 0) return stat;

   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RptAvgAndSummaryRecordData (OSCTXT* pctxt, RptAvgAndSummaryRecordData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 2);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* averagedRecord */
         case 1:
            stat = asn1PE_RptAveragedRecord (pctxt, pvalue->u.averagedRecord);
            if (stat != 0) return stat;
            break;

         /* summaryRecord */
         case 2:
            stat = asn1PE_RptSummaryRecord (pctxt, pvalue->u.summaryRecord);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_RptAveragedAndSummaryRecord (OSCTXT* pctxt, RptAveragedAndSummaryRecord* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode startTime */

   stat = asn1PE_DDateTime (pctxt, (DDateTime*)pvalue->startTime);
   if (stat != 0) return stat;

   /* encode startLoc */

   stat = asn1PE_Position3D (pctxt, (Position3D*)pvalue->startLoc);
   if (stat != 0) return stat;

   /* encode startAccOfPos */

   stat = asn1PE_PositionalAccuracy (pctxt, (PositionalAccuracy*)pvalue->startAccOfPos);
   if (stat != 0) return stat;

   /* encode endTime */

   stat = asn1PE_DDateTime (pctxt, (DDateTime*)pvalue->endTime);
   if (stat != 0) return stat;

   /* encode endLoc */

   stat = asn1PE_Position3D (pctxt, (Position3D*)pvalue->endLoc);
   if (stat != 0) return stat;

   /* encode endAccOfPos */

   stat = asn1PE_PositionalAccuracy (pctxt, (PositionalAccuracy*)pvalue->endAccOfPos);
   if (stat != 0) return stat;

   /* encode record */

   stat = asn1PE_RptAvgAndSummaryRecordData (pctxt, &pvalue->record);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_ProbeDataReportMessage (OSCTXT* pctxt, ProbeDataReportMessage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.roadAuthorityIDPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.instantaneousRecsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgAndSumRecPresent);

   /* encode configId */

   stat = asn1PE_ConfigId (pctxt, pvalue->configId);
   if (stat != 0) return stat;

   /* encode reportChar */

   stat = asn1PE_ReportCharacteristics (pctxt, &pvalue->reportChar);
   if (stat != 0) return stat;

   /* encode roadAuthorityID */

   if (pvalue->m.roadAuthorityIDPresent) {
      stat = asn1PE_RoadAuthorityID (pctxt, (RoadAuthorityID*)pvalue->roadAuthorityID);
      if (stat != 0) return stat;
   }

   /* encode instantaneousRecs */

   if (pvalue->m.instantaneousRecsPresent) {
      stat = asn1PE_RptInstantaneousRecords (pctxt, &pvalue->instantaneousRecs);
      if (stat != 0) return stat;
   }

   /* encode avgAndSumRec */

   if (pvalue->m.avgAndSumRecPresent) {
      stat = asn1PE_RptAveragedAndSummaryRecord (pctxt, &pvalue->avgAndSumRec);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

