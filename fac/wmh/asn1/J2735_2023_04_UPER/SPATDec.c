/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "SPAT.h"
#include "REGION.h"
#include "Common.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PD_TimeIntervalConfidence (OSCTXT* pctxt, TimeIntervalConfidence* pvalue)
{
   return rtxDecBitsToByte(pctxt, pvalue, 4);
}

EXTERN int asn1PD_AdvisorySpeedType (OSCTXT* pctxt, AdvisorySpeedType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(3));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_IntersectionStatusObject (OSCTXT* pctxt, IntersectionStatusObject* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_MovementPhaseState (OSCTXT* pctxt, MovementPhaseState* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 4);
   if (stat != 0) return stat;

   if (*pvalue > 9) {
      return RTERR_CONSVIO;
   }
   return stat;
}

EXTERN int asn1PD_PedestrianBicycleDetect (OSCTXT* pctxt, PedestrianBicycleDetect* pvalue)
{
   int stat = 0;

   rtxDecBit(pctxt, pvalue);

   return (stat);
}

EXTERN int asn1PD_SpeedAdvice (OSCTXT* pctxt, SpeedAdvice* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 9);
   if (stat != 0) return stat;

   if (*pvalue > 500) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_SPAT_TimeMark (OSCTXT* pctxt, SPAT_TimeMark* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, 16);
   if (stat != 0) return stat;

   if (*pvalue > 36111) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_WaitOnStopline (OSCTXT* pctxt, WaitOnStopline* pvalue)
{
   int stat = 0;

   rtxDecBit(pctxt, pvalue);

   return (stat);
}

EXTERN int asn1PD_ZoneLength (OSCTXT* pctxt, ZoneLength* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 14);
   if (stat != 0) return stat;

   if (*pvalue > 10000) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_EnabledLaneList (OSCTXT* pctxt, EnabledLaneList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 4);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 16) {
      return RTERR_CONSVIO;
   }

   /* decode elements */

   pvalue->elem = rtxMemAllocArray (pctxt, pvalue->n, LaneID);
   if (0 == pvalue->elem) return rtxErrGetStatus(pctxt);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      pctxt->level++;

      stat = asn1PD_LaneID (pctxt, (LaneID*)&pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_TimeChangeDetails (OSCTXT* pctxt, TimeChangeDetails* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode startTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.startTimePresent = 1;

            stat = asn1PD_SPAT_TimeMark (pctxt, &pvalue->startTime);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode minEndTime */
         pctxt->level++;

         stat = asn1PD_SPAT_TimeMark (pctxt, &pvalue->minEndTime);

         pctxt->level--;
         break;

         case 2:
         /* decode maxEndTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.maxEndTimePresent = 1;

            stat = asn1PD_SPAT_TimeMark (pctxt, &pvalue->maxEndTime);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode likelyTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.likelyTimePresent = 1;

            stat = asn1PD_SPAT_TimeMark (pctxt, &pvalue->likelyTime);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode confidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.confidencePresent = 1;

            stat = asn1PD_TimeIntervalConfidence (pctxt, &pvalue->confidence);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode nextTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.nextTimePresent = 1;

            stat = asn1PD_SPAT_TimeMark (pctxt, &pvalue->nextTime);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   return (stat);
}

EXTERN int asn1PD_AdvisorySpeed_regional (OSCTXT* pctxt, AdvisorySpeed_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_AdvisorySpeed (OSCTXT* pctxt, AdvisorySpeed* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode type */
         pctxt->level++;

         stat = asn1PD_AdvisorySpeedType (pctxt, &pvalue->type);

         pctxt->level--;
         break;

         case 1:
         /* decode speed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.speedPresent = 1;

            stat = asn1PD_SpeedAdvice (pctxt, &pvalue->speed);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode confidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.confidencePresent = 1;

            stat = asn1PD_SpeedConfidence (pctxt, (SpeedConfidence*)&pvalue->confidence);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode distance */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.distancePresent = 1;

            stat = asn1PD_ZoneLength (pctxt, &pvalue->distance);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode class_ */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.class_Present = 1;

            stat = asn1PD_RestrictionClassID (pctxt, (RestrictionClassID*)&pvalue->class_);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_AdvisorySpeed_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_AdvisorySpeedList (OSCTXT* pctxt, AdvisorySpeedList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AdvisorySpeed* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, AdvisorySpeed);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_AdvisorySpeed (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AdvisorySpeed (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_MovementEvent_regional (OSCTXT* pctxt, MovementEvent_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_MovementEvent (OSCTXT* pctxt, MovementEvent* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode eventState */
         pctxt->level++;

         stat = asn1PD_MovementPhaseState (pctxt, &pvalue->eventState);

         pctxt->level--;
         break;

         case 1:
         /* decode timing */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.timingPresent = 1;

            stat = asn1PD_TimeChangeDetails (pctxt, &pvalue->timing);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode speeds */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.speedsPresent = 1;

            stat = asn1PD_AdvisorySpeedList (pctxt, &pvalue->speeds);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_MovementEvent_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_MovementEventList (OSCTXT* pctxt, MovementEventList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MovementEvent* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, MovementEvent);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_MovementEvent (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_MovementEvent (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_ConnectionManeuverAssist_regional (OSCTXT* pctxt, ConnectionManeuverAssist_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_ConnectionManeuverAssist (OSCTXT* pctxt, ConnectionManeuverAssist* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode connectionID */
         pctxt->level++;

         stat = asn1PD_LaneConnectionID (pctxt, (LaneConnectionID*)&pvalue->connectionID);

         pctxt->level--;
         break;

         case 1:
         /* decode queueLength */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.queueLengthPresent = 1;

            stat = asn1PD_ZoneLength (pctxt, &pvalue->queueLength);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode availableStorageLength */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.availableStorageLengthPresent = 1;

            stat = asn1PD_ZoneLength (pctxt, &pvalue->availableStorageLength);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode waitOnStop */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.waitOnStopPresent = 1;

            stat = asn1PD_WaitOnStopline (pctxt, &pvalue->waitOnStop);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode pedBicycleDetect */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.pedBicycleDetectPresent = 1;

            stat = asn1PD_PedestrianBicycleDetect (pctxt, &pvalue->pedBicycleDetect);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_ConnectionManeuverAssist_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_ManeuverAssistList (OSCTXT* pctxt, ManeuverAssistList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ConnectionManeuverAssist* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, ConnectionManeuverAssist);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_ConnectionManeuverAssist (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ConnectionManeuverAssist (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_MovementState_regional (OSCTXT* pctxt, MovementState_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_MovementState (OSCTXT* pctxt, MovementState* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode movementName */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.movementNamePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, (DescriptiveName*)&pvalue->movementName);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode signalGroup */
         pctxt->level++;

         stat = asn1PD_SignalGroupID (pctxt, (SignalGroupID*)&pvalue->signalGroup);

         pctxt->level--;
         break;

         case 2:
         /* decode state_time_speed */
         pctxt->level++;

         stat = asn1PD_MovementEventList (pctxt, &pvalue->state_time_speed);

         pctxt->level--;
         break;

         case 3:
         /* decode maneuverAssistList */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.maneuverAssistListPresent = 1;

            stat = asn1PD_ManeuverAssistList (pctxt, &pvalue->maneuverAssistList);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_MovementState_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_MovementList (OSCTXT* pctxt, MovementList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MovementState* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, MovementState);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_MovementState (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_MovementState (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_IntersectionState_regional (OSCTXT* pctxt, IntersectionState_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_IntersectionState (OSCTXT* pctxt, IntersectionState* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[6];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 10; i_++) {
      switch (i_) {
         case 0:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, (DescriptiveName*)&pvalue->name);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode id */
         pctxt->level++;

         pvalue->id = rtxMemAllocType (pctxt, IntersectionReferenceID);

         if (pvalue->id == NULL)
            return RTERR_NOMEM;

         asn1Init_IntersectionReferenceID ((IntersectionReferenceID*)pvalue->id);

         stat = asn1PD_IntersectionReferenceID (pctxt, (IntersectionReferenceID*)pvalue->id);

         pctxt->level--;
         break;

         case 2:
         /* decode revision */
         pctxt->level++;

         stat = asn1PD_Common_MsgCount (pctxt, (Common_MsgCount*)&pvalue->revision);

         pctxt->level--;
         break;

         case 3:
         /* decode status */
         pctxt->level++;

         stat = asn1PD_IntersectionStatusObject (pctxt, &pvalue->status);

         pctxt->level--;
         break;

         case 4:
         /* decode moy */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.moyPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, (MinuteOfTheYear*)&pvalue->moy);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_DSecond (pctxt, (DSecond*)&pvalue->timeStamp);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode enabledLanes */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.enabledLanesPresent = 1;

            stat = asn1PD_EnabledLaneList (pctxt, &pvalue->enabledLanes);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode states */
         pctxt->level++;

         stat = asn1PD_MovementList (pctxt, &pvalue->states);

         pctxt->level--;
         break;

         case 8:
         /* decode maneuverAssistList */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.maneuverAssistListPresent = 1;

            stat = asn1PD_ManeuverAssistList (pctxt, &pvalue->maneuverAssistList);

            pctxt->level--;
         }
         break;

         case 9:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_IntersectionState_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            if (i_ < 1) {  /* known element */
               OSUINT32 openTypeLen;
               size_t bitStartOffset, bitLength;
               size_t bitEndOffset, bitsConsumed;

               stat = pd_UnconsLength (pctxt, &openTypeLen);
               if (stat < 0) {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return stat;
               }
               else if (stat == RT_OK_FRAG) {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return RTERR_NOTSUPP;
               }
               bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
               bitLength = openTypeLen * 8;

               if (openTypeLen > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.roadAuthorityIDPresent = 1;
                        pctxt->level++;

                        pvalue->roadAuthorityID = rtxMemAllocType (pctxt, 
                           RoadAuthorityID);

                        if (pvalue->roadAuthorityID == NULL)
                           return RTERR_NOMEM;

                        asn1Init_RoadAuthorityID ((RoadAuthorityID*)pvalue->roadAuthorityID);

                        stat = asn1PD_RoadAuthorityID (pctxt, (RoadAuthorityID*)pvalue->roadAuthorityID);

                        if (stat != 0) break;

                        pctxt->level--;

                        break;

                  }
               }

               if (0 == stat) {
                  bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
                  bitsConsumed = bitEndOffset - bitStartOffset;
                  if (bitsConsumed < bitLength) {
                     stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
                  }
                  else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
               }
            }
            else {
               stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

               if (0 == stat) {
                  pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
                  if (0 != pOpenType) {
                     pOpenType->numocts = openType.numocts;
                     pOpenType->data = openType.data;
                     rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
                  }
                  else stat = RTERR_NOMEM;
               }
               else {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return stat;
               }
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_IntersectionStateList (OSCTXT* pctxt, IntersectionStateList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      IntersectionState* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, IntersectionState);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_IntersectionState (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_IntersectionState (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_SPAT_regional (OSCTXT* pctxt, SPAT_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_SPAT (OSCTXT* pctxt, SPAT* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, (MinuteOfTheYear*)&pvalue->timeStamp);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, (DescriptiveName*)&pvalue->name);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode intersections */
         pctxt->level++;

         stat = asn1PD_IntersectionStateList (pctxt, &pvalue->intersections);

         pctxt->level--;
         break;

         case 3:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_SPAT_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

