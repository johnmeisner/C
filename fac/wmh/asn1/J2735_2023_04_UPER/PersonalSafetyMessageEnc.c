/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "PersonalSafetyMessage.h"
#include "REGION.h"
#include "Common.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PE_AnimalPropelledType (OSCTXT* pctxt, AnimalPropelledType value)
{
   int stat = 0;

   if (value >= 4) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_AnimalType (OSCTXT* pctxt, AnimalType value)
{
   int stat = 0;

   if (value >= 4) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Attachment (OSCTXT* pctxt, Attachment value)
{
   int stat = 0;

   if (value >= 7) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_AttachmentRadius (OSCTXT* pctxt, AttachmentRadius value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  200);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_MotorizedPropelledType (OSCTXT* pctxt, MotorizedPropelledType value)
{
   int stat = 0;

   if (value >= 6) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NumberOfParticipantsInCluster (OSCTXT* pctxt, NumberOfParticipantsInCluster value)
{
   int stat = 0;

   if (value >= 4) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_HumanPropelledType (OSCTXT* pctxt, HumanPropelledType value)
{
   int stat = 0;

   if (value >= 6) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PersonalAssistive (OSCTXT* pctxt, PersonalAssistive* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), OSUINTCONST(0), OSUINT32_MAX);

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(6)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(6) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(6)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PersonalClusterRadius (OSCTXT* pctxt, PersonalClusterRadius value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  100);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PersonalCrossingInProgress (OSCTXT* pctxt, PersonalCrossingInProgress value)
{
   int stat = 0;

   stat = rtxEncBit (pctxt, (OSBOOL)value);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PersonalCrossingRequest (OSCTXT* pctxt, PersonalCrossingRequest value)
{
   int stat = 0;

   stat = rtxEncBit (pctxt, (OSBOOL)value);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PersonalDeviceUsageState (OSCTXT* pctxt, PersonalDeviceUsageState* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(9), OSUINTCONST(9), OSUINTCONST(0), OSUINT32_MAX);

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(9)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(9) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(9)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PersonalDeviceUserType (OSCTXT* pctxt, PersonalDeviceUserType value)
{
   int stat = 0;

   if (value >= 5) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PublicSafetyAndRoadWorkerActivity (OSCTXT* pctxt, PublicSafetyAndRoadWorkerActivity* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), OSUINTCONST(0), OSUINT32_MAX);

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(6)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(6) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(6)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PublicSafetyDirectingTrafficSubType (OSCTXT* pctxt, PublicSafetyDirectingTrafficSubType* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(7), OSUINTCONST(7), OSUINTCONST(0), OSUINT32_MAX);

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(7)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(7) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(7)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PublicSafetyEventResponderWorkerType (OSCTXT* pctxt, PublicSafetyEventResponderWorkerType value)
{
   int stat = 0;

   if (value >= 8) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_UserSizeAndBehaviour (OSCTXT* pctxt, UserSizeAndBehaviour* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), OSUINTCONST(0), OSUINT32_MAX);

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(5)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(5) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(5)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PropelledInformation (OSCTXT* pctxt, PropelledInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 3);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 2);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* human */
         case 1:
            stat = asn1PE_HumanPropelledType (pctxt, pvalue->u.human);
            if (stat != 0) return stat;
            break;

         /* animal */
         case 2:
            stat = asn1PE_AnimalPropelledType (pctxt, pvalue->u.animal);
            if (stat != 0) return stat;
            break;

         /* motor */
         case 3:
            stat = asn1PE_MotorizedPropelledType (pctxt, pvalue->u.motor);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_PersonalSafetyMessage_regional (OSCTXT* pctxt, PersonalSafetyMessage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_PersonalSafetyMessage (OSCTXT* pctxt, PersonalSafetyMessage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.accelSetPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pathHistoryPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pathPredictionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.propulsionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.useStatePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.crossRequestPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.crossStatePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.clusterSizePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.clusterRadiusPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.eventResponderTypePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.activityTypePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.activitySubTypePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.assistTypePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.sizingPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.attachmentPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.attachmentRadiusPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.animalTypePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode basicType */

   stat = asn1PE_PersonalDeviceUserType (pctxt, pvalue->basicType);
   if (stat != 0) return stat;

   /* encode secMark */

   stat = asn1PE_DSecond (pctxt, pvalue->secMark);
   if (stat != 0) return stat;

   /* encode msgCnt */

   stat = asn1PE_Common_MsgCount (pctxt, pvalue->msgCnt);
   if (stat != 0) return stat;

   /* encode id */

   stat = asn1PE_TemporaryID (pctxt, (TemporaryID*)pvalue->id);
   if (stat != 0) return stat;

   /* encode position */

   stat = asn1PE_Position3D (pctxt, (Position3D*)pvalue->position);
   if (stat != 0) return stat;

   /* encode accuracy */

   stat = asn1PE_PositionalAccuracy (pctxt, (PositionalAccuracy*)pvalue->accuracy);
   if (stat != 0) return stat;

   /* encode speed */

   stat = asn1PE_Velocity (pctxt, pvalue->speed);
   if (stat != 0) return stat;

   /* encode heading */

   stat = asn1PE_Heading (pctxt, pvalue->heading);
   if (stat != 0) return stat;

   /* encode accelSet */

   if (pvalue->m.accelSetPresent) {
      stat = asn1PE_AccelerationSet4Way (pctxt, (AccelerationSet4Way*)pvalue->accelSet);
      if (stat != 0) return stat;
   }

   /* encode pathHistory */

   if (pvalue->m.pathHistoryPresent) {
      stat = asn1PE_PathHistory (pctxt, (PathHistory*)pvalue->pathHistory);
      if (stat != 0) return stat;
   }

   /* encode pathPrediction */

   if (pvalue->m.pathPredictionPresent) {
      stat = asn1PE_PathPrediction (pctxt, (PathPrediction*)pvalue->pathPrediction);
      if (stat != 0) return stat;
   }

   /* encode propulsion */

   if (pvalue->m.propulsionPresent) {
      stat = asn1PE_PropelledInformation (pctxt, &pvalue->propulsion);
      if (stat != 0) return stat;
   }

   /* encode useState */

   if (pvalue->m.useStatePresent) {
      stat = asn1PE_PersonalDeviceUsageState (pctxt, &pvalue->useState);
      if (stat != 0) return stat;
   }

   /* encode crossRequest */

   if (pvalue->m.crossRequestPresent) {
      stat = asn1PE_PersonalCrossingRequest (pctxt, pvalue->crossRequest);
      if (stat != 0) return stat;
   }

   /* encode crossState */

   if (pvalue->m.crossStatePresent) {
      stat = asn1PE_PersonalCrossingInProgress (pctxt, pvalue->crossState);
      if (stat != 0) return stat;
   }

   /* encode clusterSize */

   if (pvalue->m.clusterSizePresent) {
      stat = asn1PE_NumberOfParticipantsInCluster (pctxt, pvalue->clusterSize);
      if (stat != 0) return stat;
   }

   /* encode clusterRadius */

   if (pvalue->m.clusterRadiusPresent) {
      stat = asn1PE_PersonalClusterRadius (pctxt, pvalue->clusterRadius);
      if (stat != 0) return stat;
   }

   /* encode eventResponderType */

   if (pvalue->m.eventResponderTypePresent) {
      stat = asn1PE_PublicSafetyEventResponderWorkerType (pctxt, pvalue->eventResponderType);
      if (stat != 0) return stat;
   }

   /* encode activityType */

   if (pvalue->m.activityTypePresent) {
      stat = asn1PE_PublicSafetyAndRoadWorkerActivity (pctxt, &pvalue->activityType);
      if (stat != 0) return stat;
   }

   /* encode activitySubType */

   if (pvalue->m.activitySubTypePresent) {
      stat = asn1PE_PublicSafetyDirectingTrafficSubType (pctxt, &pvalue->activitySubType);
      if (stat != 0) return stat;
   }

   /* encode assistType */

   if (pvalue->m.assistTypePresent) {
      stat = asn1PE_PersonalAssistive (pctxt, &pvalue->assistType);
      if (stat != 0) return stat;
   }

   /* encode sizing */

   if (pvalue->m.sizingPresent) {
      stat = asn1PE_UserSizeAndBehaviour (pctxt, &pvalue->sizing);
      if (stat != 0) return stat;
   }

   /* encode attachment */

   if (pvalue->m.attachmentPresent) {
      stat = asn1PE_Attachment (pctxt, pvalue->attachment);
      if (stat != 0) return stat;
   }

   /* encode attachmentRadius */

   if (pvalue->m.attachmentRadiusPresent) {
      stat = asn1PE_AttachmentRadius (pctxt, pvalue->attachmentRadius);
      if (stat != 0) return stat;
   }

   /* encode animalType */

   if (pvalue->m.animalTypePresent) {
      stat = asn1PE_AnimalType (pctxt, pvalue->animalType);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_PersonalSafetyMessage_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

