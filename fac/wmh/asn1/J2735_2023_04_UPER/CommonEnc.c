/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "Common.h"
#include "MessageFrame.h"
#include "REGION.h"
#include "BasicSafetyMessage.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PE_StationID (OSCTXT* pctxt, StationID value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  OSUINT32_MAX);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PrioritizationResponseStatus (OSCTXT* pctxt, PrioritizationResponseStatus value)
{
   int stat = 0;

   if (value >= 8) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SignalGroupID (OSCTXT* pctxt, SignalGroupID value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LaneID (OSCTXT* pctxt, LaneID value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Offset_B10 (OSCTXT* pctxt, Offset_B10 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -512,  511);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Node_XY_20b (OSCTXT* pctxt, Node_XY_20b* pvalue)
{
   int stat = 0;

   /* encode x */

   stat = asn1PE_Offset_B10 (pctxt, pvalue->x);
   if (stat != 0) return stat;

   /* encode y */

   stat = asn1PE_Offset_B10 (pctxt, pvalue->y);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Offset_B11 (OSCTXT* pctxt, Offset_B11 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -1024,  1023);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Node_XY_22b (OSCTXT* pctxt, Node_XY_22b* pvalue)
{
   int stat = 0;

   /* encode x */

   stat = asn1PE_Offset_B11 (pctxt, pvalue->x);
   if (stat != 0) return stat;

   /* encode y */

   stat = asn1PE_Offset_B11 (pctxt, pvalue->y);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Offset_B12 (OSCTXT* pctxt, Offset_B12 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -2048,  2047);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Node_XY_24b (OSCTXT* pctxt, Node_XY_24b* pvalue)
{
   int stat = 0;

   /* encode x */

   stat = asn1PE_Offset_B12 (pctxt, pvalue->x);
   if (stat != 0) return stat;

   /* encode y */

   stat = asn1PE_Offset_B12 (pctxt, pvalue->y);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Offset_B13 (OSCTXT* pctxt, Offset_B13 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -4096,  4095);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Node_XY_26b (OSCTXT* pctxt, Node_XY_26b* pvalue)
{
   int stat = 0;

   /* encode x */

   stat = asn1PE_Offset_B13 (pctxt, pvalue->x);
   if (stat != 0) return stat;

   /* encode y */

   stat = asn1PE_Offset_B13 (pctxt, pvalue->y);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Offset_B14 (OSCTXT* pctxt, Offset_B14 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -8192,  8191);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Node_XY_28b (OSCTXT* pctxt, Node_XY_28b* pvalue)
{
   int stat = 0;

   /* encode x */

   stat = asn1PE_Offset_B14 (pctxt, pvalue->x);
   if (stat != 0) return stat;

   /* encode y */

   stat = asn1PE_Offset_B14 (pctxt, pvalue->y);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Offset_B16 (OSCTXT* pctxt, Offset_B16 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -32768,  32767);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Node_XY_32b (OSCTXT* pctxt, Node_XY_32b* pvalue)
{
   int stat = 0;

   /* encode x */

   stat = asn1PE_Offset_B16 (pctxt, pvalue->x);
   if (stat != 0) return stat;

   /* encode y */

   stat = asn1PE_Offset_B16 (pctxt, pvalue->y);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Longitude (OSCTXT* pctxt, Longitude value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -1799999999,  1800000001);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Latitude (OSCTXT* pctxt, Latitude value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -900000000,  900000001);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Node_LLmD_64b (OSCTXT* pctxt, Node_LLmD_64b* pvalue)
{
   int stat = 0;

   /* encode lon */

   stat = asn1PE_Longitude (pctxt, pvalue->lon);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_Latitude (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RegionId (OSCTXT* pctxt, RegionId value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RegionalExtension (OSCTXT* pctxt, RegionalExtension* pvalue)
{
   int stat = 0;

   /* encode regionId */

   stat = asn1PE_RegionId (pctxt, pvalue->regionId);
   if (stat != 0) return stat;

   /* encode regExtValue */

   stat = pe_OpenType (pctxt, pvalue->regExtValue.numocts, pvalue->regExtValue.data);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NodeOffsetPointXY (OSCTXT* pctxt, NodeOffsetPointXY* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 3);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* node_XY1 */
      case 1:
         stat = asn1PE_Node_XY_20b (pctxt, pvalue->u.node_XY1);
         if (stat != 0) return stat;
         break;

      /* node_XY2 */
      case 2:
         stat = asn1PE_Node_XY_22b (pctxt, pvalue->u.node_XY2);
         if (stat != 0) return stat;
         break;

      /* node_XY3 */
      case 3:
         stat = asn1PE_Node_XY_24b (pctxt, pvalue->u.node_XY3);
         if (stat != 0) return stat;
         break;

      /* node_XY4 */
      case 4:
         stat = asn1PE_Node_XY_26b (pctxt, pvalue->u.node_XY4);
         if (stat != 0) return stat;
         break;

      /* node_XY5 */
      case 5:
         stat = asn1PE_Node_XY_28b (pctxt, pvalue->u.node_XY5);
         if (stat != 0) return stat;
         break;

      /* node_XY6 */
      case 6:
         stat = asn1PE_Node_XY_32b (pctxt, pvalue->u.node_XY6);
         if (stat != 0) return stat;
         break;

      /* node_LatLon */
      case 7:
         stat = asn1PE_Node_LLmD_64b (pctxt, pvalue->u.node_LatLon);
         if (stat != 0) return stat;
         break;

      /* regional */
      case 8:
         stat = asn1PE_RegionalExtension (pctxt, pvalue->u.regional);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_Common_Angle (OSCTXT* pctxt, Common_Angle value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  28800);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_GrossSpeed (OSCTXT* pctxt, GrossSpeed value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  31);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Common_MsgCount (OSCTXT* pctxt, Common_MsgCount value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  127);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_TemporaryID (OSCTXT* pctxt, TemporaryID* pvalue)
{
   int stat = 0;

   if (pvalue->numocts != 4) {
      return RTERR_CONSVIO;
   }
   stat = pe_byte_align (pctxt);
   if (stat != 0) return stat;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 32);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DSecond (OSCTXT* pctxt, DSecond value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  65535);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Common_Elevation (OSCTXT* pctxt, Common_Elevation value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -4096,  61439);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SemiMajorAxisAccuracy (OSCTXT* pctxt, SemiMajorAxisAccuracy value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SemiMinorAxisAccuracy (OSCTXT* pctxt, SemiMinorAxisAccuracy value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SemiMajorAxisOrientation (OSCTXT* pctxt, SemiMajorAxisOrientation value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  65535);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PositionalAccuracy (OSCTXT* pctxt, PositionalAccuracy* pvalue)
{
   int stat = 0;

   /* encode semiMajor */

   stat = asn1PE_SemiMajorAxisAccuracy (pctxt, pvalue->semiMajor);
   if (stat != 0) return stat;

   /* encode semiMinor */

   stat = asn1PE_SemiMinorAxisAccuracy (pctxt, pvalue->semiMinor);
   if (stat != 0) return stat;

   /* encode orientation */

   stat = asn1PE_SemiMajorAxisOrientation (pctxt, pvalue->orientation);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_TransmissionState (OSCTXT* pctxt, TransmissionState value)
{
   int stat = 0;

   if (value >= 8) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Speed (OSCTXT* pctxt, Speed value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  8191);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Heading (OSCTXT* pctxt, Heading value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  28800);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SteeringWheelAngle (OSCTXT* pctxt, SteeringWheelAngle value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -126,  127);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Acceleration (OSCTXT* pctxt, Acceleration value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -2000,  2001);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VerticalAcceleration (OSCTXT* pctxt, VerticalAcceleration value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -127,  127);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_YawRate (OSCTXT* pctxt, YawRate value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -32767,  32767);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_AccelerationSet4Way (OSCTXT* pctxt, AccelerationSet4Way* pvalue)
{
   int stat = 0;

   /* encode long_ */

   stat = asn1PE_Acceleration (pctxt, pvalue->long_);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_Acceleration (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   /* encode vert */

   stat = asn1PE_VerticalAcceleration (pctxt, pvalue->vert);
   if (stat != 0) return stat;

   /* encode yaw */

   stat = asn1PE_YawRate (pctxt, pvalue->yaw);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_BrakeAppliedStatus (OSCTXT* pctxt, BrakeAppliedStatus* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 5);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_TractionControlStatus (OSCTXT* pctxt, TractionControlStatus value)
{
   int stat = 0;

   if (value >= 4) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_AntiLockBrakeStatus (OSCTXT* pctxt, AntiLockBrakeStatus value)
{
   int stat = 0;

   if (value >= 4) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_StabilityControlStatus (OSCTXT* pctxt, StabilityControlStatus value)
{
   int stat = 0;

   if (value >= 4) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_BrakeBoostApplied (OSCTXT* pctxt, BrakeBoostApplied value)
{
   int stat = 0;

   if (value >= 3) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_AuxiliaryBrakeStatus (OSCTXT* pctxt, AuxiliaryBrakeStatus value)
{
   int stat = 0;

   if (value >= 4) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_BrakeSystemStatus (OSCTXT* pctxt, BrakeSystemStatus* pvalue)
{
   int stat = 0;

   /* encode wheelBrakes */

   stat = asn1PE_BrakeAppliedStatus (pctxt, &pvalue->wheelBrakes);
   if (stat != 0) return stat;

   /* encode traction */

   stat = asn1PE_TractionControlStatus (pctxt, pvalue->traction);
   if (stat != 0) return stat;

   /* encode abs_ */

   stat = asn1PE_AntiLockBrakeStatus (pctxt, pvalue->abs_);
   if (stat != 0) return stat;

   /* encode scs */

   stat = asn1PE_StabilityControlStatus (pctxt, pvalue->scs);
   if (stat != 0) return stat;

   /* encode brakeBoost */

   stat = asn1PE_BrakeBoostApplied (pctxt, pvalue->brakeBoost);
   if (stat != 0) return stat;

   /* encode auxBrakes */

   stat = asn1PE_AuxiliaryBrakeStatus (pctxt, pvalue->auxBrakes);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VehicleWidth (OSCTXT* pctxt, VehicleWidth value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  1023);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VehicleLength (OSCTXT* pctxt, VehicleLength value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  4095);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VehicleSize (OSCTXT* pctxt, VehicleSize* pvalue)
{
   int stat = 0;

   /* encode width */

   stat = asn1PE_VehicleWidth (pctxt, pvalue->width);
   if (stat != 0) return stat;

   /* encode length */

   stat = asn1PE_VehicleLength (pctxt, pvalue->length);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_BSMcoreData (OSCTXT* pctxt, BSMcoreData* pvalue)
{
   int stat = 0;

   /* encode msgCnt */

   stat = asn1PE_Common_MsgCount (pctxt, pvalue->msgCnt);
   if (stat != 0) return stat;

   /* encode id */

   stat = asn1PE_TemporaryID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* encode secMark */

   stat = asn1PE_DSecond (pctxt, pvalue->secMark);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_Latitude (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   /* encode long_ */

   stat = asn1PE_Longitude (pctxt, pvalue->long_);
   if (stat != 0) return stat;

   /* encode elev */

   stat = asn1PE_Common_Elevation (pctxt, pvalue->elev);
   if (stat != 0) return stat;

   /* encode accuracy */

   stat = asn1PE_PositionalAccuracy (pctxt, &pvalue->accuracy);
   if (stat != 0) return stat;

   /* encode transmission */

   stat = asn1PE_TransmissionState (pctxt, pvalue->transmission);
   if (stat != 0) return stat;

   /* encode speed */

   stat = asn1PE_Speed (pctxt, pvalue->speed);
   if (stat != 0) return stat;

   /* encode heading */

   stat = asn1PE_Heading (pctxt, pvalue->heading);
   if (stat != 0) return stat;

   /* encode angle */

   stat = asn1PE_SteeringWheelAngle (pctxt, pvalue->angle);
   if (stat != 0) return stat;

   /* encode accelSet */

   stat = asn1PE_AccelerationSet4Way (pctxt, &pvalue->accelSet);
   if (stat != 0) return stat;

   /* encode brakes */

   stat = asn1PE_BrakeSystemStatus (pctxt, &pvalue->brakes);
   if (stat != 0) return stat;

   /* encode size */

   stat = asn1PE_VehicleSize (pctxt, &pvalue->size);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Priority (OSCTXT* pctxt, Priority* pvalue)
{
   int stat = 0;

   if (pvalue->numocts != 1) {
      return RTERR_CONSVIO;
   }
   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 8);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_HeadingSlice (OSCTXT* pctxt, HeadingSlice* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 16);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Extent (OSCTXT* pctxt, Extent value)
{
   int stat = 0;

   if (value >= 16) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_ObstacleDistance (OSCTXT* pctxt, ObstacleDistance value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  32767);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DYear (OSCTXT* pctxt, DYear value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  4095);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DMonth (OSCTXT* pctxt, DMonth value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  12);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DDay (OSCTXT* pctxt, DDay value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  31);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DHour (OSCTXT* pctxt, DHour value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  31);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DMinute (OSCTXT* pctxt, DMinute value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  60);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DOffset (OSCTXT* pctxt, DOffset value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -840,  840);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DDateTime (OSCTXT* pctxt, DDateTime* pvalue)
{
   int stat = 0;

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.yearPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.monthPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dayPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.hourPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.minutePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.secondPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.offsetPresent);

   /* encode year */

   if (pvalue->m.yearPresent) {
      stat = asn1PE_DYear (pctxt, pvalue->year);
      if (stat != 0) return stat;
   }

   /* encode month */

   if (pvalue->m.monthPresent) {
      stat = asn1PE_DMonth (pctxt, pvalue->month);
      if (stat != 0) return stat;
   }

   /* encode day */

   if (pvalue->m.dayPresent) {
      stat = asn1PE_DDay (pctxt, pvalue->day);
      if (stat != 0) return stat;
   }

   /* encode hour */

   if (pvalue->m.hourPresent) {
      stat = asn1PE_DHour (pctxt, pvalue->hour);
      if (stat != 0) return stat;
   }

   /* encode minute */

   if (pvalue->m.minutePresent) {
      stat = asn1PE_DMinute (pctxt, pvalue->minute);
      if (stat != 0) return stat;
   }

   /* encode second */

   if (pvalue->m.secondPresent) {
      stat = asn1PE_DSecond (pctxt, pvalue->second);
      if (stat != 0) return stat;
   }

   /* encode offset */

   if (pvalue->m.offsetPresent) {
      stat = asn1PE_DOffset (pctxt, pvalue->offset);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_VerticalAccelerationThreshold (OSCTXT* pctxt, VerticalAccelerationThreshold* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 5);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_GNSSstatus (OSCTXT* pctxt, GNSSstatus* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 8);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Offset_B09 (OSCTXT* pctxt, Offset_B09 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -256,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_AntennaOffsetSet (OSCTXT* pctxt, AntennaOffsetSet* pvalue)
{
   int stat = 0;

   /* encode antOffsetX */

   stat = asn1PE_Offset_B12 (pctxt, pvalue->antOffsetX);
   if (stat != 0) return stat;

   /* encode antOffsetY */

   stat = asn1PE_Offset_B09 (pctxt, pvalue->antOffsetY);
   if (stat != 0) return stat;

   /* encode antOffsetZ */

   stat = asn1PE_Offset_B10 (pctxt, pvalue->antOffsetZ);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RTCMheader (OSCTXT* pctxt, RTCMheader* pvalue)
{
   int stat = 0;

   /* encode status */

   stat = asn1PE_GNSSstatus (pctxt, &pvalue->status);
   if (stat != 0) return stat;

   /* encode offsetSet */

   stat = asn1PE_AntennaOffsetSet (pctxt, &pvalue->offsetSet);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RTCMmessage (OSCTXT* pctxt, RTCMmessage* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1023), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RTCMmessageList (OSCTXT* pctxt, RTCMmessageList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(5), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_RTCMmessage (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_SSPindex (OSCTXT* pctxt, SSPindex value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  31);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SirenInUse (OSCTXT* pctxt, SirenInUse value)
{
   int stat = 0;

   if (value >= 4) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LightbarInUse (OSCTXT* pctxt, LightbarInUse value)
{
   int stat = 0;

   if (value >= 8) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_MultiVehicleResponse (OSCTXT* pctxt, MultiVehicleResponse value)
{
   int stat = 0;

   if (value >= 4) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PrivilegedEventFlags (OSCTXT* pctxt, PrivilegedEventFlags* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 16);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PrivilegedEvents (OSCTXT* pctxt, PrivilegedEvents* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode notUsed */

   stat = asn1PE_SSPindex (pctxt, pvalue->notUsed);
   if (stat != 0) return stat;

   /* encode event */

   stat = asn1PE_PrivilegedEventFlags (pctxt, &pvalue->event);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_ResponseType (OSCTXT* pctxt, ResponseType value)
{
   int stat = 0;

   if (value >= 7) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_EmergencyDetails (OSCTXT* pctxt, EmergencyDetails* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.eventsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.responseTypePresent);

   /* encode notUsed */

   stat = asn1PE_SSPindex (pctxt, pvalue->notUsed);
   if (stat != 0) return stat;

   /* encode sirenUse */

   stat = asn1PE_SirenInUse (pctxt, pvalue->sirenUse);
   if (stat != 0) return stat;

   /* encode lightsUse */

   stat = asn1PE_LightbarInUse (pctxt, pvalue->lightsUse);
   if (stat != 0) return stat;

   /* encode multi */

   stat = asn1PE_MultiVehicleResponse (pctxt, pvalue->multi);
   if (stat != 0) return stat;

   /* encode events */

   if (pvalue->m.eventsPresent) {
      stat = asn1PE_PrivilegedEvents (pctxt, &pvalue->events);
      if (stat != 0) return stat;
   }

   /* encode responseType */

   if (pvalue->m.responseTypePresent) {
      stat = asn1PE_ResponseType (pctxt, pvalue->responseType);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_VehicleHeight (OSCTXT* pctxt, VehicleHeight value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  127);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_BumperHeight (OSCTXT* pctxt, BumperHeight value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  127);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_BumperHeights (OSCTXT* pctxt, BumperHeights* pvalue)
{
   int stat = 0;

   /* encode front */

   stat = asn1PE_BumperHeight (pctxt, pvalue->front);
   if (stat != 0) return stat;

   /* encode rear */

   stat = asn1PE_BumperHeight (pctxt, pvalue->rear);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_TimeOffset (OSCTXT* pctxt, TimeOffset value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  1,  65535);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_CoarseHeading (OSCTXT* pctxt, CoarseHeading value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  240);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_BasicVehicleClass (OSCTXT* pctxt, BasicVehicleClass value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_BasicVehicleRole (OSCTXT* pctxt, BasicVehicleRole value)
{
   int stat = 0;

   if (value >= 23) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 5);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Iso3833VehicleType (OSCTXT* pctxt, Iso3833VehicleType value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  100);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VehicleType (OSCTXT* pctxt, VehicleType value)
{
   int stat = 0;

   if (value >= 16) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_FuelType (OSCTXT* pctxt, FuelType value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  15);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VehicleClassification_regional (OSCTXT* pctxt, VehicleClassification_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_VehicleClassification (OSCTXT* pctxt, VehicleClassification* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.keyTypePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rolePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.iso3883Present);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.hpmsTypePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehicleTypePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.responseEquipPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.responderTypePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.fuelTypePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode keyType */

   if (pvalue->m.keyTypePresent) {
      stat = asn1PE_BasicVehicleClass (pctxt, pvalue->keyType);
      if (stat != 0) return stat;
   }

   /* encode role */

   if (pvalue->m.rolePresent) {
      stat = asn1PE_BasicVehicleRole (pctxt, pvalue->role);
      if (stat != 0) return stat;
   }

   /* encode iso3883 */

   if (pvalue->m.iso3883Present) {
      stat = asn1PE_Iso3833VehicleType (pctxt, pvalue->iso3883);
      if (stat != 0) return stat;
   }

   /* encode hpmsType */

   if (pvalue->m.hpmsTypePresent) {
      stat = asn1PE_VehicleType (pctxt, pvalue->hpmsType);
      if (stat != 0) return stat;
   }

   /* encode vehicleType */

   if (pvalue->m.vehicleTypePresent) {
      stat = asn1PE_VehicleGroupAffected (pctxt, pvalue->vehicleType);
      if (stat != 0) return stat;
   }

   /* encode responseEquip */

   if (pvalue->m.responseEquipPresent) {
      stat = asn1PE_IncidentResponseEquipment (pctxt, pvalue->responseEquip);
      if (stat != 0) return stat;
   }

   /* encode responderType */

   if (pvalue->m.responderTypePresent) {
      stat = asn1PE_ResponderGroupAffected (pctxt, pvalue->responderType);
      if (stat != 0) return stat;
   }

   /* encode fuelType */

   if (pvalue->m.fuelTypePresent) {
      stat = asn1PE_FuelType (pctxt, pvalue->fuelType);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_VehicleClassification_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_VehicleMass (OSCTXT* pctxt, VehicleMass value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Axles (OSCTXT* pctxt, Axles* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.frontAxlesPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rearAxlesPresent);

   /* encode totalAxles */

   {
      OSBOOL extbit1;
      if ((pvalue->totalAxles >= 1 && pvalue->totalAxles <= 10)) {
         extbit1 = FALSE;
      }
      else {
         extbit1 = TRUE;
      }

      /* extension bit */

      rtxEncBit (pctxt, extbit1);

      if (extbit1) {
         stat = pe_UnconsUInt32(pctxt, pvalue->totalAxles);
         if (stat != 0) return stat;
      }
      else {
         stat = pe_ConsUnsigned(pctxt, pvalue->totalAxles,  1,  10);
         if (stat != 0) return stat;
      }
   }

   /* encode frontAxles */

   if (pvalue->m.frontAxlesPresent) {
      {
         OSBOOL extbit1;
         if (pvalue->frontAxles <= 10) {
            extbit1 = FALSE;
         }
         else {
            extbit1 = TRUE;
         }

         /* extension bit */

         rtxEncBit (pctxt, extbit1);

         if (extbit1) {
            stat = pe_UnconsUInt32(pctxt, pvalue->frontAxles);
            if (stat != 0) return stat;
         }
         else {
            stat = pe_ConsUnsigned(pctxt, pvalue->frontAxles,  0,  10);
            if (stat != 0) return stat;
         }
      }
   }

   /* encode rearAxles */

   if (pvalue->m.rearAxlesPresent) {
      {
         OSBOOL extbit1;
         if (pvalue->rearAxles <= 10) {
            extbit1 = FALSE;
         }
         else {
            extbit1 = TRUE;
         }

         /* extension bit */

         rtxEncBit (pctxt, extbit1);

         if (extbit1) {
            stat = pe_UnconsUInt32(pctxt, pvalue->rearAxles);
            if (stat != 0) return stat;
         }
         else {
            stat = pe_ConsUnsigned(pctxt, pvalue->rearAxles,  0,  10);
            if (stat != 0) return stat;
         }
      }
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_TrailerWeight (OSCTXT* pctxt, TrailerWeight value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  64255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_CoefficientOfFriction (OSCTXT* pctxt, CoefficientOfFriction value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  50);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_AmbientAirTemperature (OSCTXT* pctxt, AmbientAirTemperature value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  191);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_AmbientAirPressure (OSCTXT* pctxt, AmbientAirPressure value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_WiperStatus (OSCTXT* pctxt, WiperStatus value)
{
   int stat = 0;

   if (value >= 7) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_WiperRate (OSCTXT* pctxt, WiperRate value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  127);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_WiperSet (OSCTXT* pctxt, WiperSet* pvalue)
{
   int stat = 0;

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.statusRearPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rateRearPresent);

   /* encode statusFront */

   stat = asn1PE_WiperStatus (pctxt, pvalue->statusFront);
   if (stat != 0) return stat;

   /* encode rateFront */

   stat = asn1PE_WiperRate (pctxt, pvalue->rateFront);
   if (stat != 0) return stat;

   /* encode statusRear */

   if (pvalue->m.statusRearPresent) {
      stat = asn1PE_WiperStatus (pctxt, pvalue->statusRear);
      if (stat != 0) return stat;
   }

   /* encode rateRear */

   if (pvalue->m.rateRearPresent) {
      stat = asn1PE_WiperRate (pctxt, pvalue->rateRear);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_TrailerUnitDescJ2945Slash1B (OSCTXT* pctxt, TrailerUnitDescJ2945Slash1B* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.heightPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.weightPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rearPivotPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.bumpersPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.axlesPresent);

   /* encode width */

   stat = asn1PE_VehicleWidth (pctxt, pvalue->width);
   if (stat != 0) return stat;

   /* encode length */

   stat = asn1PE_VehicleLength (pctxt, pvalue->length);
   if (stat != 0) return stat;

   /* encode height */

   if (pvalue->m.heightPresent) {
      stat = asn1PE_VehicleHeight (pctxt, pvalue->height);
      if (stat != 0) return stat;
   }

   /* encode weight */

   if (pvalue->m.weightPresent) {
      stat = asn1PE_TrailerWeight (pctxt, pvalue->weight);
      if (stat != 0) return stat;
   }

   /* encode frontPivot */

   stat = asn1PE_PivotPointDescription (pctxt, (PivotPointDescription*)pvalue->frontPivot);
   if (stat != 0) return stat;

   /* encode rearPivot */

   if (pvalue->m.rearPivotPresent) {
      stat = asn1PE_PivotPointDescription (pctxt, (PivotPointDescription*)pvalue->rearPivot);
      if (stat != 0) return stat;
   }

   /* encode bumpers */

   if (pvalue->m.bumpersPresent) {
      stat = asn1PE_BumperHeights (pctxt, &pvalue->bumpers);
      if (stat != 0) return stat;
   }

   /* encode axles */

   if (pvalue->m.axlesPresent) {
      stat = asn1PE_Axles (pctxt, &pvalue->axles);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_TrailersJ2945Slash1B (OSCTXT* pctxt, TrailersJ2945Slash1B* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), OSUINTCONST(0), OSUINT32_MAX);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_TrailerUnitDescJ2945Slash1B (pctxt, ((TrailerUnitDescJ2945Slash1B*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_MinuteOfTheYear (OSCTXT* pctxt, MinuteOfTheYear value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  527040);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_ApproachID (OSCTXT* pctxt, ApproachID value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  15);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_CodeWord (OSCTXT* pctxt, CodeWord* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Confidence (OSCTXT* pctxt, Confidence value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  200);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Count (OSCTXT* pctxt, Count value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  32);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DeltaAngle (OSCTXT* pctxt, DeltaAngle value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -150,  150);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DescriptiveName (OSCTXT* pctxt, DescriptiveName value)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(63), 0, 0);

   stat = pe_ConstrainedStringEx (pctxt, value, 0, 8, 7, 7);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DrivenLineOffsetLg (OSCTXT* pctxt, DrivenLineOffsetLg value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -32767,  32767);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DrivenLineOffsetSm (OSCTXT* pctxt, DrivenLineOffsetSm value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -2047,  2047);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Duration (OSCTXT* pctxt, Duration value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  3600);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_ElevationConfidence (OSCTXT* pctxt, ElevationConfidence value)
{
   int stat = 0;

   if (value >= 16) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_ExteriorLights (OSCTXT* pctxt, ExteriorLights* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(9), OSUINTCONST(9), OSUINTCONST(0), OSUINT32_MAX);

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(9)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(9) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(9)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PortlandCementType (OSCTXT* pctxt, PortlandCementType value)
{
   int stat = 0;

   if (value >= 3) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_AsphaltOrTarType (OSCTXT* pctxt, AsphaltOrTarType value)
{
   int stat = 0;

   if (value >= 4) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_GravelType (OSCTXT* pctxt, GravelType value)
{
   int stat = 0;

   if (value >= 2) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 1);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_GrassType (OSCTXT* pctxt, GrassType value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case lessThan30Mph: ui = 0; break;
      default: 
         return RTERR_INVENUM;
      break;
   }

   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, ui, 0);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_CindersType (OSCTXT* pctxt, CindersType value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case packed: ui = 0; break;
      default: 
         return RTERR_INVENUM;
      break;
   }

   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, ui, 0);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RockType (OSCTXT* pctxt, RockType value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case crushed: ui = 0; break;
      default: 
         return RTERR_INVENUM;
      break;
   }

   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, ui, 0);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_IceType (OSCTXT* pctxt, IceType value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case smooth: ui = 0; break;
      default: 
         return RTERR_INVENUM;
      break;
   }

   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, ui, 0);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SnowType (OSCTXT* pctxt, SnowType value)
{
   int stat = 0;

   if (value >= 2) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 1);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RoadSurfaceCondition (OSCTXT* pctxt, RoadSurfaceCondition value)
{
   int stat = 0;

   if (value >= 2) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 1);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_MeanVariation (OSCTXT* pctxt, MeanVariation value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  25000);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VariationStdDev (OSCTXT* pctxt, VariationStdDev value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  2500);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_FurtherInfoID (OSCTXT* pctxt, FurtherInfoID* pvalue)
{
   int stat = 0;

   if (pvalue->numocts != 2) {
      return RTERR_CONSVIO;
   }
   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 16);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_HeadingConfidence (OSCTXT* pctxt, HeadingConfidence value)
{
   int stat = 0;

   if (value >= 8) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_IntersectionID (OSCTXT* pctxt, IntersectionID value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  65535);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LaneConnectionID (OSCTXT* pctxt, LaneConnectionID value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LaneWidth (OSCTXT* pctxt, LaneWidth value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  32767);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Location_quality (OSCTXT* pctxt, Location_quality value)
{
   int stat = 0;

   if (value >= 8) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Location_tech (OSCTXT* pctxt, Location_tech value)
{
   int stat = 0;

   if (value >= 10) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_MergeDivergeNodeAngle (OSCTXT* pctxt, MergeDivergeNodeAngle value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -180,  180);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_MessageBLOB (OSCTXT* pctxt, MessageBLOB* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(2000), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NodeAttributeXY (OSCTXT* pctxt, NodeAttributeXY value)
{
   int stat = 0;

   if (value >= 12) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_OffsetLL_B18 (OSCTXT* pctxt, OffsetLL_B18 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -131072,  131071);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PayloadData (OSCTXT* pctxt, PayloadData* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2048), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PositionConfidence (OSCTXT* pctxt, PositionConfidence value)
{
   int stat = 0;

   if (value >= 16) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RadiusOfCurvature (OSCTXT* pctxt, RadiusOfCurvature value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -32767,  32767);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RequestID (OSCTXT* pctxt, RequestID value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RequestImportanceLevel (OSCTXT* pctxt, RequestImportanceLevel value)
{
   int stat = 0;

   if (value >= 16) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RequestSubRole (OSCTXT* pctxt, RequestSubRole value)
{
   int stat = 0;

   if (value >= 16) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RestrictionClassID (OSCTXT* pctxt, RestrictionClassID value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_FullRoadAuthorityID (OSCTXT* pctxt, FullRoadAuthorityID value)
{
   int stat = 0;

   stat = pe_ObjectIdentifier (pctxt, &value);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RelativeRoadAuthorityID (OSCTXT* pctxt, RelativeRoadAuthorityID value)
{
   int stat = 0;

   stat = pe_RelativeOID (pctxt, &value);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RoadRegulatorID (OSCTXT* pctxt, RoadRegulatorID value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  65535);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RoadSegmentID (OSCTXT* pctxt, RoadSegmentID value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  65535);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RoadwayCrownAngle (OSCTXT* pctxt, RoadwayCrownAngle value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -128,  127);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Scale_B12 (OSCTXT* pctxt, Scale_B12 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -2048,  2047);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SegmentAttributeXY (OSCTXT* pctxt, SegmentAttributeXY value)
{
   int stat = 0;

   if (value >= 38) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 6);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SignalReqScheme (OSCTXT* pctxt, SignalReqScheme* pvalue)
{
   int stat = 0;

   if (pvalue->numocts != 1) {
      return RTERR_CONSVIO;
   }
   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 8);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SpeedConfidence (OSCTXT* pctxt, SpeedConfidence value)
{
   int stat = 0;

   if (value >= 8) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SpeedLimitType (OSCTXT* pctxt, SpeedLimitType value)
{
   int stat = 0;

   if (value >= 13) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_ThrottleConfidence (OSCTXT* pctxt, ThrottleConfidence value)
{
   int stat = 0;

   if (value >= 4) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_TimeConfidence (OSCTXT* pctxt, TimeConfidence value)
{
   int stat = 0;

   if (value >= 40) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 6);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_TransitStatus (OSCTXT* pctxt, TransitStatus* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 6);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_URL_Link (OSCTXT* pctxt, URL_Link value)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pe_ConstrainedStringEx (pctxt, value, 0, 8, 7, 7);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VehicleEventFlags (OSCTXT* pctxt, VehicleEventFlags* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(13), OSUINTCONST(13), OSUINTCONST(14), OSUINTCONST(14));

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(13)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(13) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(13)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Velocity (OSCTXT* pctxt, Velocity value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  8191);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VertOffset_B08 (OSCTXT* pctxt, VertOffset_B08 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -128,  127);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VertOffset_B09 (OSCTXT* pctxt, VertOffset_B09 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -256,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VertOffset_B10 (OSCTXT* pctxt, VertOffset_B10 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -512,  511);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VertOffset_B11 (OSCTXT* pctxt, VertOffset_B11 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -1024,  1023);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VertOffset_B12 (OSCTXT* pctxt, VertOffset_B12 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -2048,  2047);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_ComputedLane_offsetXaxis (OSCTXT* pctxt, ComputedLane_offsetXaxis* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* small_ */
      case 1:
         stat = asn1PE_DrivenLineOffsetSm (pctxt, pvalue->u.small_);
         if (stat != 0) return stat;
         break;

      /* large_ */
      case 2:
         stat = asn1PE_DrivenLineOffsetLg (pctxt, pvalue->u.large_);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_ComputedLane_offsetYaxis (OSCTXT* pctxt, ComputedLane_offsetYaxis* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* small_ */
      case 1:
         stat = asn1PE_DrivenLineOffsetSm (pctxt, pvalue->u.small_);
         if (stat != 0) return stat;
         break;

      /* large_ */
      case 2:
         stat = asn1PE_DrivenLineOffsetLg (pctxt, pvalue->u.large_);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_ComputedLane_regional (OSCTXT* pctxt, ComputedLane_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_ComputedLane (OSCTXT* pctxt, ComputedLane* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rotateXYPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.scaleXaxisPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.scaleYaxisPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode referenceLaneId */

   stat = asn1PE_LaneID (pctxt, pvalue->referenceLaneId);
   if (stat != 0) return stat;

   /* encode offsetXaxis */

   stat = asn1PE_ComputedLane_offsetXaxis (pctxt, &pvalue->offsetXaxis);
   if (stat != 0) return stat;

   /* encode offsetYaxis */

   stat = asn1PE_ComputedLane_offsetYaxis (pctxt, &pvalue->offsetYaxis);
   if (stat != 0) return stat;

   /* encode rotateXY */

   if (pvalue->m.rotateXYPresent) {
      stat = asn1PE_Common_Angle (pctxt, pvalue->rotateXY);
      if (stat != 0) return stat;
   }

   /* encode scaleXaxis */

   if (pvalue->m.scaleXaxisPresent) {
      stat = asn1PE_Scale_B12 (pctxt, pvalue->scaleXaxis);
      if (stat != 0) return stat;
   }

   /* encode scaleYaxis */

   if (pvalue->m.scaleYaxisPresent) {
      stat = asn1PE_Scale_B12 (pctxt, pvalue->scaleYaxis);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_ComputedLane_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_DDate (OSCTXT* pctxt, DDate* pvalue)
{
   int stat = 0;

   /* encode year */

   stat = asn1PE_DYear (pctxt, pvalue->year);
   if (stat != 0) return stat;

   /* encode month */

   stat = asn1PE_DMonth (pctxt, pvalue->month);
   if (stat != 0) return stat;

   /* encode day */

   stat = asn1PE_DDay (pctxt, pvalue->day);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DFullTime (OSCTXT* pctxt, DFullTime* pvalue)
{
   int stat = 0;

   /* encode year */

   stat = asn1PE_DYear (pctxt, pvalue->year);
   if (stat != 0) return stat;

   /* encode month */

   stat = asn1PE_DMonth (pctxt, pvalue->month);
   if (stat != 0) return stat;

   /* encode day */

   stat = asn1PE_DDay (pctxt, pvalue->day);
   if (stat != 0) return stat;

   /* encode hour */

   stat = asn1PE_DHour (pctxt, pvalue->hour);
   if (stat != 0) return stat;

   /* encode minute */

   stat = asn1PE_DMinute (pctxt, pvalue->minute);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DMonthDay (OSCTXT* pctxt, DMonthDay* pvalue)
{
   int stat = 0;

   /* encode month */

   stat = asn1PE_DMonth (pctxt, pvalue->month);
   if (stat != 0) return stat;

   /* encode day */

   stat = asn1PE_DDay (pctxt, pvalue->day);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DTime (OSCTXT* pctxt, DTime* pvalue)
{
   int stat = 0;

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.offsetPresent);

   /* encode hour */

   stat = asn1PE_DHour (pctxt, pvalue->hour);
   if (stat != 0) return stat;

   /* encode minute */

   stat = asn1PE_DMinute (pctxt, pvalue->minute);
   if (stat != 0) return stat;

   /* encode second */

   stat = asn1PE_DSecond (pctxt, pvalue->second);
   if (stat != 0) return stat;

   /* encode offset */

   if (pvalue->m.offsetPresent) {
      stat = asn1PE_DOffset (pctxt, pvalue->offset);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_DYearMonth (OSCTXT* pctxt, DYearMonth* pvalue)
{
   int stat = 0;

   /* encode year */

   stat = asn1PE_DYear (pctxt, pvalue->year);
   if (stat != 0) return stat;

   /* encode month */

   stat = asn1PE_DMonth (pctxt, pvalue->month);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_TransmissionAndSpeed (OSCTXT* pctxt, TransmissionAndSpeed* pvalue)
{
   int stat = 0;

   /* encode transmisson */

   stat = asn1PE_TransmissionState (pctxt, pvalue->transmisson);
   if (stat != 0) return stat;

   /* encode speed */

   stat = asn1PE_Velocity (pctxt, pvalue->speed);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PositionConfidenceSet (OSCTXT* pctxt, PositionConfidenceSet* pvalue)
{
   int stat = 0;

   /* encode pos */

   stat = asn1PE_PositionConfidence (pctxt, pvalue->pos);
   if (stat != 0) return stat;

   /* encode elevation */

   stat = asn1PE_ElevationConfidence (pctxt, pvalue->elevation);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SpeedandHeadingandThrottleConfidence (OSCTXT* pctxt, SpeedandHeadingandThrottleConfidence* pvalue)
{
   int stat = 0;

   /* encode heading */

   stat = asn1PE_HeadingConfidence (pctxt, pvalue->heading);
   if (stat != 0) return stat;

   /* encode speed */

   stat = asn1PE_SpeedConfidence (pctxt, pvalue->speed);
   if (stat != 0) return stat;

   /* encode throttle */

   stat = asn1PE_ThrottleConfidence (pctxt, pvalue->throttle);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_FullPositionVector (OSCTXT* pctxt, FullPositionVector* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.utcTimePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.elevationPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headingPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.posAccuracyPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeConfidencePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.posConfidencePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedConfidencePresent);

   /* encode utcTime */

   if (pvalue->m.utcTimePresent) {
      stat = asn1PE_DDateTime (pctxt, &pvalue->utcTime);
      if (stat != 0) return stat;
   }

   /* encode long_ */

   stat = asn1PE_Longitude (pctxt, pvalue->long_);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_Latitude (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   /* encode elevation */

   if (pvalue->m.elevationPresent) {
      stat = asn1PE_Common_Elevation (pctxt, pvalue->elevation);
      if (stat != 0) return stat;
   }

   /* encode heading */

   if (pvalue->m.headingPresent) {
      stat = asn1PE_Heading (pctxt, pvalue->heading);
      if (stat != 0) return stat;
   }

   /* encode speed */

   if (pvalue->m.speedPresent) {
      stat = asn1PE_TransmissionAndSpeed (pctxt, &pvalue->speed);
      if (stat != 0) return stat;
   }

   /* encode posAccuracy */

   if (pvalue->m.posAccuracyPresent) {
      stat = asn1PE_PositionalAccuracy (pctxt, &pvalue->posAccuracy);
      if (stat != 0) return stat;
   }

   /* encode timeConfidence */

   if (pvalue->m.timeConfidencePresent) {
      stat = asn1PE_TimeConfidence (pctxt, pvalue->timeConfidence);
      if (stat != 0) return stat;
   }

   /* encode posConfidence */

   if (pvalue->m.posConfidencePresent) {
      stat = asn1PE_PositionConfidenceSet (pctxt, &pvalue->posConfidence);
      if (stat != 0) return stat;
   }

   /* encode speedConfidence */

   if (pvalue->m.speedConfidencePresent) {
      stat = asn1PE_SpeedandHeadingandThrottleConfidence (pctxt, &pvalue->speedConfidence);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_Header (OSCTXT* pctxt, Header* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.yearPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.secMarkPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.msgIssueRevisionPresent);

   /* encode year */

   if (pvalue->m.yearPresent) {
      stat = asn1PE_DYear (pctxt, pvalue->year);
      if (stat != 0) return stat;
   }

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode secMark */

   if (pvalue->m.secMarkPresent) {
      stat = asn1PE_DSecond (pctxt, pvalue->secMark);
      if (stat != 0) return stat;
   }

   /* encode msgIssueRevision */

   if (pvalue->m.msgIssueRevisionPresent) {
      stat = asn1PE_Common_MsgCount (pctxt, pvalue->msgIssueRevision);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_IntersectionAccessPoint (OSCTXT* pctxt, IntersectionAccessPoint* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 3);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 2);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* lane */
         case 1:
            stat = asn1PE_LaneID (pctxt, pvalue->u.lane);
            if (stat != 0) return stat;
            break;

         /* approach */
         case 2:
            stat = asn1PE_ApproachID (pctxt, pvalue->u.approach);
            if (stat != 0) return stat;
            break;

         /* connection */
         case 3:
            stat = asn1PE_LaneConnectionID (pctxt, pvalue->u.connection);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_IntersectionReferenceID (OSCTXT* pctxt, IntersectionReferenceID* pvalue)
{
   int stat = 0;

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionPresent);

   /* encode region */

   if (pvalue->m.regionPresent) {
      stat = asn1PE_RoadRegulatorID (pctxt, pvalue->region);
      if (stat != 0) return stat;
   }

   /* encode id */

   stat = asn1PE_IntersectionID (pctxt, pvalue->id);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RegulatorySpeedLimit (OSCTXT* pctxt, RegulatorySpeedLimit* pvalue)
{
   int stat = 0;

   /* encode type */

   stat = asn1PE_SpeedLimitType (pctxt, pvalue->type);
   if (stat != 0) return stat;

   /* encode speed */

   stat = asn1PE_Velocity (pctxt, pvalue->speed);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SpeedLimitList (OSCTXT* pctxt, SpeedLimitList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(9), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegulatorySpeedLimit (pctxt, ((RegulatorySpeedLimit*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_LaneDataAttribute_regional (OSCTXT* pctxt, LaneDataAttribute_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_LaneDataAttribute (OSCTXT* pctxt, LaneDataAttribute* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 7);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 3);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* pathEndPointAngle */
         case 1:
            stat = asn1PE_DeltaAngle (pctxt, pvalue->u.pathEndPointAngle);
            if (stat != 0) return stat;
            break;

         /* laneCrownPointCenter */
         case 2:
            stat = asn1PE_RoadwayCrownAngle (pctxt, pvalue->u.laneCrownPointCenter);
            if (stat != 0) return stat;
            break;

         /* laneCrownPointLeft */
         case 3:
            stat = asn1PE_RoadwayCrownAngle (pctxt, pvalue->u.laneCrownPointLeft);
            if (stat != 0) return stat;
            break;

         /* laneCrownPointRight */
         case 4:
            stat = asn1PE_RoadwayCrownAngle (pctxt, pvalue->u.laneCrownPointRight);
            if (stat != 0) return stat;
            break;

         /* laneAngle */
         case 5:
            stat = asn1PE_MergeDivergeNodeAngle (pctxt, pvalue->u.laneAngle);
            if (stat != 0) return stat;
            break;

         /* speedLimits */
         case 6:
            stat = asn1PE_SpeedLimitList (pctxt, pvalue->u.speedLimits);
            if (stat != 0) return stat;
            break;

         /* regional */
         case 7:
            stat = asn1PE_LaneDataAttribute_regional (pctxt, pvalue->u.regional);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 8);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_LaneDataAttributeList (OSCTXT* pctxt, LaneDataAttributeList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_LaneDataAttribute (pctxt, ((LaneDataAttribute*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_NodeAttributeXYList (OSCTXT* pctxt, NodeAttributeXYList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_NodeAttributeXY (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_SegmentAttributeXYList (OSCTXT* pctxt, SegmentAttributeXYList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_SegmentAttributeXY (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_NodeAttributeSetXY_regional (OSCTXT* pctxt, NodeAttributeSetXY_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_NodeAttributeSetXY (OSCTXT* pctxt, NodeAttributeSetXY* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.localNodePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.disabledPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.enabledPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dWidthPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dElevationPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode localNode */

   if (pvalue->m.localNodePresent) {
      stat = asn1PE_NodeAttributeXYList (pctxt, &pvalue->localNode);
      if (stat != 0) return stat;
   }

   /* encode disabled */

   if (pvalue->m.disabledPresent) {
      stat = asn1PE_SegmentAttributeXYList (pctxt, &pvalue->disabled);
      if (stat != 0) return stat;
   }

   /* encode enabled */

   if (pvalue->m.enabledPresent) {
      stat = asn1PE_SegmentAttributeXYList (pctxt, &pvalue->enabled);
      if (stat != 0) return stat;
   }

   /* encode data */

   if (pvalue->m.dataPresent) {
      stat = asn1PE_LaneDataAttributeList (pctxt, &pvalue->data);
      if (stat != 0) return stat;
   }

   /* encode dWidth */

   if (pvalue->m.dWidthPresent) {
      stat = asn1PE_Offset_B10 (pctxt, pvalue->dWidth);
      if (stat != 0) return stat;
   }

   /* encode dElevation */

   if (pvalue->m.dElevationPresent) {
      stat = asn1PE_Offset_B10 (pctxt, pvalue->dElevation);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_NodeAttributeSetXY_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NodeXY (OSCTXT* pctxt, NodeXY* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.attributesPresent);

   /* encode delta */

   stat = asn1PE_NodeOffsetPointXY (pctxt, &pvalue->delta);
   if (stat != 0) return stat;

   /* encode attributes */

   if (pvalue->m.attributesPresent) {
      stat = asn1PE_NodeAttributeSetXY (pctxt, &pvalue->attributes);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NodeSetXY (OSCTXT* pctxt, NodeSetXY* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(63), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_NodeXY (pctxt, ((NodeXY*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_NodeListXY (OSCTXT* pctxt, NodeListXY* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 2);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* nodes */
         case 1:
            stat = asn1PE_NodeSetXY (pctxt, pvalue->u.nodes);
            if (stat != 0) return stat;
            break;

         /* computed */
         case 2:
            stat = asn1PE_ComputedLane (pctxt, pvalue->u.computed);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_PathHistoryPoint (OSCTXT* pctxt, PathHistoryPoint* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.posAccuracyPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headingPresent);

   /* encode latOffset */

   stat = asn1PE_OffsetLL_B18 (pctxt, pvalue->latOffset);
   if (stat != 0) return stat;

   /* encode lonOffset */

   stat = asn1PE_OffsetLL_B18 (pctxt, pvalue->lonOffset);
   if (stat != 0) return stat;

   /* encode elevationOffset */

   stat = asn1PE_VertOffset_B12 (pctxt, pvalue->elevationOffset);
   if (stat != 0) return stat;

   /* encode timeOffset */

   stat = asn1PE_TimeOffset (pctxt, pvalue->timeOffset);
   if (stat != 0) return stat;

   /* encode speed */

   if (pvalue->m.speedPresent) {
      stat = asn1PE_Speed (pctxt, pvalue->speed);
      if (stat != 0) return stat;
   }

   /* encode posAccuracy */

   if (pvalue->m.posAccuracyPresent) {
      stat = asn1PE_PositionalAccuracy (pctxt, &pvalue->posAccuracy);
      if (stat != 0) return stat;
   }

   /* encode heading */

   if (pvalue->m.headingPresent) {
      stat = asn1PE_CoarseHeading (pctxt, pvalue->heading);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_PathHistoryPointList (OSCTXT* pctxt, PathHistoryPointList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(23), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_PathHistoryPoint (pctxt, ((PathHistoryPoint*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_PathHistory (OSCTXT* pctxt, PathHistory* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.initialPositionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.currGNSSstatusPresent);

   /* encode initialPosition */

   if (pvalue->m.initialPositionPresent) {
      stat = asn1PE_FullPositionVector (pctxt, &pvalue->initialPosition);
      if (stat != 0) return stat;
   }

   /* encode currGNSSstatus */

   if (pvalue->m.currGNSSstatusPresent) {
      stat = asn1PE_GNSSstatus (pctxt, &pvalue->currGNSSstatus);
      if (stat != 0) return stat;
   }

   /* encode crumbData */

   stat = asn1PE_PathHistoryPointList (pctxt, &pvalue->crumbData);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_PathPrediction (OSCTXT* pctxt, PathPrediction* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode radiusOfCurve */

   stat = asn1PE_RadiusOfCurvature (pctxt, pvalue->radiusOfCurve);
   if (stat != 0) return stat;

   /* encode confidence */

   stat = asn1PE_Confidence (pctxt, pvalue->confidence);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_Position3D_regional (OSCTXT* pctxt, Position3D_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_Position3D (OSCTXT* pctxt, Position3D* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.elevationPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode lat */

   stat = asn1PE_Latitude (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   /* encode long_ */

   stat = asn1PE_Longitude (pctxt, pvalue->long_);
   if (stat != 0) return stat;

   /* encode elevation */

   if (pvalue->m.elevationPresent) {
      stat = asn1PE_Common_Elevation (pctxt, pvalue->elevation);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_Position3D_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RequestorType (OSCTXT* pctxt, RequestorType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.subrolePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.requestPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.iso3883Present);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.hpmsTypePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode role */

   stat = asn1PE_BasicVehicleRole (pctxt, pvalue->role);
   if (stat != 0) return stat;

   /* encode subrole */

   if (pvalue->m.subrolePresent) {
      stat = asn1PE_RequestSubRole (pctxt, pvalue->subrole);
      if (stat != 0) return stat;
   }

   /* encode request */

   if (pvalue->m.requestPresent) {
      stat = asn1PE_RequestImportanceLevel (pctxt, pvalue->request);
      if (stat != 0) return stat;
   }

   /* encode iso3883 */

   if (pvalue->m.iso3883Present) {
      stat = asn1PE_Iso3833VehicleType (pctxt, pvalue->iso3883);
      if (stat != 0) return stat;
   }

   /* encode hpmsType */

   if (pvalue->m.hpmsTypePresent) {
      stat = asn1PE_VehicleType (pctxt, pvalue->hpmsType);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RoadSegmentReferenceID (OSCTXT* pctxt, RoadSegmentReferenceID* pvalue)
{
   int stat = 0;

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionPresent);

   /* encode region */

   if (pvalue->m.regionPresent) {
      stat = asn1PE_RoadRegulatorID (pctxt, pvalue->region);
      if (stat != 0) return stat;
   }

   /* encode id */

   stat = asn1PE_RoadSegmentID (pctxt, pvalue->id);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VehicleID (OSCTXT* pctxt, VehicleID* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* entityID */
      case 1:
         stat = asn1PE_TemporaryID (pctxt, pvalue->u.entityID);
         if (stat != 0) return stat;
         break;

      /* stationID */
      case 2:
         stat = asn1PE_StationID (pctxt, pvalue->u.stationID);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_VehicleSafetyExtensions (OSCTXT* pctxt, VehicleSafetyExtensions* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   extbit = (OSBOOL)(pvalue->m.timestampPresent ||
   pvalue->m.heightPresent ||
   pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.eventsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pathHistoryPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pathPredictionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.lightsPresent);

   /* encode events */

   if (pvalue->m.eventsPresent) {
      stat = asn1PE_VehicleEventFlags (pctxt, &pvalue->events);
      if (stat != 0) return stat;
   }

   /* encode pathHistory */

   if (pvalue->m.pathHistoryPresent) {
      stat = asn1PE_PathHistory (pctxt, &pvalue->pathHistory);
      if (stat != 0) return stat;
   }

   /* encode pathPrediction */

   if (pvalue->m.pathPredictionPresent) {
      stat = asn1PE_PathPrediction (pctxt, &pvalue->pathPrediction);
      if (stat != 0) return stat;
   }

   /* encode lights */

   if (pvalue->m.lightsPresent) {
      stat = asn1PE_ExteriorLights (pctxt, &pvalue->lights);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count + 2);
      if (stat != 0) return stat;

      /* encode optional bits */

      rtxEncBit (pctxt, (OSBOOL)pvalue->m.timestampPresent);

      rtxEncBit (pctxt, (OSBOOL)pvalue->m.heightPresent);

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->m.timestampPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return stat;

         stat = asn1PE_DDateTime (pctxt, &pvalue->timestamp);
         if (stat != 0) return stat;

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return stat;
      }

      if (pvalue->m.heightPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return stat;

         stat = asn1PE_VehicleHeight (pctxt, pvalue->height);
         if (stat != 0) return stat;

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return stat;
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_VerticalOffset (OSCTXT* pctxt, VerticalOffset* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 3);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* offset1 */
      case 1:
         stat = asn1PE_VertOffset_B07 (pctxt, pvalue->u.offset1);
         if (stat != 0) return stat;
         break;

      /* offset2 */
      case 2:
         stat = asn1PE_VertOffset_B08 (pctxt, pvalue->u.offset2);
         if (stat != 0) return stat;
         break;

      /* offset3 */
      case 3:
         stat = asn1PE_VertOffset_B09 (pctxt, pvalue->u.offset3);
         if (stat != 0) return stat;
         break;

      /* offset4 */
      case 4:
         stat = asn1PE_VertOffset_B10 (pctxt, pvalue->u.offset4);
         if (stat != 0) return stat;
         break;

      /* offset5 */
      case 5:
         stat = asn1PE_VertOffset_B11 (pctxt, pvalue->u.offset5);
         if (stat != 0) return stat;
         break;

      /* offset6 */
      case 6:
         stat = asn1PE_VertOffset_B12 (pctxt, pvalue->u.offset6);
         if (stat != 0) return stat;
         break;

      /* elevation */
      case 7:
         stat = asn1PE_Common_Elevation (pctxt, pvalue->u.elevation);
         if (stat != 0) return stat;
         break;

      /* regional */
      case 8:
         stat = asn1PE_RegionalExtension (pctxt, pvalue->u.regional);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_PortlandCement (OSCTXT* pctxt, PortlandCement* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode type */

   stat = asn1PE_PortlandCementType (pctxt, pvalue->type);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_AsphaltOrTar (OSCTXT* pctxt, AsphaltOrTar* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode type */

   stat = asn1PE_AsphaltOrTarType (pctxt, pvalue->type);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_Gravel (OSCTXT* pctxt, Gravel* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode type */

   stat = asn1PE_GravelType (pctxt, pvalue->type);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_Grass (OSCTXT* pctxt, Grass* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode type */

   stat = asn1PE_GrassType (pctxt, pvalue->type);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_Cinders (OSCTXT* pctxt, Cinders* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode type */

   stat = asn1PE_CindersType (pctxt, pvalue->type);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_Rock (OSCTXT* pctxt, Rock* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode type */

   stat = asn1PE_RockType (pctxt, pvalue->type);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_Ice (OSCTXT* pctxt, Ice* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode type */

   stat = asn1PE_IceType (pctxt, pvalue->type);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_Snow (OSCTXT* pctxt, Snow* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode type */

   stat = asn1PE_SnowType (pctxt, pvalue->type);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_DescriptionOfRoadSurface (OSCTXT* pctxt, DescriptionOfRoadSurface* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 8);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 3);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* portlandCement */
         case 1:
            stat = asn1PE_PortlandCement (pctxt, pvalue->u.portlandCement);
            if (stat != 0) return stat;
            break;

         /* asphaltOrTar */
         case 2:
            stat = asn1PE_AsphaltOrTar (pctxt, pvalue->u.asphaltOrTar);
            if (stat != 0) return stat;
            break;

         /* gravel */
         case 3:
            stat = asn1PE_Gravel (pctxt, pvalue->u.gravel);
            if (stat != 0) return stat;
            break;

         /* grass */
         case 4:
            stat = asn1PE_Grass (pctxt, pvalue->u.grass);
            if (stat != 0) return stat;
            break;

         /* cinders */
         case 5:
            stat = asn1PE_Cinders (pctxt, pvalue->u.cinders);
            if (stat != 0) return stat;
            break;

         /* rock */
         case 6:
            stat = asn1PE_Rock (pctxt, pvalue->u.rock);
            if (stat != 0) return stat;
            break;

         /* ice */
         case 7:
            stat = asn1PE_Ice (pctxt, pvalue->u.ice);
            if (stat != 0) return stat;
            break;

         /* snow */
         case 8:
            stat = asn1PE_Snow (pctxt, pvalue->u.snow);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 9);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_RoadRoughness (OSCTXT* pctxt, RoadRoughness* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.verticalVariationStdDevPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.meanHorizontalVariationPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.horizontalVariationStdDevPresent);

   /* encode meanVerticalVariation */

   stat = asn1PE_MeanVariation (pctxt, pvalue->meanVerticalVariation);
   if (stat != 0) return stat;

   /* encode verticalVariationStdDev */

   if (pvalue->m.verticalVariationStdDevPresent) {
      stat = asn1PE_VariationStdDev (pctxt, pvalue->verticalVariationStdDev);
      if (stat != 0) return stat;
   }

   /* encode meanHorizontalVariation */

   if (pvalue->m.meanHorizontalVariationPresent) {
      stat = asn1PE_MeanVariation (pctxt, pvalue->meanHorizontalVariation);
      if (stat != 0) return stat;
   }

   /* encode horizontalVariationStdDev */

   if (pvalue->m.horizontalVariationStdDevPresent) {
      stat = asn1PE_VariationStdDev (pctxt, pvalue->horizontalVariationStdDev);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_FrictionInformation (OSCTXT* pctxt, FrictionInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dryOrWetPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.roadRoughnessPresent);

   /* encode roadSurfaceDescription */

   stat = asn1PE_DescriptionOfRoadSurface (pctxt, &pvalue->roadSurfaceDescription);
   if (stat != 0) return stat;

   /* encode dryOrWet */

   if (pvalue->m.dryOrWetPresent) {
      stat = asn1PE_RoadSurfaceCondition (pctxt, pvalue->dryOrWet);
      if (stat != 0) return stat;
   }

   /* encode roadRoughness */

   if (pvalue->m.roadRoughnessPresent) {
      stat = asn1PE_RoadRoughness (pctxt, &pvalue->roadRoughness);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RoadAuthorityID (OSCTXT* pctxt, RoadAuthorityID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 2);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* fullRdAuthID */
         case 1:
            stat = asn1PE_FullRoadAuthorityID (pctxt, *pvalue->u.fullRdAuthID);
            if (stat != 0) return stat;
            break;

         /* relRdAuthID */
         case 2:
            stat = asn1PE_RelativeRoadAuthorityID (pctxt, *pvalue->u.relRdAuthID);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

