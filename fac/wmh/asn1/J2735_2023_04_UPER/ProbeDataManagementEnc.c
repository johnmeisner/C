/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "ProbeDataManagement.h"
#include "REGION.h"
#include "Common.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PE_GrossDistance (OSCTXT* pctxt, GrossDistance value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  1023);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SecondOfTime (OSCTXT* pctxt, SecondOfTime value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  61);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_TermDistance (OSCTXT* pctxt, TermDistance value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  1,  30000);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_TermTime (OSCTXT* pctxt, TermTime value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  1,  1800);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VehicleStatusDeviceTypeTag (OSCTXT* pctxt, VehicleStatusDeviceTypeTag value)
{
   int stat = 0;

   if (value >= 29) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 5);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Sample (OSCTXT* pctxt, Sample* pvalue)
{
   int stat = 0;

   /* encode sampleStart */

   stat = pe_ConsUnsigned(pctxt, pvalue->sampleStart,  0,  255);
   if (stat != 0) return stat;

   /* encode sampleEnd */

   stat = pe_ConsUnsigned(pctxt, pvalue->sampleEnd,  0,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_ProbeDataManagement_term (OSCTXT* pctxt, ProbeDataManagement_term* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* termtime */
      case 1:
         stat = asn1PE_TermTime (pctxt, pvalue->u.termtime);
         if (stat != 0) return stat;
         break;

      /* termDistance */
      case 2:
         stat = asn1PE_TermDistance (pctxt, pvalue->u.termDistance);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_SnapshotTime (OSCTXT* pctxt, SnapshotTime* pvalue)
{
   int stat = 0;

   /* encode speed1 */

   stat = asn1PE_GrossSpeed (pctxt, pvalue->speed1);
   if (stat != 0) return stat;

   /* encode time1 */

   stat = asn1PE_SecondOfTime (pctxt, pvalue->time1);
   if (stat != 0) return stat;

   /* encode speed2 */

   stat = asn1PE_GrossSpeed (pctxt, pvalue->speed2);
   if (stat != 0) return stat;

   /* encode time2 */

   stat = asn1PE_SecondOfTime (pctxt, pvalue->time2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SnapshotDistance (OSCTXT* pctxt, SnapshotDistance* pvalue)
{
   int stat = 0;

   /* encode distance1 */

   stat = asn1PE_GrossDistance (pctxt, pvalue->distance1);
   if (stat != 0) return stat;

   /* encode speed1 */

   stat = asn1PE_GrossSpeed (pctxt, pvalue->speed1);
   if (stat != 0) return stat;

   /* encode distance2 */

   stat = asn1PE_GrossDistance (pctxt, pvalue->distance2);
   if (stat != 0) return stat;

   /* encode speed2 */

   stat = asn1PE_GrossSpeed (pctxt, pvalue->speed2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_ProbeDataManagement_snapshot (OSCTXT* pctxt, ProbeDataManagement_snapshot* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* snapshotTime */
      case 1:
         stat = asn1PE_SnapshotTime (pctxt, pvalue->u.snapshotTime);
         if (stat != 0) return stat;
         break;

      /* snapshotDistance */
      case 2:
         stat = asn1PE_SnapshotDistance (pctxt, pvalue->u.snapshotDistance);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_VehicleStatusRequest (OSCTXT* pctxt, VehicleStatusRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.subTypePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.sendOnLessThenValuePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.sendOnMoreThenValuePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.sendAllPresent);

   /* encode dataType */

   stat = asn1PE_VehicleStatusDeviceTypeTag (pctxt, pvalue->dataType);
   if (stat != 0) return stat;

   /* encode subType */

   if (pvalue->m.subTypePresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->subType,  1,  15);
      if (stat != 0) return stat;

   }

   /* encode sendOnLessThenValue */

   if (pvalue->m.sendOnLessThenValuePresent) {
      stat = pe_ConsInteger(pctxt, pvalue->sendOnLessThenValue,  -32767,  32767);
      if (stat != 0) return stat;

   }

   /* encode sendOnMoreThenValue */

   if (pvalue->m.sendOnMoreThenValuePresent) {
      stat = pe_ConsInteger(pctxt, pvalue->sendOnMoreThenValue,  -32767,  32767);
      if (stat != 0) return stat;

   }

   /* encode sendAll */

   if (pvalue->m.sendAllPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->sendAll);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_VehicleStatusRequestList (OSCTXT* pctxt, VehicleStatusRequestList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_VehicleStatusRequest (pctxt, ((VehicleStatusRequest*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_ProbeDataManagement_regional (OSCTXT* pctxt, ProbeDataManagement_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_ProbeDataManagement (OSCTXT* pctxt, ProbeDataManagement* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataElementsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode sample */

   stat = asn1PE_Sample (pctxt, &pvalue->sample);
   if (stat != 0) return stat;

   /* encode directions */

   stat = asn1PE_HeadingSlice (pctxt, (HeadingSlice*)pvalue->directions);
   if (stat != 0) return stat;

   /* encode term */

   stat = asn1PE_ProbeDataManagement_term (pctxt, &pvalue->term);
   if (stat != 0) return stat;

   /* encode snapshot */

   stat = asn1PE_ProbeDataManagement_snapshot (pctxt, &pvalue->snapshot);
   if (stat != 0) return stat;

   /* encode txInterval */

   stat = asn1PE_SecondOfTime (pctxt, pvalue->txInterval);
   if (stat != 0) return stat;

   /* encode dataElements */

   if (pvalue->m.dataElementsPresent) {
      stat = asn1PE_VehicleStatusRequestList (pctxt, &pvalue->dataElements);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_ProbeDataManagement_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

