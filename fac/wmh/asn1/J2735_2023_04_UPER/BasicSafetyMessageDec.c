/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "BasicSafetyMessage.h"
#include "REGION.h"
#include "Common.h"
#include "ProbeDataReport.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PD_PartII_Id (OSCTXT* pctxt, PartII_Id* pvalue)
{
   return rtxDecBitsToByte(pctxt, pvalue, 6);
}

EXTERN int asn1PD_IsDolly (OSCTXT* pctxt, IsDolly* pvalue)
{
   int stat = 0;

   rtxDecBit(pctxt, pvalue);

   return (stat);
}

EXTERN int asn1PD_ObstacleDirection (OSCTXT* pctxt, ObstacleDirection* pvalue)
{
   int stat = 0;

   stat = asn1PD_Common_Angle (pctxt, (Common_Angle*)pvalue);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_PivotingAllowed (OSCTXT* pctxt, PivotingAllowed* pvalue)
{
   int stat = 0;

   rtxDecBit(pctxt, pvalue);

   return (stat);
}

EXTERN int asn1PD_SpeedProfileMeasurement (OSCTXT* pctxt, SpeedProfileMeasurement* pvalue)
{
   int stat = 0;

   stat = asn1PD_GrossSpeed (pctxt, (GrossSpeed*)pvalue);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_TrailerMass (OSCTXT* pctxt, TrailerMass* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_VertOffset_B07 (OSCTXT* pctxt, VertOffset_B07* pvalue)
{
   int stat;

   /* range_value = 128, range_bitcnt = 7 */
   stat = pd_ConsInt8(pctxt, pvalue, -64, 63);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_PartIIcontent (OSCTXT* pctxt, PartIIcontent* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode partII_Id */
   pctxt->level++;

   stat = asn1PD_PartII_Id (pctxt, &pvalue->partII_Id);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode partII_Value */
   pctxt->level++;

   stat = pd_OpenType (pctxt, &pvalue->partII_Value.data, &pvalue->partII_Value.numocts);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_BasicSafetyMessage_partII (OSCTXT* pctxt, BasicSafetyMessage_partII* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PartIIcontent* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, PartIIcontent);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_PartIIcontent (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PartIIcontent (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_BasicSafetyMessage_regional (OSCTXT* pctxt, BasicSafetyMessage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_BasicSafetyMessage (OSCTXT* pctxt, BasicSafetyMessage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode coreData */
   pctxt->level++;

   pvalue->coreData = rtxMemAllocType (pctxt, BSMcoreData);

   if (pvalue->coreData == NULL)
      return RTERR_NOMEM;

   asn1Init_BSMcoreData ((BSMcoreData*)pvalue->coreData);

   stat = asn1PD_BSMcoreData (pctxt, (BSMcoreData*)pvalue->coreData);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode partII */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.partIIPresent = 1;

      stat = asn1PD_BasicSafetyMessage_partII (pctxt, &pvalue->partII);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode regional */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.regionalPresent = 1;

      stat = asn1PD_BasicSafetyMessage_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_DisabledVehicle (OSCTXT* pctxt, DisabledVehicle* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode statusDetails */
   pctxt->level++;

   stat = rtxDecBitsToUInt16(pctxt, &pvalue->statusDetails, 5);
   if (stat != 0) return stat;

   if (pvalue->statusDetails > 18) {
      return RTERR_CONSVIO;
   }

   pvalue->statusDetails += 523;

   pctxt->level--;

   /* decode locationDetails */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.locationDetailsPresent = 1;

      stat = asn1PD_GenericLocations (pctxt, &pvalue->locationDetails);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_EventDescription_description (OSCTXT* pctxt, EventDescription_description* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 8) {
      return RTERR_CONSVIO;
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      pctxt->level++;

      stat = asn1PD_ITIScodes (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_EventDescription_regional (OSCTXT* pctxt, EventDescription_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_EventDescription (OSCTXT* pctxt, EventDescription* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode typeEvent */
         pctxt->level++;

         stat = asn1PD_ITIScodes (pctxt, &pvalue->typeEvent);

         pctxt->level--;
         break;

         case 1:
         /* decode description */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.descriptionPresent = 1;

            stat = asn1PD_EventDescription_description (pctxt, &pvalue->description);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode priority */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.priorityPresent = 1;

            pvalue->priority = rtxMemAllocType (pctxt, Priority);

            if (pvalue->priority == NULL)
               return RTERR_NOMEM;

            asn1Init_Priority ((Priority*)pvalue->priority);

            stat = asn1PD_Priority (pctxt, (Priority*)pvalue->priority);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode heading */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.headingPresent = 1;

            pvalue->heading = rtxMemAllocType (pctxt, HeadingSlice);

            if (pvalue->heading == NULL)
               return RTERR_NOMEM;

            asn1Init_HeadingSlice ((HeadingSlice*)pvalue->heading);

            stat = asn1PD_HeadingSlice (pctxt, (HeadingSlice*)pvalue->heading);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode extent */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.extentPresent = 1;

            stat = asn1PD_Extent (pctxt, (Extent*)&pvalue->extent);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_EventDescription_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_ObstacleDetection (OSCTXT* pctxt, ObstacleDetection* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode obDist */
         pctxt->level++;

         stat = asn1PD_ObstacleDistance (pctxt, (ObstacleDistance*)&pvalue->obDist);

         pctxt->level--;
         break;

         case 1:
         /* decode obDirect */
         pctxt->level++;

         stat = asn1PD_ObstacleDirection (pctxt, (ObstacleDirection*)&pvalue->obDirect);

         pctxt->level--;
         break;

         case 2:
         /* decode description */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.descriptionPresent = 1;

            stat = rtxDecBitsToUInt16(pctxt, &pvalue->description, 5);
            if (stat != 0) return stat;

            if (pvalue->description > 18) {
               return RTERR_CONSVIO;
            }

            pvalue->description += 523;

            pctxt->level--;
         }
         break;

         case 3:
         /* decode locationDetails */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.locationDetailsPresent = 1;

            stat = asn1PD_GenericLocations (pctxt, &pvalue->locationDetails);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode dateTime */
         pctxt->level++;

         pvalue->dateTime = rtxMemAllocType (pctxt, DDateTime);

         if (pvalue->dateTime == NULL)
            return RTERR_NOMEM;

         asn1Init_DDateTime ((DDateTime*)pvalue->dateTime);

         stat = asn1PD_DDateTime (pctxt, (DDateTime*)pvalue->dateTime);

         pctxt->level--;
         break;

         case 5:
         /* decode vertEvent */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vertEventPresent = 1;

            pvalue->vertEvent = rtxMemAllocType (pctxt, 
               VerticalAccelerationThreshold);

            if (pvalue->vertEvent == NULL)
               return RTERR_NOMEM;

            asn1Init_VerticalAccelerationThreshold ((VerticalAccelerationThreshold*)pvalue->vertEvent);

            stat = asn1PD_VerticalAccelerationThreshold (pctxt, (VerticalAccelerationThreshold*)pvalue->vertEvent);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_PivotPointDescription (OSCTXT* pctxt, PivotPointDescription* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode pivotOffset */
   pctxt->level++;

   stat = asn1PD_Offset_B11 (pctxt, (Offset_B11*)&pvalue->pivotOffset);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode pivotAngle */
   pctxt->level++;

   stat = asn1PD_Common_Angle (pctxt, (Common_Angle*)&pvalue->pivotAngle);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode pivots */
   pctxt->level++;

   stat = asn1PD_PivotingAllowed (pctxt, &pvalue->pivots);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RTCMPackage (OSCTXT* pctxt, RTCMPackage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode rtcmHeader */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.rtcmHeaderPresent = 1;

      pvalue->rtcmHeader = rtxMemAllocType (pctxt, RTCMheader);

      if (pvalue->rtcmHeader == NULL)
         return RTERR_NOMEM;

      asn1Init_RTCMheader ((RTCMheader*)pvalue->rtcmHeader);

      stat = asn1PD_RTCMheader (pctxt, (RTCMheader*)pvalue->rtcmHeader);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode msgs */
   pctxt->level++;

   pvalue->msgs = rtxMemAllocType (pctxt, RTCMmessageList);

   if (pvalue->msgs == NULL)
      return RTERR_NOMEM;

   asn1Init_RTCMmessageList ((RTCMmessageList*)pvalue->msgs);

   stat = asn1PD_RTCMmessageList (pctxt, (RTCMmessageList*)pvalue->msgs);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_TrailerHistoryPoint (OSCTXT* pctxt, TrailerHistoryPoint* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode pivotAngle */
   pctxt->level++;

   stat = asn1PD_Common_Angle (pctxt, (Common_Angle*)&pvalue->pivotAngle);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode timeOffset */
   pctxt->level++;

   stat = asn1PD_TimeOffset (pctxt, (TimeOffset*)&pvalue->timeOffset);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode positionOffset */
   pctxt->level++;

   pvalue->positionOffset = rtxMemAllocTypeZ (pctxt, Node_XY_24b);

   if (pvalue->positionOffset == NULL)
      return RTERR_NOMEM;

   stat = asn1PD_Node_XY_24b (pctxt, (Node_XY_24b*)pvalue->positionOffset);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode elevationOffset */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.elevationOffsetPresent = 1;

      stat = asn1PD_VertOffset_B07 (pctxt, &pvalue->elevationOffset);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode heading */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.headingPresent = 1;

      stat = asn1PD_CoarseHeading (pctxt, (CoarseHeading*)&pvalue->heading);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_TrailerHistoryPointList (OSCTXT* pctxt, TrailerHistoryPointList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(23), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TrailerHistoryPoint* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, TrailerHistoryPoint);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_TrailerHistoryPoint (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TrailerHistoryPoint (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_TrailerUnitDescription (OSCTXT* pctxt, TrailerUnitDescription* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[8];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 8; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 13; i_++) {
      switch (i_) {
         case 0:
         /* decode isDolly */
         pctxt->level++;

         stat = asn1PD_IsDolly (pctxt, &pvalue->isDolly);

         pctxt->level--;
         break;

         case 1:
         /* decode width */
         pctxt->level++;

         stat = asn1PD_VehicleWidth (pctxt, (VehicleWidth*)&pvalue->width);

         pctxt->level--;
         break;

         case 2:
         /* decode length */
         pctxt->level++;

         stat = asn1PD_VehicleLength (pctxt, (VehicleLength*)&pvalue->length);

         pctxt->level--;
         break;

         case 3:
         /* decode height */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.heightPresent = 1;

            stat = asn1PD_VehicleHeight (pctxt, (VehicleHeight*)&pvalue->height);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode mass */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.massPresent = 1;

            stat = asn1PD_TrailerMass (pctxt, &pvalue->mass);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode bumperHeights */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.bumperHeightsPresent = 1;

            pvalue->bumperHeights = rtxMemAllocTypeZ (pctxt, BumperHeights);

            if (pvalue->bumperHeights == NULL)
               return RTERR_NOMEM;

            stat = asn1PD_BumperHeights (pctxt, (BumperHeights*)pvalue->bumperHeights);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode centerOfGravity */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.centerOfGravityPresent = 1;

            stat = asn1PD_VehicleHeight (pctxt, (VehicleHeight*)&pvalue->centerOfGravity);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode frontPivot */
         pctxt->level++;

         stat = asn1PD_PivotPointDescription (pctxt, &pvalue->frontPivot);

         pctxt->level--;
         break;

         case 8:
         /* decode rearPivot */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.rearPivotPresent = 1;

            stat = asn1PD_PivotPointDescription (pctxt, &pvalue->rearPivot);

            pctxt->level--;
         }
         break;

         case 9:
         /* decode rearWheelOffset */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.rearWheelOffsetPresent = 1;

            stat = asn1PD_Offset_B12 (pctxt, (Offset_B12*)&pvalue->rearWheelOffset);

            pctxt->level--;
         }
         break;

         case 10:
         /* decode positionOffset */
         pctxt->level++;

         pvalue->positionOffset = rtxMemAllocTypeZ (pctxt, Node_XY_24b);

         if (pvalue->positionOffset == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_XY_24b (pctxt, (Node_XY_24b*)pvalue->positionOffset);

         pctxt->level--;
         break;

         case 11:
         /* decode elevationOffset */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.elevationOffsetPresent = 1;

            stat = asn1PD_VertOffset_B07 (pctxt, &pvalue->elevationOffset);

            pctxt->level--;
         }
         break;

         case 12:
         /* decode crumbData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.crumbDataPresent = 1;

            stat = asn1PD_TrailerHistoryPointList (pctxt, &pvalue->crumbData);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_TrailerUnitDescriptionList (OSCTXT* pctxt, TrailerUnitDescriptionList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TrailerUnitDescription* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, TrailerUnitDescription);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_TrailerUnitDescription (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TrailerUnitDescription (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_TrailerData (OSCTXT* pctxt, TrailerData* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode notUsed */
   pctxt->level++;

   stat = asn1PD_SSPindex (pctxt, (SSPindex*)&pvalue->notUsed);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode connection */
   pctxt->level++;

   stat = asn1PD_PivotPointDescription (pctxt, &pvalue->connection);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode units */
   pctxt->level++;

   stat = asn1PD_TrailerUnitDescriptionList (pctxt, &pvalue->units);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_SpecialVehicleExtensions (OSCTXT* pctxt, SpecialVehicleExtensions* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 3; i_++) {
      switch (i_) {
         case 0:
         /* decode vehicleAlerts */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vehicleAlertsPresent = 1;

            pvalue->vehicleAlerts = rtxMemAllocType (pctxt, EmergencyDetails);

            if (pvalue->vehicleAlerts == NULL)
               return RTERR_NOMEM;

            asn1Init_EmergencyDetails ((EmergencyDetails*)pvalue->vehicleAlerts);

            stat = asn1PD_EmergencyDetails (pctxt, (EmergencyDetails*)pvalue->vehicleAlerts);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode description */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.descriptionPresent = 1;

            stat = asn1PD_EventDescription (pctxt, &pvalue->description);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode deprecated */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.deprecatedPresent = 1;

            stat = asn1PD_TrailerData (pctxt, &pvalue->deprecated);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_SpeedProfileMeasurementList (OSCTXT* pctxt, SpeedProfileMeasurementList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 5);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 20) {
      return RTERR_CONSVIO;
   }

   /* decode elements */

   pvalue->elem = rtxMemAllocArray (pctxt, pvalue->n, SpeedProfileMeasurement);
   if (0 == pvalue->elem) return rtxErrGetStatus(pctxt);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      pctxt->level++;

      stat = asn1PD_SpeedProfileMeasurement (pctxt, (SpeedProfileMeasurement*)&pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_SpeedProfile (OSCTXT* pctxt, SpeedProfile* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode speedReports */
   pctxt->level++;

   stat = asn1PD_SpeedProfileMeasurementList (pctxt, &pvalue->speedReports);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_VehicleData (OSCTXT* pctxt, VehicleData* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[8];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 8; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 8; i_++) {
      switch (i_) {
         case 0:
         /* decode height */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.heightPresent = 1;

            stat = asn1PD_VehicleHeight (pctxt, (VehicleHeight*)&pvalue->height);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode trailerPresent */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.trailerPresentPresent = 1;

            rtxDecBit(pctxt, &pvalue->trailerPresent);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode bumpers */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.bumpersPresent = 1;

            pvalue->bumpers = rtxMemAllocTypeZ (pctxt, BumperHeights);

            if (pvalue->bumpers == NULL)
               return RTERR_NOMEM;

            stat = asn1PD_BumperHeights (pctxt, (BumperHeights*)pvalue->bumpers);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode mass */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.massPresent = 1;

            stat = asn1PD_VehicleMass (pctxt, (VehicleMass*)&pvalue->mass);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode pivotPoint */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.pivotPointPresent = 1;

            stat = asn1PD_PivotPointDescription (pctxt, &pvalue->pivotPoint);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode axles */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.axlesPresent = 1;

            pvalue->axles = rtxMemAllocType (pctxt, Axles);

            if (pvalue->axles == NULL)
               return RTERR_NOMEM;

            asn1Init_Axles ((Axles*)pvalue->axles);

            stat = asn1PD_Axles (pctxt, (Axles*)pvalue->axles);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode rollAngle */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.rollAnglePresent = 1;

            /* range_value = 181, range_bitcnt = 8 */
            stat = pd_ConsInt8(pctxt, &pvalue->rollAngle, -90, 90);
            if (stat != 0) return stat;

            pctxt->level--;
         }
         break;

         case 7:
         /* decode deprecated */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.deprecatedPresent = 1;

            stat = asn1PD_TrailerWeight (pctxt, (TrailerWeight*)&pvalue->deprecated);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_WeatherReport (OSCTXT* pctxt, WeatherReport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode isRaining */
         pctxt->level++;

         stat = asn1PD_EssPrecipYesNo (pctxt, &pvalue->isRaining);

         pctxt->level--;
         break;

         case 1:
         /* decode rainRate */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.rainRatePresent = 1;

            stat = asn1PD_EssPrecipRate (pctxt, &pvalue->rainRate);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode precipSituation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.precipSituationPresent = 1;

            stat = asn1PD_EssPrecipSituation (pctxt, &pvalue->precipSituation);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode solarRadiation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.solarRadiationPresent = 1;

            stat = asn1PD_EssSolarRadiation (pctxt, &pvalue->solarRadiation);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode friction */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.frictionPresent = 1;

            stat = asn1PD_EssMobileFriction (pctxt, &pvalue->friction);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode roadFriction */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.roadFrictionPresent = 1;

            stat = asn1PD_CoefficientOfFriction (pctxt, (CoefficientOfFriction*)&pvalue->roadFriction);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_WeatherProbe (OSCTXT* pctxt, WeatherProbe* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 3; i_++) {
      switch (i_) {
         case 0:
         /* decode airTemp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.airTempPresent = 1;

            stat = asn1PD_AmbientAirTemperature (pctxt, (AmbientAirTemperature*)&pvalue->airTemp);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode airPressure */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.airPressurePresent = 1;

            stat = asn1PD_AmbientAirPressure (pctxt, (AmbientAirPressure*)&pvalue->airPressure);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode rainRates */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.rainRatesPresent = 1;

            pvalue->rainRates = rtxMemAllocType (pctxt, WiperSet);

            if (pvalue->rainRates == NULL)
               return RTERR_NOMEM;

            asn1Init_WiperSet ((WiperSet*)pvalue->rainRates);

            stat = asn1PD_WiperSet (pctxt, (WiperSet*)pvalue->rainRates);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_SupplementalVehicleExtensions_regional (OSCTXT* pctxt, SupplementalVehicleExtensions_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_SupplementalVehicleExtensions (OSCTXT* pctxt, SupplementalVehicleExtensions* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[10];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 10; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 10; i_++) {
      switch (i_) {
         case 0:
         /* decode classification */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.classificationPresent = 1;

            stat = asn1PD_BasicVehicleClass (pctxt, (BasicVehicleClass*)&pvalue->classification);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode classDetails */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.classDetailsPresent = 1;

            pvalue->classDetails = rtxMemAllocType (pctxt, 
               VehicleClassification);

            if (pvalue->classDetails == NULL)
               return RTERR_NOMEM;

            asn1Init_VehicleClassification ((VehicleClassification*)pvalue->classDetails);

            stat = asn1PD_VehicleClassification (pctxt, (VehicleClassification*)pvalue->classDetails);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode vehicleData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vehicleDataPresent = 1;

            stat = asn1PD_VehicleData (pctxt, &pvalue->vehicleData);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode deprecated1 */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.deprecated1Present = 1;

            stat = asn1PD_WeatherReport (pctxt, &pvalue->deprecated1);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode deprecated2 */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.deprecated2Present = 1;

            stat = asn1PD_WeatherProbe (pctxt, &pvalue->deprecated2);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode deprecated3 */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.deprecated3Present = 1;

            stat = asn1PD_ObstacleDetection (pctxt, &pvalue->deprecated3);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode status */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.statusPresent = 1;

            stat = asn1PD_DisabledVehicle (pctxt, &pvalue->status);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode deprecated4 */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.deprecated4Present = 1;

            stat = asn1PD_SpeedProfile (pctxt, &pvalue->deprecated4);

            pctxt->level--;
         }
         break;

         case 8:
         /* decode deprecated5 */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.deprecated5Present = 1;

            stat = asn1PD_RTCMPackage (pctxt, &pvalue->deprecated5);

            pctxt->level--;
         }
         break;

         case 9:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_SupplementalVehicleExtensions_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            if (i_ < 2) {  /* known element */
               OSUINT32 openTypeLen;
               size_t bitStartOffset, bitLength;
               size_t bitEndOffset, bitsConsumed;

               stat = pd_UnconsLength (pctxt, &openTypeLen);
               if (stat < 0) {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return stat;
               }
               else if (stat == RT_OK_FRAG) {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return RTERR_NOTSUPP;
               }
               bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
               bitLength = openTypeLen * 8;

               if (openTypeLen > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.fhwaVehicleClassPresent = 1;
                        pctxt->level++;

                        stat = asn1PD_RptVehicleClass (pctxt, (RptVehicleClass*)&pvalue->fhwaVehicleClass);

                        if (stat != 0) break;

                        pctxt->level--;

                        break;

                     case 1:
                        pvalue->m.trailersPresent = 1;
                        pctxt->level++;

                        stat = asn1PD_TrailersJ2945Slash1B (pctxt, (TrailersJ2945Slash1B*)&pvalue->trailers);

                        if (stat != 0) break;

                        pctxt->level--;

                        break;

                  }
               }

               if (0 == stat) {
                  bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
                  bitsConsumed = bitEndOffset - bitStartOffset;
                  if (bitsConsumed < bitLength) {
                     stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
                  }
                  else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
               }
            }
            else {
               stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

               if (0 == stat) {
                  pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
                  if (0 != pOpenType) {
                     pOpenType->numocts = openType.numocts;
                     pOpenType->data = openType.data;
                     rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
                  }
                  else stat = RTERR_NOMEM;
               }
               else {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return stat;
               }
            }
         }
         else if (i_ >= 2) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

