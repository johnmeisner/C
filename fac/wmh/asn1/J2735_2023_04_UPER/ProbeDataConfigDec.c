/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "ProbeDataConfig.h"
#include "Common.h"
#include "TravelerInformation.h"
#include "MessageFrame.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PD_ConfigId (OSCTXT* pctxt, ConfigId* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 254) {
      return RTERR_CONSVIO;
   }

   *pvalue += 1;

   return stat;
}

EXTERN int asn1PD_CfgMsgDictionary (OSCTXT* pctxt, CfgMsgDictionary* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(2));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 2) {
         return RTERR_CONSVIO;
      }
      *pvalue += 1;
   }

   return (stat);
}

EXTERN int asn1PD_CfgVehicleClass (OSCTXT* pctxt, CfgVehicleClass* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode motorcycles */
   pctxt->level++;

   rtxDecBit(pctxt, &pvalue->motorcycles);

   pctxt->level--;

   /* decode passengerCars */
   pctxt->level++;

   rtxDecBit(pctxt, &pvalue->passengerCars);

   pctxt->level--;

   /* decode other2axle4tireSingleUnitVehs */
   pctxt->level++;

   rtxDecBit(pctxt, &pvalue->other2axle4tireSingleUnitVehs);

   pctxt->level--;

   /* decode buses */
   pctxt->level++;

   rtxDecBit(pctxt, &pvalue->buses);

   pctxt->level--;

   /* decode twoAxle6TireSingleUnitTrucks */
   pctxt->level++;

   rtxDecBit(pctxt, &pvalue->twoAxle6TireSingleUnitTrucks);

   pctxt->level--;

   /* decode threeAxleSingleUnitTrucks */
   pctxt->level++;

   rtxDecBit(pctxt, &pvalue->threeAxleSingleUnitTrucks);

   pctxt->level--;

   /* decode fourOrMoreAxleSingleUnitTrucks */
   pctxt->level++;

   rtxDecBit(pctxt, &pvalue->fourOrMoreAxleSingleUnitTrucks);

   pctxt->level--;

   /* decode fourOrFewerAxleSingleTrailerTrucks */
   pctxt->level++;

   rtxDecBit(pctxt, &pvalue->fourOrFewerAxleSingleTrailerTrucks);

   pctxt->level--;

   /* decode fiveAxleSingleTrailerTrucks */
   pctxt->level++;

   rtxDecBit(pctxt, &pvalue->fiveAxleSingleTrailerTrucks);

   pctxt->level--;

   /* decode sixOrMoreAxleSingleTrailerTrucks */
   pctxt->level++;

   rtxDecBit(pctxt, &pvalue->sixOrMoreAxleSingleTrailerTrucks);

   pctxt->level--;

   /* decode fiveOrFewerAxleMultiTrailerTrucks */
   pctxt->level++;

   rtxDecBit(pctxt, &pvalue->fiveOrFewerAxleMultiTrailerTrucks);

   pctxt->level--;

   /* decode sixAxleMultiTrailerTrucks */
   pctxt->level++;

   rtxDecBit(pctxt, &pvalue->sixAxleMultiTrailerTrucks);

   pctxt->level--;

   /* decode sevenOrMoreAxleMultiTrailerTrucks */
   pctxt->level++;

   rtxDecBit(pctxt, &pvalue->sevenOrMoreAxleMultiTrailerTrucks);

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_ConfigDescriptor (OSCTXT* pctxt, ConfigDescriptor* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode identifier */
         pctxt->level++;

         stat = asn1PD_ConfigId (pctxt, &pvalue->identifier);

         pctxt->level--;
         break;

         case 1:
         /* decode vehClass */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vehClassPresent = 1;

            stat = asn1PD_CfgVehicleClass (pctxt, &pvalue->vehClass);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode roadAuthorityID */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.roadAuthorityIDPresent = 1;

            pvalue->roadAuthorityID = rtxMemAllocType (pctxt, 
               RoadAuthorityID);

            if (pvalue->roadAuthorityID == NULL)
               return RTERR_NOMEM;

            asn1Init_RoadAuthorityID ((RoadAuthorityID*)pvalue->roadAuthorityID);

            stat = asn1PD_RoadAuthorityID (pctxt, (RoadAuthorityID*)pvalue->roadAuthorityID);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode percentOfResp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.percentOfRespPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->percentOfResp, 4);
            if (stat != 0) return stat;

            if (pvalue->percentOfResp > 9) {
               return RTERR_CONSVIO;
            }

            pvalue->percentOfResp += 1;

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgInterval (OSCTXT* pctxt, CfgInterval* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      {
         OSBOOL b_ = 0;
         DEC_BIT (pctxt, &b_);
         ui = b_;
      }
      pvalue->t = ui + 1;

      switch (ui) {
         /* timeInterval */
         case 0:
            pctxt->level++;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->u.timeInterval, 16);
            if (stat != 0) return stat;

            if (pvalue->u.timeInterval > 35999) {
               return RTERR_CONSVIO;
            }

            pvalue->u.timeInterval += 1;

            pctxt->level--;

            break;

         /* distanceInterval */
         case 1:
            pctxt->level++;

            stat = rtxDecBitsToByte(pctxt, &pvalue->u.distanceInterval, 7);
            if (stat != 0) return stat;

            if (pvalue->u.distanceInterval > 99) {
               return RTERR_CONSVIO;
            }

            pvalue->u.distanceInterval += 1;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_CfgTransitVehicleData (OSCTXT* pctxt, CfgTransitVehicleData* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 3; i_++) {
      switch (i_) {
         case 0:
         /* decode currNumPasngers */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.currNumPasngersPresent = 1;

            rtxDecBit(pctxt, &pvalue->currNumPasngers);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode avgNumPasngers */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgNumPasngersPresent = 1;

            rtxDecBit(pctxt, &pvalue->avgNumPasngers);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode trnstVehSchAdh */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.trnstVehSchAdhPresent = 1;

            rtxDecBit(pctxt, &pvalue->trnstVehSchAdh);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgIntervalEvents (OSCTXT* pctxt, CfgIntervalEvents* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode interval */
         pctxt->level++;

         stat = asn1PD_CfgInterval (pctxt, &pvalue->interval);

         pctxt->level--;
         break;

         case 1:
         /* decode wiperStatus */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.wiperStatusPresent = 1;

            rtxDecBit(pctxt, &pvalue->wiperStatus);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode vehCount */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vehCountPresent = 1;

            rtxDecBit(pctxt, &pvalue->vehCount);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode weatherData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.weatherDataPresent = 1;

            rtxDecBit(pctxt, &pvalue->weatherData);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode transitVehData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.transitVehDataPresent = 1;

            stat = asn1PD_CfgTransitVehicleData (pctxt, &pvalue->transitVehData);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode numOfOccupants */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.numOfOccupantsPresent = 1;

            rtxDecBit(pctxt, &pvalue->numOfOccupants);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgEvents (OSCTXT* pctxt, CfgEvents* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode absActivated */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.absActivatedPresent = 1;

            rtxDecBit(pctxt, &pvalue->absActivated);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode tractionCtlLoss */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.tractionCtlLossPresent = 1;

            rtxDecBit(pctxt, &pvalue->tractionCtlLoss);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode stabilityCtlActivated */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.stabilityCtlActivatedPresent = 1;

            rtxDecBit(pctxt, &pvalue->stabilityCtlActivated);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode hardBraking */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.hardBrakingPresent = 1;

            rtxDecBit(pctxt, &pvalue->hardBraking);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode swerveThreshold */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.swerveThresholdPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->swerveThreshold, 6);
            if (stat != 0) return stat;

            if (pvalue->swerveThreshold > 49) {
               return RTERR_CONSVIO;
            }

            pvalue->swerveThreshold += 1;

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgHysteresis (OSCTXT* pctxt, CfgHysteresis* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode hysSamples */
   pctxt->level++;

   stat = rtxDecBitsToByte(pctxt, &pvalue->hysSamples, 4);
   if (stat != 0) return stat;

   if (pvalue->hysSamples > 9) {
      return RTERR_CONSVIO;
   }

   pvalue->hysSamples += 1;

   pctxt->level--;

   /* decode hysRate */
   pctxt->level++;

   stat = rtxDecBitsToByte(pctxt, &pvalue->hysRate, 4);
   if (stat != 0) return stat;

   if (pvalue->hysRate > 9) {
      return RTERR_CONSVIO;
   }

   pvalue->hysRate += 1;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgKinematicEvents (OSCTXT* pctxt, CfgKinematicEvents* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode events */
   pctxt->level++;

   stat = asn1PD_CfgEvents (pctxt, &pvalue->events);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode hysteresis */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.hysteresisPresent = 1;

      stat = asn1PD_CfgHysteresis (pctxt, &pvalue->hysteresis);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgLowSpeedCriteria (OSCTXT* pctxt, CfgLowSpeedCriteria* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode lowSpeedThreshold */
   pctxt->level++;

   stat = rtxDecBitsToByte(pctxt, &pvalue->lowSpeedThreshold, 7);
   if (stat != 0) return stat;

   if (pvalue->lowSpeedThreshold > 95) {
      return RTERR_CONSVIO;
   }

   pvalue->lowSpeedThreshold += 5;

   pctxt->level--;

   /* decode lowSpeedTimeThresh */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.lowSpeedTimeThreshPresent = 1;

      stat = rtxDecBitsToByte(pctxt, &pvalue->lowSpeedTimeThresh, 5);
      if (stat != 0) return stat;

      if (pvalue->lowSpeedTimeThresh > 29) {
         return RTERR_CONSVIO;
      }

      pvalue->lowSpeedTimeThresh += 1;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgEmerAndTransitInfo (OSCTXT* pctxt, CfgEmerAndTransitInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      stat = rtxDecBits(pctxt, &ui, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* emerVehLightBar */
         case 0:
            pctxt->level++;

            rtxDecBit(pctxt, &pvalue->u.emerVehLightBar);

            pctxt->level--;

            break;

         /* reqTspEvp */
         case 1:
            pctxt->level++;

            rtxDecBit(pctxt, &pvalue->u.reqTspEvp);

            pctxt->level--;

            break;

         /* transitVehPassCnt */
         case 2:
            pctxt->level++;

            rtxDecBit(pctxt, &pvalue->u.transitVehPassCnt);

            pctxt->level--;

            break;

         /* transitVehDoor */
         case 3:
            pctxt->level++;

            rtxDecBit(pctxt, &pvalue->u.transitVehDoor);

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_CfgMsgRecepIndicators_messages (OSCTXT* pctxt, CfgMsgRecepIndicators_messages* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_Length64 (pctxt, &pvalue->n);
   if (stat != 0) return stat;

   /* decode elements */

   pvalue->elem = rtxMemAllocArray (pctxt, pvalue->n, DSRCmsgID);
   if (0 == pvalue->elem) return rtxErrGetStatus(pctxt);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      pctxt->level++;

      stat = asn1PD_DSRCmsgID (pctxt, (DSRCmsgID*)&pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_CfgMsgRecepIndicators (OSCTXT* pctxt, CfgMsgRecepIndicators* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode msgDictionary */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.msgDictionaryPresent = 1;

      stat = asn1PD_CfgMsgDictionary (pctxt, &pvalue->msgDictionary);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode messages */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.messagesPresent = 1;

      stat = asn1PD_CfgMsgRecepIndicators_messages (pctxt, &pvalue->messages);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgVehicleEvents (OSCTXT* pctxt, CfgVehicleEvents* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[12];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 12; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 12; i_++) {
      switch (i_) {
         case 0:
         /* decode headLights */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.headLightsPresent = 1;

            rtxDecBit(pctxt, &pvalue->headLights);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode fogLights */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.fogLightsPresent = 1;

            rtxDecBit(pctxt, &pvalue->fogLights);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode hazardLights */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.hazardLightsPresent = 1;

            rtxDecBit(pctxt, &pvalue->hazardLights);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode kinematicEvents */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.kinematicEventsPresent = 1;

            stat = asn1PD_CfgKinematicEvents (pctxt, &pvalue->kinematicEvents);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode wiperStatusChange */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.wiperStatusChangePresent = 1;

            rtxDecBit(pctxt, &pvalue->wiperStatusChange);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode lowSpeed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.lowSpeedPresent = 1;

            stat = asn1PD_CfgLowSpeedCriteria (pctxt, &pvalue->lowSpeed);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode resumedSpeed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.resumedSpeedPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->resumedSpeed, 7);
            if (stat != 0) return stat;

            if (pvalue->resumedSpeed > 99) {
               return RTERR_CONSVIO;
            }

            pvalue->resumedSpeed += 1;

            pctxt->level--;
         }
         break;

         case 7:
         /* decode vehEntrsExitsRegion */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vehEntrsExitsRegionPresent = 1;

            rtxDecBit(pctxt, &pvalue->vehEntrsExitsRegion);

            pctxt->level--;
         }
         break;

         case 8:
         /* decode emerVehDetect */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.emerVehDetectPresent = 1;

            rtxDecBit(pctxt, &pvalue->emerVehDetect);

            pctxt->level--;
         }
         break;

         case 9:
         /* decode emerAndTransInfo */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.emerAndTransInfoPresent = 1;

            stat = asn1PD_CfgEmerAndTransitInfo (pctxt, &pvalue->emerAndTransInfo);

            pctxt->level--;
         }
         break;

         case 10:
         /* decode v2xMsgRecption */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.v2xMsgRecptionPresent = 1;

            stat = asn1PD_CfgMsgRecepIndicators (pctxt, &pvalue->v2xMsgRecption);

            pctxt->level--;
         }
         break;

         case 11:
         /* decode driverAlertsAndWarnings */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.driverAlertsAndWarningsPresent = 1;

            rtxDecBit(pctxt, &pvalue->driverAlertsAndWarnings);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgTrafficSigEncounters_intersections (OSCTXT* pctxt, CfgTrafficSigEncounters_intersections* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 7);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 100) {
      return RTERR_CONSVIO;
   }

   /* decode elements */

   pvalue->elem = rtxMemAllocArray (pctxt, pvalue->n, IntersectionID);
   if (0 == pvalue->elem) return rtxErrGetStatus(pctxt);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      pctxt->level++;

      stat = asn1PD_IntersectionID (pctxt, (IntersectionID*)&pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_CfgTrafficSigEncounters (OSCTXT* pctxt, CfgTrafficSigEncounters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[8];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 8; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 8; i_++) {
      switch (i_) {
         case 0:
         /* decode intersections */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.intersectionsPresent = 1;

            stat = asn1PD_CfgTrafficSigEncounters_intersections (pctxt, &pvalue->intersections);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode trfcsigApproachDelay */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.trfcsigApproachDelayPresent = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->trfcsigApproachDelay, pctxt->buffer.aligned ? 16 : 12);
            if (stat != 0) return stat;

            if (pvalue->trfcsigApproachDelay > 3599) {
               return RTERR_CONSVIO;
            }

            pvalue->trfcsigApproachDelay += 1;

            pctxt->level--;
         }
         break;

         case 2:
         /* decode trfsigApproachSpeed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.trfsigApproachSpeedPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->trfsigApproachSpeed, 8);
            if (stat != 0) return stat;

            if (pvalue->trfsigApproachSpeed > 199) {
               return RTERR_CONSVIO;
            }

            pvalue->trfsigApproachSpeed += 1;

            pctxt->level--;
         }
         break;

         case 3:
         /* decode trfsigArrivalGreen */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.trfsigArrivalGreenPresent = 1;

            rtxDecBit(pctxt, &pvalue->trfsigArrivalGreen);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode trfsigArrivalRed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.trfsigArrivalRedPresent = 1;

            rtxDecBit(pctxt, &pvalue->trfsigArrivalRed);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode trfsigPedDelay */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.trfsigPedDelayPresent = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->trfsigPedDelay, pctxt->buffer.aligned ? 16 : 9);
            if (stat != 0) return stat;

            if (pvalue->trfsigPedDelay > 299) {
               return RTERR_CONSVIO;
            }

            pvalue->trfsigPedDelay += 1;

            pctxt->level--;
         }
         break;

         case 6:
         /* decode trfsigSpatMismatch */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.trfsigSpatMismatchPresent = 1;

            rtxDecBit(pctxt, &pvalue->trfsigSpatMismatch);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode trfsigSpatTimingError */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.trfsigSpatTimingErrorPresent = 1;

            rtxDecBit(pctxt, &pvalue->trfsigSpatTimingError);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgRoadSignTypes (OSCTXT* pctxt, CfgRoadSignTypes* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[14];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 14; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 14; i_++) {
      switch (i_) {
         case 0:
         /* decode whiteOnGreen */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.whiteOnGreenPresent = 1;

            rtxDecBit(pctxt, &pvalue->whiteOnGreen);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode blackOnYellow */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.blackOnYellowPresent = 1;

            rtxDecBit(pctxt, &pvalue->blackOnYellow);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode blackOnOrange */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.blackOnOrangePresent = 1;

            rtxDecBit(pctxt, &pvalue->blackOnOrange);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode whiteOnRed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.whiteOnRedPresent = 1;

            rtxDecBit(pctxt, &pvalue->whiteOnRed);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode blackOnWhite */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.blackOnWhitePresent = 1;

            rtxDecBit(pctxt, &pvalue->blackOnWhite);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode octagon */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.octagonPresent = 1;

            rtxDecBit(pctxt, &pvalue->octagon);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode eqlatTriangle */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.eqlatTrianglePresent = 1;

            rtxDecBit(pctxt, &pvalue->eqlatTriangle);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode circle */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.circlePresent = 1;

            rtxDecBit(pctxt, &pvalue->circle);

            pctxt->level--;
         }
         break;

         case 8:
         /* decode pennant */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.pennantPresent = 1;

            rtxDecBit(pctxt, &pvalue->pennant);

            pctxt->level--;
         }
         break;

         case 9:
         /* decode pentagon */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.pentagonPresent = 1;

            rtxDecBit(pctxt, &pvalue->pentagon);

            pctxt->level--;
         }
         break;

         case 10:
         /* decode crossbuck */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.crossbuckPresent = 1;

            rtxDecBit(pctxt, &pvalue->crossbuck);

            pctxt->level--;
         }
         break;

         case 11:
         /* decode diamond */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.diamondPresent = 1;

            rtxDecBit(pctxt, &pvalue->diamond);

            pctxt->level--;
         }
         break;

         case 12:
         /* decode trapezoid */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.trapezoidPresent = 1;

            rtxDecBit(pctxt, &pvalue->trapezoid);

            pctxt->level--;
         }
         break;

         case 13:
         /* decode other */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.otherPresent = 1;

            rtxDecBit(pctxt, &pvalue->other);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgRoadSignInfo (OSCTXT* pctxt, CfgRoadSignInfo* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode roadsignDetection */
   pctxt->level++;

   stat = asn1PD_CfgRoadSignTypes (pctxt, &pvalue->roadsignDetection);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode lowRoadsignReflect1 */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.lowRoadsignReflect1Present = 1;

      stat = rtxDecBitsToByte(pctxt, &pvalue->lowRoadsignReflect1, 8);
      if (stat != 0) return stat;

      if (pvalue->lowRoadsignReflect1 > 249) {
         return RTERR_CONSVIO;
      }

      pvalue->lowRoadsignReflect1 += 1;

      pctxt->level--;
   }

   /* decode lowRoadsignReflect2 */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.lowRoadsignReflect2Present = 1;

      stat = rtxDecBitsToByte(pctxt, &pvalue->lowRoadsignReflect2, 8);
      if (stat != 0) return stat;

      if (pvalue->lowRoadsignReflect2 > 249) {
         return RTERR_CONSVIO;
      }

      pvalue->lowRoadsignReflect2 += 1;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgRoadwayEvents (OSCTXT* pctxt, CfgRoadwayEvents* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 14; i_++) {
      switch (i_) {
         case 0:
         /* decode obstacleDetected */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->obstacleDetected);

         pctxt->level--;
         break;

         case 1:
         /* decode adverseRoadSurface */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->adverseRoadSurface);

         pctxt->level--;
         break;

         case 2:
         /* decode trafficSigEncounters */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.trafficSigEncountersPresent = 1;

            stat = asn1PD_CfgTrafficSigEncounters (pctxt, &pvalue->trafficSigEncounters);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode trfsigLightOut */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->trfsigLightOut);

         pctxt->level--;
         break;

         case 4:
         /* decode trfsigRoadGeoMismatch */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->trfsigRoadGeoMismatch);

         pctxt->level--;
         break;

         case 5:
         /* decode roadSignInfo */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.roadSignInfoPresent = 1;

            stat = asn1PD_CfgRoadSignInfo (pctxt, &pvalue->roadSignInfo);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode lowLaneMarkReflect */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.lowLaneMarkReflectPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->lowLaneMarkReflect, 7);
            if (stat != 0) return stat;

            if (pvalue->lowLaneMarkReflect > 99) {
               return RTERR_CONSVIO;
            }

            pvalue->lowLaneMarkReflect += 1;

            pctxt->level--;
         }
         break;

         case 7:
         /* decode roadsignIncnstncy */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->roadsignIncnstncy);

         pctxt->level--;
         break;

         case 8:
         /* decode laneGeoIncnstncy */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->laneGeoIncnstncy);

         pctxt->level--;
         break;

         case 9:
         /* decode incidentDetect */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->incidentDetect);

         pctxt->level--;
         break;

         case 10:
         /* decode workZoneCharDetect */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->workZoneCharDetect);

         pctxt->level--;
         break;

         case 11:
         /* decode inclWeatherDetect */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->inclWeatherDetect);

         pctxt->level--;
         break;

         case 12:
         /* decode railrdCrossActivated */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->railrdCrossActivated);

         pctxt->level--;
         break;

         case 13:
         /* decode drawBridgeActivated */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->drawBridgeActivated);

         pctxt->level--;
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgCommSysPerfEvents (OSCTXT* pctxt, CfgCommSysPerfEvents* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[10];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 10; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 10; i_++) {
      switch (i_) {
         case 0:
         /* decode j2945_1ChanBusyThresh */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.j2945_1ChanBusyThreshPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->j2945_1ChanBusyThresh, 7);
            if (stat != 0) return stat;

            if (pvalue->j2945_1ChanBusyThresh > 99) {
               return RTERR_CONSVIO;
            }

            pvalue->j2945_1ChanBusyThresh += 1;

            pctxt->level--;
         }
         break;

         case 1:
         /* decode rfDataRsuInfo */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.rfDataRsuInfoPresent = 1;

            rtxDecBit(pctxt, &pvalue->rfDataRsuInfo);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode numRsusObservedThresh */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.numRsusObservedThreshPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->numRsusObservedThresh, 8);
            if (stat != 0) return stat;

            if (pvalue->numRsusObservedThresh > 253) {
               return RTERR_CONSVIO;
            }

            pvalue->numRsusObservedThresh += 1;

            pctxt->level--;
         }
         break;

         case 3:
         /* decode rfV2xJamDetectThresh */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.rfV2xJamDetectThreshPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->rfV2xJamDetectThresh, 8);
            if (stat != 0) return stat;

            if (pvalue->rfV2xJamDetectThresh > 139) {
               return RTERR_CONSVIO;
            }

            pvalue->rfV2xJamDetectThresh += 1;

            pctxt->level--;
         }
         break;

         case 4:
         /* decode j2945_1VehDensThresh */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.j2945_1VehDensThreshPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->j2945_1VehDensThresh, 8);
            if (stat != 0) return stat;

            if (pvalue->j2945_1VehDensThresh > 254) {
               return RTERR_CONSVIO;
            }

            pvalue->j2945_1VehDensThresh += 1;

            pctxt->level--;
         }
         break;

         case 5:
         /* decode j2945_1CqiBelowThresh */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.j2945_1CqiBelowThreshPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->j2945_1CqiBelowThresh, 7);
            if (stat != 0) return stat;

            if (pvalue->j2945_1CqiBelowThresh > 99) {
               return RTERR_CONSVIO;
            }

            pvalue->j2945_1CqiBelowThresh += 1;

            pctxt->level--;
         }
         break;

         case 6:
         /* decode j2945_1TrackErrorThresh */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.j2945_1TrackErrorThreshPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->j2945_1TrackErrorThresh, 7);
            if (stat != 0) return stat;

            if (pvalue->j2945_1TrackErrorThresh > 99) {
               return RTERR_CONSVIO;
            }

            pvalue->j2945_1TrackErrorThresh += 1;

            pctxt->level--;
         }
         break;

         case 7:
         /* decode gnssHdopExceedsThresh */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.gnssHdopExceedsThreshPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->gnssHdopExceedsThresh, 5);
            if (stat != 0) return stat;

            if (pvalue->gnssHdopExceedsThresh > 19) {
               return RTERR_CONSVIO;
            }

            pvalue->gnssHdopExceedsThresh += 1;

            pctxt->level--;
         }
         break;

         case 8:
         /* decode gnssSatsBelowThresh */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.gnssSatsBelowThreshPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->gnssSatsBelowThresh, 5);
            if (stat != 0) return stat;

            if (pvalue->gnssSatsBelowThresh > 19) {
               return RTERR_CONSVIO;
            }

            pvalue->gnssSatsBelowThresh += 1;

            pctxt->level--;
         }
         break;

         case 9:
         /* decode gnssJammingDetect */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.gnssJammingDetectPresent = 1;

            rtxDecBit(pctxt, &pvalue->gnssJammingDetect);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgInstantaneousEventTriggers (OSCTXT* pctxt, CfgInstantaneousEventTriggers* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      stat = rtxDecBits(pctxt, &ui, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* intervalEvents */
         case 0:
            pctxt->level++;

            pvalue->u.intervalEvents = rtxMemAllocType (pctxt, 
               CfgIntervalEvents);

            if (pvalue->u.intervalEvents == NULL)
               return RTERR_NOMEM;

            asn1Init_CfgIntervalEvents (pvalue->u.intervalEvents);

            stat = asn1PD_CfgIntervalEvents (pctxt, pvalue->u.intervalEvents);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* vehicleEvents */
         case 1:
            pctxt->level++;

            pvalue->u.vehicleEvents = rtxMemAllocType (pctxt, 
               CfgVehicleEvents);

            if (pvalue->u.vehicleEvents == NULL)
               return RTERR_NOMEM;

            asn1Init_CfgVehicleEvents (pvalue->u.vehicleEvents);

            stat = asn1PD_CfgVehicleEvents (pctxt, pvalue->u.vehicleEvents);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* roadwayEvents */
         case 2:
            pctxt->level++;

            pvalue->u.roadwayEvents = rtxMemAllocType (pctxt, 
               CfgRoadwayEvents);

            if (pvalue->u.roadwayEvents == NULL)
               return RTERR_NOMEM;

            asn1Init_CfgRoadwayEvents (pvalue->u.roadwayEvents);

            stat = asn1PD_CfgRoadwayEvents (pctxt, pvalue->u.roadwayEvents);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* commSysPerfEvents */
         case 3:
            pctxt->level++;

            pvalue->u.commSysPerfEvents = rtxMemAllocType (pctxt, 
               CfgCommSysPerfEvents);

            if (pvalue->u.commSysPerfEvents == NULL)
               return RTERR_NOMEM;

            asn1Init_CfgCommSysPerfEvents (pvalue->u.commSysPerfEvents);

            stat = asn1PD_CfgCommSysPerfEvents (pctxt, pvalue->u.commSysPerfEvents);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_CfgAveragedTriggers (OSCTXT* pctxt, CfgAveragedTriggers* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode avgSpeed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgSpeedPresent = 1;

            rtxDecBit(pctxt, &pvalue->avgSpeed);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode avgStopDuration */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgStopDurationPresent = 1;

            rtxDecBit(pctxt, &pvalue->avgStopDuration);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode avgFuelConsumption */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgFuelConsumptionPresent = 1;

            rtxDecBit(pctxt, &pvalue->avgFuelConsumption);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode avgEmissions */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgEmissionsPresent = 1;

            rtxDecBit(pctxt, &pvalue->avgEmissions);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode avgNumOfOccupants */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgNumOfOccupantsPresent = 1;

            rtxDecBit(pctxt, &pvalue->avgNumOfOccupants);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgStoppedCriteria (OSCTXT* pctxt, CfgStoppedCriteria* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode stoppedSpeedThreshold */
   pctxt->level++;

   stat = rtxDecBitsToByte(pctxt, &pvalue->stoppedSpeedThreshold, 5);
   if (stat != 0) return stat;

   if (pvalue->stoppedSpeedThreshold > 29) {
      return RTERR_CONSVIO;
   }

   pvalue->stoppedSpeedThreshold += 1;

   pctxt->level--;

   /* decode amountOfTimeBelow */
   pctxt->level++;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, &pvalue->amountOfTimeBelow, pctxt->buffer.aligned ? 16 : 9);
   if (stat != 0) return stat;

   if (pvalue->amountOfTimeBelow > 299) {
      return RTERR_CONSVIO;
   }

   pvalue->amountOfTimeBelow += 1;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgSummaryTriggers (OSCTXT* pctxt, CfgSummaryTriggers* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[12];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 12; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 12; i_++) {
      switch (i_) {
         case 0:
         /* decode regTravelTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regTravelTimePresent = 1;

            rtxDecBit(pctxt, &pvalue->regTravelTime);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode regVehDistTraveled */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regVehDistTraveledPresent = 1;

            rtxDecBit(pctxt, &pvalue->regVehDistTraveled);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode regVehTimeTraveled */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regVehTimeTraveledPresent = 1;

            rtxDecBit(pctxt, &pvalue->regVehTimeTraveled);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode fuelConsumption */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.fuelConsumptionPresent = 1;

            rtxDecBit(pctxt, &pvalue->fuelConsumption);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode totalVehEmissions */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.totalVehEmissionsPresent = 1;

            rtxDecBit(pctxt, &pvalue->totalVehEmissions);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode numOfLowSpeedEvents */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.numOfLowSpeedEventsPresent = 1;

            stat = asn1PD_CfgLowSpeedCriteria (pctxt, &pvalue->numOfLowSpeedEvents);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode timeStopped */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.timeStoppedPresent = 1;

            stat = asn1PD_CfgStoppedCriteria (pctxt, &pvalue->timeStopped);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode numOfStopped */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.numOfStoppedPresent = 1;

            stat = asn1PD_CfgStoppedCriteria (pctxt, &pvalue->numOfStopped);

            pctxt->level--;
         }
         break;

         case 8:
         /* decode locOfStops */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.locOfStopsPresent = 1;

            rtxDecBit(pctxt, &pvalue->locOfStops);

            pctxt->level--;
         }
         break;

         case 9:
         /* decode regNumOfVehPassed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regNumOfVehPassedPresent = 1;

            rtxDecBit(pctxt, &pvalue->regNumOfVehPassed);

            pctxt->level--;
         }
         break;

         case 10:
         /* decode regNumOfSurpassedVeh */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regNumOfSurpassedVehPresent = 1;

            rtxDecBit(pctxt, &pvalue->regNumOfSurpassedVeh);

            pctxt->level--;
         }
         break;

         case 11:
         /* decode totalMsgsReceived */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.totalMsgsReceivedPresent = 1;

            stat = asn1PD_CfgMsgRecepIndicators (pctxt, &pvalue->totalMsgsReceived);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_CfgAveragedAndSummaryTriggers (OSCTXT* pctxt, CfgAveragedAndSummaryTriggers* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      {
         OSBOOL b_ = 0;
         DEC_BIT (pctxt, &b_);
         ui = b_;
      }
      pvalue->t = ui + 1;

      switch (ui) {
         /* averagedTriggers */
         case 0:
            pctxt->level++;

            pvalue->u.averagedTriggers = rtxMemAllocType (pctxt, 
               CfgAveragedTriggers);

            if (pvalue->u.averagedTriggers == NULL)
               return RTERR_NOMEM;

            asn1Init_CfgAveragedTriggers (pvalue->u.averagedTriggers);

            stat = asn1PD_CfgAveragedTriggers (pctxt, pvalue->u.averagedTriggers);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* summaryTriggers */
         case 1:
            pctxt->level++;

            pvalue->u.summaryTriggers = rtxMemAllocType (pctxt, 
               CfgSummaryTriggers);

            if (pvalue->u.summaryTriggers == NULL)
               return RTERR_NOMEM;

            asn1Init_CfgSummaryTriggers (pvalue->u.summaryTriggers);

            stat = asn1PD_CfgSummaryTriggers (pctxt, pvalue->u.summaryTriggers);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_ConfigTriggers (OSCTXT* pctxt, ConfigTriggers* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      {
         OSBOOL b_ = 0;
         DEC_BIT (pctxt, &b_);
         ui = b_;
      }
      pvalue->t = ui + 1;

      switch (ui) {
         /* instantaneousTriggers */
         case 0:
            pctxt->level++;

            pvalue->u.instantaneousTriggers = rtxMemAllocType (pctxt, 
               CfgInstantaneousEventTriggers);

            if (pvalue->u.instantaneousTriggers == NULL)
               return RTERR_NOMEM;

            asn1Init_CfgInstantaneousEventTriggers (pvalue->u.instantaneousTriggers);

            stat = asn1PD_CfgInstantaneousEventTriggers (pctxt, pvalue->u.instantaneousTriggers);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* avgAndSumTriggers */
         case 1:
            pctxt->level++;

            pvalue->u.avgAndSumTriggers = rtxMemAllocType (pctxt, 
               CfgAveragedAndSummaryTriggers);

            if (pvalue->u.avgAndSumTriggers == NULL)
               return RTERR_NOMEM;

            asn1Init_CfgAveragedAndSummaryTriggers (pvalue->u.avgAndSumTriggers);

            stat = asn1PD_CfgAveragedAndSummaryTriggers (pctxt, pvalue->u.avgAndSumTriggers);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_CfgEventRecurrence (OSCTXT* pctxt, CfgEventRecurrence* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 12; i_++) {
      switch (i_) {
         case 0:
         /* decode startTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.startTimePresent = 1;

            pvalue->startTime = rtxMemAllocType (pctxt, DTime);

            if (pvalue->startTime == NULL)
               return RTERR_NOMEM;

            asn1Init_DTime ((DTime*)pvalue->startTime);

            stat = asn1PD_DTime (pctxt, (DTime*)pvalue->startTime);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode endTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.endTimePresent = 1;

            pvalue->endTime = rtxMemAllocType (pctxt, DTime);

            if (pvalue->endTime == NULL)
               return RTERR_NOMEM;

            asn1Init_DTime ((DTime*)pvalue->endTime);

            stat = asn1PD_DTime (pctxt, (DTime*)pvalue->endTime);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode startDate */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.startDatePresent = 1;

            pvalue->startDate = rtxMemAllocTypeZ (pctxt, DDate);

            if (pvalue->startDate == NULL)
               return RTERR_NOMEM;

            stat = asn1PD_DDate (pctxt, (DDate*)pvalue->startDate);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode endDate */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.endDatePresent = 1;

            pvalue->endDate = rtxMemAllocTypeZ (pctxt, DDate);

            if (pvalue->endDate == NULL)
               return RTERR_NOMEM;

            stat = asn1PD_DDate (pctxt, (DDate*)pvalue->endDate);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode monday */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->monday);

         pctxt->level--;
         break;

         case 5:
         /* decode tuesday */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->tuesday);

         pctxt->level--;
         break;

         case 6:
         /* decode wednesday */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->wednesday);

         pctxt->level--;
         break;

         case 7:
         /* decode thursday */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->thursday);

         pctxt->level--;
         break;

         case 8:
         /* decode friday */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->friday);

         pctxt->level--;
         break;

         case 9:
         /* decode saturday */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->saturday);

         pctxt->level--;
         break;

         case 10:
         /* decode sunday */
         pctxt->level++;

         rtxDecBit(pctxt, &pvalue->sunday);

         pctxt->level--;
         break;

         case 11:
         /* decode exclusion */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.exclusionPresent = 1;

            rtxDecBit(pctxt, &pvalue->exclusion);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_ConfigTemporalBoundary (OSCTXT* pctxt, ConfigTemporalBoundary* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode beginTime */
   pctxt->level++;

   pvalue->beginTime = rtxMemAllocType (pctxt, DDateTime);

   if (pvalue->beginTime == NULL)
      return RTERR_NOMEM;

   asn1Init_DDateTime ((DDateTime*)pvalue->beginTime);

   stat = asn1PD_DDateTime (pctxt, (DDateTime*)pvalue->beginTime);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode endTime */
   pctxt->level++;

   pvalue->endTime = rtxMemAllocType (pctxt, DDateTime);

   if (pvalue->endTime == NULL)
      return RTERR_NOMEM;

   asn1Init_DDateTime ((DDateTime*)pvalue->endTime);

   stat = asn1PD_DDateTime (pctxt, (DDateTime*)pvalue->endTime);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode recurring */
   pctxt->level++;

   stat = asn1PD_CfgEventRecurrence (pctxt, &pvalue->recurring);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_ConfigBoundary (OSCTXT* pctxt, ConfigBoundary* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      {
         OSBOOL b_ = 0;
         DEC_BIT (pctxt, &b_);
         ui = b_;
      }
      pvalue->t = ui + 1;

      switch (ui) {
         /* temporalBoundary */
         case 0:
            pctxt->level++;

            pvalue->u.temporalBoundary = rtxMemAllocType (pctxt, 
               ConfigTemporalBoundary);

            if (pvalue->u.temporalBoundary == NULL)
               return RTERR_NOMEM;

            asn1Init_ConfigTemporalBoundary (pvalue->u.temporalBoundary);

            stat = asn1PD_ConfigTemporalBoundary (pctxt, pvalue->u.temporalBoundary);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* geoAndDistBoundary */
         case 1:
            pctxt->level++;

            pvalue->u.geoAndDistBoundary = rtxMemAllocType (pctxt, 
               ValidRegion);

            if (pvalue->u.geoAndDistBoundary == NULL)
               return RTERR_NOMEM;

            asn1Init_ValidRegion ((ValidRegion*)pvalue->u.geoAndDistBoundary);

            stat = asn1PD_ValidRegion (pctxt, (ValidRegion*)pvalue->u.geoAndDistBoundary);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_ProbeDataConfig (OSCTXT* pctxt, ProbeDataConfig* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode descriptor */
   pctxt->level++;

   stat = asn1PD_ConfigDescriptor (pctxt, &pvalue->descriptor);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode triggers */
   pctxt->level++;

   stat = asn1PD_ConfigTriggers (pctxt, &pvalue->triggers);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode maxAgeOfData */
   pctxt->level++;

   stat = rtxDecBitsToByte(pctxt, &pvalue->maxAgeOfData, 7);
   if (stat != 0) return stat;

   if (pvalue->maxAgeOfData > 89) {
      return RTERR_CONSVIO;
   }

   pvalue->maxAgeOfData += 1;

   pctxt->level--;

   /* decode boundary */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.boundaryPresent = 1;

      stat = asn1PD_ConfigBoundary (pctxt, &pvalue->boundary);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_ProbeDataConfigMessage (OSCTXT* pctxt, ProbeDataConfigMessage* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ProbeDataConfig* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, ProbeDataConfig);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_ProbeDataConfig (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ProbeDataConfig (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

