/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "ProbeDataConfig.h"
#include "Common.h"
#include "TravelerInformation.h"
#include "MessageFrame.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PE_ConfigId (OSCTXT* pctxt, ConfigId value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  1,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_CfgMsgDictionary (OSCTXT* pctxt, CfgMsgDictionary value)
{
   int stat = 0;

   if (value >= 4) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value - 1, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_CfgVehicleClass (OSCTXT* pctxt, CfgVehicleClass* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode motorcycles */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->motorcycles);
   if (stat != 0) return stat;

   /* encode passengerCars */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->passengerCars);
   if (stat != 0) return stat;

   /* encode other2axle4tireSingleUnitVehs */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->other2axle4tireSingleUnitVehs);
   if (stat != 0) return stat;

   /* encode buses */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->buses);
   if (stat != 0) return stat;

   /* encode twoAxle6TireSingleUnitTrucks */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->twoAxle6TireSingleUnitTrucks);
   if (stat != 0) return stat;

   /* encode threeAxleSingleUnitTrucks */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->threeAxleSingleUnitTrucks);
   if (stat != 0) return stat;

   /* encode fourOrMoreAxleSingleUnitTrucks */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->fourOrMoreAxleSingleUnitTrucks);
   if (stat != 0) return stat;

   /* encode fourOrFewerAxleSingleTrailerTrucks */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->fourOrFewerAxleSingleTrailerTrucks);
   if (stat != 0) return stat;

   /* encode fiveAxleSingleTrailerTrucks */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->fiveAxleSingleTrailerTrucks);
   if (stat != 0) return stat;

   /* encode sixOrMoreAxleSingleTrailerTrucks */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->sixOrMoreAxleSingleTrailerTrucks);
   if (stat != 0) return stat;

   /* encode fiveOrFewerAxleMultiTrailerTrucks */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->fiveOrFewerAxleMultiTrailerTrucks);
   if (stat != 0) return stat;

   /* encode sixAxleMultiTrailerTrucks */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->sixAxleMultiTrailerTrucks);
   if (stat != 0) return stat;

   /* encode sevenOrMoreAxleMultiTrailerTrucks */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->sevenOrMoreAxleMultiTrailerTrucks);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_ConfigDescriptor (OSCTXT* pctxt, ConfigDescriptor* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehClassPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.roadAuthorityIDPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.percentOfRespPresent);

   /* encode identifier */

   stat = asn1PE_ConfigId (pctxt, pvalue->identifier);
   if (stat != 0) return stat;

   /* encode vehClass */

   if (pvalue->m.vehClassPresent) {
      stat = asn1PE_CfgVehicleClass (pctxt, &pvalue->vehClass);
      if (stat != 0) return stat;
   }

   /* encode roadAuthorityID */

   if (pvalue->m.roadAuthorityIDPresent) {
      stat = asn1PE_RoadAuthorityID (pctxt, (RoadAuthorityID*)pvalue->roadAuthorityID);
      if (stat != 0) return stat;
   }

   /* encode percentOfResp */

   if (pvalue->m.percentOfRespPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->percentOfResp,  1,  10);
      if (stat != 0) return stat;

   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgInterval (OSCTXT* pctxt, CfgInterval* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 2);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* timeInterval */
         case 1:
            stat = pe_ConsUnsigned(pctxt, pvalue->u.timeInterval,  1,  36000);
            if (stat != 0) return stat;

            break;

         /* distanceInterval */
         case 2:
            stat = pe_ConsUnsigned(pctxt, pvalue->u.distanceInterval,  1,  100);
            if (stat != 0) return stat;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_CfgTransitVehicleData (OSCTXT* pctxt, CfgTransitVehicleData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.currNumPasngersPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgNumPasngersPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.trnstVehSchAdhPresent);

   /* encode currNumPasngers */

   if (pvalue->m.currNumPasngersPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->currNumPasngers);
      if (stat != 0) return stat;
   }

   /* encode avgNumPasngers */

   if (pvalue->m.avgNumPasngersPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->avgNumPasngers);
      if (stat != 0) return stat;
   }

   /* encode trnstVehSchAdh */

   if (pvalue->m.trnstVehSchAdhPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->trnstVehSchAdh);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgIntervalEvents (OSCTXT* pctxt, CfgIntervalEvents* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.wiperStatusPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehCountPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.weatherDataPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.transitVehDataPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.numOfOccupantsPresent);

   /* encode interval */

   stat = asn1PE_CfgInterval (pctxt, &pvalue->interval);
   if (stat != 0) return stat;

   /* encode wiperStatus */

   if (pvalue->m.wiperStatusPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->wiperStatus);
      if (stat != 0) return stat;
   }

   /* encode vehCount */

   if (pvalue->m.vehCountPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->vehCount);
      if (stat != 0) return stat;
   }

   /* encode weatherData */

   if (pvalue->m.weatherDataPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->weatherData);
      if (stat != 0) return stat;
   }

   /* encode transitVehData */

   if (pvalue->m.transitVehDataPresent) {
      stat = asn1PE_CfgTransitVehicleData (pctxt, &pvalue->transitVehData);
      if (stat != 0) return stat;
   }

   /* encode numOfOccupants */

   if (pvalue->m.numOfOccupantsPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->numOfOccupants);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgEvents (OSCTXT* pctxt, CfgEvents* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.absActivatedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.tractionCtlLossPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.stabilityCtlActivatedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.hardBrakingPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.swerveThresholdPresent);

   /* encode absActivated */

   if (pvalue->m.absActivatedPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->absActivated);
      if (stat != 0) return stat;
   }

   /* encode tractionCtlLoss */

   if (pvalue->m.tractionCtlLossPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->tractionCtlLoss);
      if (stat != 0) return stat;
   }

   /* encode stabilityCtlActivated */

   if (pvalue->m.stabilityCtlActivatedPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->stabilityCtlActivated);
      if (stat != 0) return stat;
   }

   /* encode hardBraking */

   if (pvalue->m.hardBrakingPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->hardBraking);
      if (stat != 0) return stat;
   }

   /* encode swerveThreshold */

   if (pvalue->m.swerveThresholdPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->swerveThreshold,  1,  50);
      if (stat != 0) return stat;

   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgHysteresis (OSCTXT* pctxt, CfgHysteresis* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode hysSamples */

   stat = pe_ConsUnsigned(pctxt, pvalue->hysSamples,  1,  10);
   if (stat != 0) return stat;

   /* encode hysRate */

   stat = pe_ConsUnsigned(pctxt, pvalue->hysRate,  1,  10);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgKinematicEvents (OSCTXT* pctxt, CfgKinematicEvents* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.hysteresisPresent);

   /* encode events */

   stat = asn1PE_CfgEvents (pctxt, &pvalue->events);
   if (stat != 0) return stat;

   /* encode hysteresis */

   if (pvalue->m.hysteresisPresent) {
      stat = asn1PE_CfgHysteresis (pctxt, &pvalue->hysteresis);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgLowSpeedCriteria (OSCTXT* pctxt, CfgLowSpeedCriteria* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.lowSpeedTimeThreshPresent);

   /* encode lowSpeedThreshold */

   stat = pe_ConsUnsigned(pctxt, pvalue->lowSpeedThreshold,  5,  100);
   if (stat != 0) return stat;

   /* encode lowSpeedTimeThresh */

   if (pvalue->m.lowSpeedTimeThreshPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->lowSpeedTimeThresh,  1,  30);
      if (stat != 0) return stat;

   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgEmerAndTransitInfo (OSCTXT* pctxt, CfgEmerAndTransitInfo* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 4);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 2);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* emerVehLightBar */
         case 1:
            stat = rtxEncBit (pctxt, (OSBOOL)pvalue->u.emerVehLightBar);
            if (stat != 0) return stat;
            break;

         /* reqTspEvp */
         case 2:
            stat = rtxEncBit (pctxt, (OSBOOL)pvalue->u.reqTspEvp);
            if (stat != 0) return stat;
            break;

         /* transitVehPassCnt */
         case 3:
            stat = rtxEncBit (pctxt, (OSBOOL)pvalue->u.transitVehPassCnt);
            if (stat != 0) return stat;
            break;

         /* transitVehDoor */
         case 4:
            stat = rtxEncBit (pctxt, (OSBOOL)pvalue->u.transitVehDoor);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 5);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_CfgMsgRecepIndicators_messages (OSCTXT* pctxt, CfgMsgRecepIndicators_messages* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), OSUINTCONST(0), OSUINT32_MAX);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_DSRCmsgID (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_CfgMsgRecepIndicators (OSCTXT* pctxt, CfgMsgRecepIndicators* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.msgDictionaryPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.messagesPresent);

   /* encode msgDictionary */

   if (pvalue->m.msgDictionaryPresent) {
      stat = asn1PE_CfgMsgDictionary (pctxt, pvalue->msgDictionary);
      if (stat != 0) return stat;
   }

   /* encode messages */

   if (pvalue->m.messagesPresent) {
      stat = asn1PE_CfgMsgRecepIndicators_messages (pctxt, &pvalue->messages);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgVehicleEvents (OSCTXT* pctxt, CfgVehicleEvents* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headLightsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.fogLightsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.hazardLightsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.kinematicEventsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.wiperStatusChangePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.lowSpeedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.resumedSpeedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehEntrsExitsRegionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.emerVehDetectPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.emerAndTransInfoPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.v2xMsgRecptionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.driverAlertsAndWarningsPresent);

   /* encode headLights */

   if (pvalue->m.headLightsPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->headLights);
      if (stat != 0) return stat;
   }

   /* encode fogLights */

   if (pvalue->m.fogLightsPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->fogLights);
      if (stat != 0) return stat;
   }

   /* encode hazardLights */

   if (pvalue->m.hazardLightsPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->hazardLights);
      if (stat != 0) return stat;
   }

   /* encode kinematicEvents */

   if (pvalue->m.kinematicEventsPresent) {
      stat = asn1PE_CfgKinematicEvents (pctxt, &pvalue->kinematicEvents);
      if (stat != 0) return stat;
   }

   /* encode wiperStatusChange */

   if (pvalue->m.wiperStatusChangePresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->wiperStatusChange);
      if (stat != 0) return stat;
   }

   /* encode lowSpeed */

   if (pvalue->m.lowSpeedPresent) {
      stat = asn1PE_CfgLowSpeedCriteria (pctxt, &pvalue->lowSpeed);
      if (stat != 0) return stat;
   }

   /* encode resumedSpeed */

   if (pvalue->m.resumedSpeedPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->resumedSpeed,  1,  100);
      if (stat != 0) return stat;

   }

   /* encode vehEntrsExitsRegion */

   if (pvalue->m.vehEntrsExitsRegionPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->vehEntrsExitsRegion);
      if (stat != 0) return stat;
   }

   /* encode emerVehDetect */

   if (pvalue->m.emerVehDetectPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->emerVehDetect);
      if (stat != 0) return stat;
   }

   /* encode emerAndTransInfo */

   if (pvalue->m.emerAndTransInfoPresent) {
      stat = asn1PE_CfgEmerAndTransitInfo (pctxt, &pvalue->emerAndTransInfo);
      if (stat != 0) return stat;
   }

   /* encode v2xMsgRecption */

   if (pvalue->m.v2xMsgRecptionPresent) {
      stat = asn1PE_CfgMsgRecepIndicators (pctxt, &pvalue->v2xMsgRecption);
      if (stat != 0) return stat;
   }

   /* encode driverAlertsAndWarnings */

   if (pvalue->m.driverAlertsAndWarningsPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->driverAlertsAndWarnings);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgTrafficSigEncounters_intersections (OSCTXT* pctxt, CfgTrafficSigEncounters_intersections* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(100), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_IntersectionID (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_CfgTrafficSigEncounters (OSCTXT* pctxt, CfgTrafficSigEncounters* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.intersectionsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.trfcsigApproachDelayPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.trfsigApproachSpeedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.trfsigArrivalGreenPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.trfsigArrivalRedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.trfsigPedDelayPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.trfsigSpatMismatchPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.trfsigSpatTimingErrorPresent);

   /* encode intersections */

   if (pvalue->m.intersectionsPresent) {
      stat = asn1PE_CfgTrafficSigEncounters_intersections (pctxt, &pvalue->intersections);
      if (stat != 0) return stat;
   }

   /* encode trfcsigApproachDelay */

   if (pvalue->m.trfcsigApproachDelayPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->trfcsigApproachDelay,  1,  3600);
      if (stat != 0) return stat;

   }

   /* encode trfsigApproachSpeed */

   if (pvalue->m.trfsigApproachSpeedPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->trfsigApproachSpeed,  1,  200);
      if (stat != 0) return stat;

   }

   /* encode trfsigArrivalGreen */

   if (pvalue->m.trfsigArrivalGreenPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->trfsigArrivalGreen);
      if (stat != 0) return stat;
   }

   /* encode trfsigArrivalRed */

   if (pvalue->m.trfsigArrivalRedPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->trfsigArrivalRed);
      if (stat != 0) return stat;
   }

   /* encode trfsigPedDelay */

   if (pvalue->m.trfsigPedDelayPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->trfsigPedDelay,  1,  300);
      if (stat != 0) return stat;

   }

   /* encode trfsigSpatMismatch */

   if (pvalue->m.trfsigSpatMismatchPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->trfsigSpatMismatch);
      if (stat != 0) return stat;
   }

   /* encode trfsigSpatTimingError */

   if (pvalue->m.trfsigSpatTimingErrorPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->trfsigSpatTimingError);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgRoadSignTypes (OSCTXT* pctxt, CfgRoadSignTypes* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.whiteOnGreenPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.blackOnYellowPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.blackOnOrangePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.whiteOnRedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.blackOnWhitePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.octagonPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.eqlatTrianglePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.circlePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pennantPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pentagonPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.crossbuckPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.diamondPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.trapezoidPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.otherPresent);

   /* encode whiteOnGreen */

   if (pvalue->m.whiteOnGreenPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->whiteOnGreen);
      if (stat != 0) return stat;
   }

   /* encode blackOnYellow */

   if (pvalue->m.blackOnYellowPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->blackOnYellow);
      if (stat != 0) return stat;
   }

   /* encode blackOnOrange */

   if (pvalue->m.blackOnOrangePresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->blackOnOrange);
      if (stat != 0) return stat;
   }

   /* encode whiteOnRed */

   if (pvalue->m.whiteOnRedPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->whiteOnRed);
      if (stat != 0) return stat;
   }

   /* encode blackOnWhite */

   if (pvalue->m.blackOnWhitePresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->blackOnWhite);
      if (stat != 0) return stat;
   }

   /* encode octagon */

   if (pvalue->m.octagonPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->octagon);
      if (stat != 0) return stat;
   }

   /* encode eqlatTriangle */

   if (pvalue->m.eqlatTrianglePresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->eqlatTriangle);
      if (stat != 0) return stat;
   }

   /* encode circle */

   if (pvalue->m.circlePresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->circle);
      if (stat != 0) return stat;
   }

   /* encode pennant */

   if (pvalue->m.pennantPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->pennant);
      if (stat != 0) return stat;
   }

   /* encode pentagon */

   if (pvalue->m.pentagonPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->pentagon);
      if (stat != 0) return stat;
   }

   /* encode crossbuck */

   if (pvalue->m.crossbuckPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->crossbuck);
      if (stat != 0) return stat;
   }

   /* encode diamond */

   if (pvalue->m.diamondPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->diamond);
      if (stat != 0) return stat;
   }

   /* encode trapezoid */

   if (pvalue->m.trapezoidPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->trapezoid);
      if (stat != 0) return stat;
   }

   /* encode other */

   if (pvalue->m.otherPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->other);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgRoadSignInfo (OSCTXT* pctxt, CfgRoadSignInfo* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.lowRoadsignReflect1Present);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.lowRoadsignReflect2Present);

   /* encode roadsignDetection */

   stat = asn1PE_CfgRoadSignTypes (pctxt, &pvalue->roadsignDetection);
   if (stat != 0) return stat;

   /* encode lowRoadsignReflect1 */

   if (pvalue->m.lowRoadsignReflect1Present) {
      stat = pe_ConsUnsigned(pctxt, pvalue->lowRoadsignReflect1,  1,  250);
      if (stat != 0) return stat;

   }

   /* encode lowRoadsignReflect2 */

   if (pvalue->m.lowRoadsignReflect2Present) {
      stat = pe_ConsUnsigned(pctxt, pvalue->lowRoadsignReflect2,  1,  250);
      if (stat != 0) return stat;

   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgRoadwayEvents (OSCTXT* pctxt, CfgRoadwayEvents* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.trafficSigEncountersPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.roadSignInfoPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.lowLaneMarkReflectPresent);

   /* encode obstacleDetected */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->obstacleDetected);
   if (stat != 0) return stat;

   /* encode adverseRoadSurface */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->adverseRoadSurface);
   if (stat != 0) return stat;

   /* encode trafficSigEncounters */

   if (pvalue->m.trafficSigEncountersPresent) {
      stat = asn1PE_CfgTrafficSigEncounters (pctxt, &pvalue->trafficSigEncounters);
      if (stat != 0) return stat;
   }

   /* encode trfsigLightOut */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->trfsigLightOut);
   if (stat != 0) return stat;

   /* encode trfsigRoadGeoMismatch */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->trfsigRoadGeoMismatch);
   if (stat != 0) return stat;

   /* encode roadSignInfo */

   if (pvalue->m.roadSignInfoPresent) {
      stat = asn1PE_CfgRoadSignInfo (pctxt, &pvalue->roadSignInfo);
      if (stat != 0) return stat;
   }

   /* encode lowLaneMarkReflect */

   if (pvalue->m.lowLaneMarkReflectPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->lowLaneMarkReflect,  1,  100);
      if (stat != 0) return stat;

   }

   /* encode roadsignIncnstncy */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->roadsignIncnstncy);
   if (stat != 0) return stat;

   /* encode laneGeoIncnstncy */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->laneGeoIncnstncy);
   if (stat != 0) return stat;

   /* encode incidentDetect */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->incidentDetect);
   if (stat != 0) return stat;

   /* encode workZoneCharDetect */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->workZoneCharDetect);
   if (stat != 0) return stat;

   /* encode inclWeatherDetect */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->inclWeatherDetect);
   if (stat != 0) return stat;

   /* encode railrdCrossActivated */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->railrdCrossActivated);
   if (stat != 0) return stat;

   /* encode drawBridgeActivated */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->drawBridgeActivated);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgCommSysPerfEvents (OSCTXT* pctxt, CfgCommSysPerfEvents* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.j2945_1ChanBusyThreshPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rfDataRsuInfoPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.numRsusObservedThreshPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rfV2xJamDetectThreshPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.j2945_1VehDensThreshPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.j2945_1CqiBelowThreshPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.j2945_1TrackErrorThreshPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.gnssHdopExceedsThreshPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.gnssSatsBelowThreshPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.gnssJammingDetectPresent);

   /* encode j2945_1ChanBusyThresh */

   if (pvalue->m.j2945_1ChanBusyThreshPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->j2945_1ChanBusyThresh,  1,  100);
      if (stat != 0) return stat;

   }

   /* encode rfDataRsuInfo */

   if (pvalue->m.rfDataRsuInfoPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->rfDataRsuInfo);
      if (stat != 0) return stat;
   }

   /* encode numRsusObservedThresh */

   if (pvalue->m.numRsusObservedThreshPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->numRsusObservedThresh,  1,  254);
      if (stat != 0) return stat;

   }

   /* encode rfV2xJamDetectThresh */

   if (pvalue->m.rfV2xJamDetectThreshPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->rfV2xJamDetectThresh,  1,  140);
      if (stat != 0) return stat;

   }

   /* encode j2945_1VehDensThresh */

   if (pvalue->m.j2945_1VehDensThreshPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->j2945_1VehDensThresh,  1,  255);
      if (stat != 0) return stat;

   }

   /* encode j2945_1CqiBelowThresh */

   if (pvalue->m.j2945_1CqiBelowThreshPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->j2945_1CqiBelowThresh,  1,  100);
      if (stat != 0) return stat;

   }

   /* encode j2945_1TrackErrorThresh */

   if (pvalue->m.j2945_1TrackErrorThreshPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->j2945_1TrackErrorThresh,  1,  100);
      if (stat != 0) return stat;

   }

   /* encode gnssHdopExceedsThresh */

   if (pvalue->m.gnssHdopExceedsThreshPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->gnssHdopExceedsThresh,  1,  20);
      if (stat != 0) return stat;

   }

   /* encode gnssSatsBelowThresh */

   if (pvalue->m.gnssSatsBelowThreshPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->gnssSatsBelowThresh,  1,  20);
      if (stat != 0) return stat;

   }

   /* encode gnssJammingDetect */

   if (pvalue->m.gnssJammingDetectPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->gnssJammingDetect);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgInstantaneousEventTriggers (OSCTXT* pctxt, CfgInstantaneousEventTriggers* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 4);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 2);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* intervalEvents */
         case 1:
            stat = asn1PE_CfgIntervalEvents (pctxt, pvalue->u.intervalEvents);
            if (stat != 0) return stat;
            break;

         /* vehicleEvents */
         case 2:
            stat = asn1PE_CfgVehicleEvents (pctxt, pvalue->u.vehicleEvents);
            if (stat != 0) return stat;
            break;

         /* roadwayEvents */
         case 3:
            stat = asn1PE_CfgRoadwayEvents (pctxt, pvalue->u.roadwayEvents);
            if (stat != 0) return stat;
            break;

         /* commSysPerfEvents */
         case 4:
            stat = asn1PE_CfgCommSysPerfEvents (pctxt, pvalue->u.commSysPerfEvents);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 5);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_CfgAveragedTriggers (OSCTXT* pctxt, CfgAveragedTriggers* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgSpeedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgStopDurationPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgFuelConsumptionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgEmissionsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.avgNumOfOccupantsPresent);

   /* encode avgSpeed */

   if (pvalue->m.avgSpeedPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->avgSpeed);
      if (stat != 0) return stat;
   }

   /* encode avgStopDuration */

   if (pvalue->m.avgStopDurationPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->avgStopDuration);
      if (stat != 0) return stat;
   }

   /* encode avgFuelConsumption */

   if (pvalue->m.avgFuelConsumptionPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->avgFuelConsumption);
      if (stat != 0) return stat;
   }

   /* encode avgEmissions */

   if (pvalue->m.avgEmissionsPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->avgEmissions);
      if (stat != 0) return stat;
   }

   /* encode avgNumOfOccupants */

   if (pvalue->m.avgNumOfOccupantsPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->avgNumOfOccupants);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgStoppedCriteria (OSCTXT* pctxt, CfgStoppedCriteria* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode stoppedSpeedThreshold */

   stat = pe_ConsUnsigned(pctxt, pvalue->stoppedSpeedThreshold,  1,  30);
   if (stat != 0) return stat;

   /* encode amountOfTimeBelow */

   stat = pe_ConsUnsigned(pctxt, pvalue->amountOfTimeBelow,  1,  300);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgSummaryTriggers (OSCTXT* pctxt, CfgSummaryTriggers* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regTravelTimePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regVehDistTraveledPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regVehTimeTraveledPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.fuelConsumptionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.totalVehEmissionsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.numOfLowSpeedEventsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStoppedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.numOfStoppedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.locOfStopsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regNumOfVehPassedPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regNumOfSurpassedVehPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.totalMsgsReceivedPresent);

   /* encode regTravelTime */

   if (pvalue->m.regTravelTimePresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->regTravelTime);
      if (stat != 0) return stat;
   }

   /* encode regVehDistTraveled */

   if (pvalue->m.regVehDistTraveledPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->regVehDistTraveled);
      if (stat != 0) return stat;
   }

   /* encode regVehTimeTraveled */

   if (pvalue->m.regVehTimeTraveledPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->regVehTimeTraveled);
      if (stat != 0) return stat;
   }

   /* encode fuelConsumption */

   if (pvalue->m.fuelConsumptionPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->fuelConsumption);
      if (stat != 0) return stat;
   }

   /* encode totalVehEmissions */

   if (pvalue->m.totalVehEmissionsPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->totalVehEmissions);
      if (stat != 0) return stat;
   }

   /* encode numOfLowSpeedEvents */

   if (pvalue->m.numOfLowSpeedEventsPresent) {
      stat = asn1PE_CfgLowSpeedCriteria (pctxt, &pvalue->numOfLowSpeedEvents);
      if (stat != 0) return stat;
   }

   /* encode timeStopped */

   if (pvalue->m.timeStoppedPresent) {
      stat = asn1PE_CfgStoppedCriteria (pctxt, &pvalue->timeStopped);
      if (stat != 0) return stat;
   }

   /* encode numOfStopped */

   if (pvalue->m.numOfStoppedPresent) {
      stat = asn1PE_CfgStoppedCriteria (pctxt, &pvalue->numOfStopped);
      if (stat != 0) return stat;
   }

   /* encode locOfStops */

   if (pvalue->m.locOfStopsPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->locOfStops);
      if (stat != 0) return stat;
   }

   /* encode regNumOfVehPassed */

   if (pvalue->m.regNumOfVehPassedPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->regNumOfVehPassed);
      if (stat != 0) return stat;
   }

   /* encode regNumOfSurpassedVeh */

   if (pvalue->m.regNumOfSurpassedVehPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->regNumOfSurpassedVeh);
      if (stat != 0) return stat;
   }

   /* encode totalMsgsReceived */

   if (pvalue->m.totalMsgsReceivedPresent) {
      stat = asn1PE_CfgMsgRecepIndicators (pctxt, &pvalue->totalMsgsReceived);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_CfgAveragedAndSummaryTriggers (OSCTXT* pctxt, CfgAveragedAndSummaryTriggers* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 2);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* averagedTriggers */
         case 1:
            stat = asn1PE_CfgAveragedTriggers (pctxt, pvalue->u.averagedTriggers);
            if (stat != 0) return stat;
            break;

         /* summaryTriggers */
         case 2:
            stat = asn1PE_CfgSummaryTriggers (pctxt, pvalue->u.summaryTriggers);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_ConfigTriggers (OSCTXT* pctxt, ConfigTriggers* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 2);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* instantaneousTriggers */
         case 1:
            stat = asn1PE_CfgInstantaneousEventTriggers (pctxt, pvalue->u.instantaneousTriggers);
            if (stat != 0) return stat;
            break;

         /* avgAndSumTriggers */
         case 2:
            stat = asn1PE_CfgAveragedAndSummaryTriggers (pctxt, pvalue->u.avgAndSumTriggers);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_CfgEventRecurrence (OSCTXT* pctxt, CfgEventRecurrence* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.startTimePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.endTimePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.startDatePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.endDatePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.exclusionPresent);

   /* encode startTime */

   if (pvalue->m.startTimePresent) {
      stat = asn1PE_DTime (pctxt, (DTime*)pvalue->startTime);
      if (stat != 0) return stat;
   }

   /* encode endTime */

   if (pvalue->m.endTimePresent) {
      stat = asn1PE_DTime (pctxt, (DTime*)pvalue->endTime);
      if (stat != 0) return stat;
   }

   /* encode startDate */

   if (pvalue->m.startDatePresent) {
      stat = asn1PE_DDate (pctxt, (DDate*)pvalue->startDate);
      if (stat != 0) return stat;
   }

   /* encode endDate */

   if (pvalue->m.endDatePresent) {
      stat = asn1PE_DDate (pctxt, (DDate*)pvalue->endDate);
      if (stat != 0) return stat;
   }

   /* encode monday */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->monday);
   if (stat != 0) return stat;

   /* encode tuesday */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->tuesday);
   if (stat != 0) return stat;

   /* encode wednesday */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->wednesday);
   if (stat != 0) return stat;

   /* encode thursday */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->thursday);
   if (stat != 0) return stat;

   /* encode friday */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->friday);
   if (stat != 0) return stat;

   /* encode saturday */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->saturday);
   if (stat != 0) return stat;

   /* encode sunday */

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->sunday);
   if (stat != 0) return stat;

   /* encode exclusion */

   if (pvalue->m.exclusionPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->exclusion);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_ConfigTemporalBoundary (OSCTXT* pctxt, ConfigTemporalBoundary* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode beginTime */

   stat = asn1PE_DDateTime (pctxt, (DDateTime*)pvalue->beginTime);
   if (stat != 0) return stat;

   /* encode endTime */

   stat = asn1PE_DDateTime (pctxt, (DDateTime*)pvalue->endTime);
   if (stat != 0) return stat;

   /* encode recurring */

   stat = asn1PE_CfgEventRecurrence (pctxt, &pvalue->recurring);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_ConfigBoundary (OSCTXT* pctxt, ConfigBoundary* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 2);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* temporalBoundary */
         case 1:
            stat = asn1PE_ConfigTemporalBoundary (pctxt, pvalue->u.temporalBoundary);
            if (stat != 0) return stat;
            break;

         /* geoAndDistBoundary */
         case 2:
            stat = asn1PE_ValidRegion (pctxt, (ValidRegion*)pvalue->u.geoAndDistBoundary);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_ProbeDataConfig (OSCTXT* pctxt, ProbeDataConfig* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.boundaryPresent);

   /* encode descriptor */

   stat = asn1PE_ConfigDescriptor (pctxt, &pvalue->descriptor);
   if (stat != 0) return stat;

   /* encode triggers */

   stat = asn1PE_ConfigTriggers (pctxt, &pvalue->triggers);
   if (stat != 0) return stat;

   /* encode maxAgeOfData */

   stat = pe_ConsUnsigned(pctxt, pvalue->maxAgeOfData,  1,  90);
   if (stat != 0) return stat;

   /* encode boundary */

   if (pvalue->m.boundaryPresent) {
      stat = asn1PE_ConfigBoundary (pctxt, &pvalue->boundary);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_ProbeDataConfigMessage (OSCTXT* pctxt, ProbeDataConfigMessage* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), OSUINTCONST(0), OSUINT32_MAX);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_ProbeDataConfig (pctxt, ((ProbeDataConfig*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

