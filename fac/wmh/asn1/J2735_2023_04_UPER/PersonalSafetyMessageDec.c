/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "PersonalSafetyMessage.h"
#include "REGION.h"
#include "Common.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PD_AnimalPropelledType (OSCTXT* pctxt, AnimalPropelledType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(3));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_AnimalType (OSCTXT* pctxt, AnimalType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(3));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_Attachment (OSCTXT* pctxt, Attachment* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(6));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 6) {
         return RTERR_CONSVIO;
      }
   }

   return (stat);
}

EXTERN int asn1PD_AttachmentRadius (OSCTXT* pctxt, AttachmentRadius* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 200) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_MotorizedPropelledType (OSCTXT* pctxt, MotorizedPropelledType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(5));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 5) {
         return RTERR_CONSVIO;
      }
   }

   return (stat);
}

EXTERN int asn1PD_NumberOfParticipantsInCluster (OSCTXT* pctxt, NumberOfParticipantsInCluster* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(3));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_HumanPropelledType (OSCTXT* pctxt, HumanPropelledType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(5));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 5) {
         return RTERR_CONSVIO;
      }
   }

   return (stat);
}

EXTERN int asn1PD_PersonalAssistive (OSCTXT* pctxt, PersonalAssistive* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 
      OSUINTCONST(0), OSUINT32_MAX);

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         PD_BYTE_ALIGN(pctxt);

      }

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return RTERR_NOMEM;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   return (stat);
}

EXTERN int asn1PD_PersonalClusterRadius (OSCTXT* pctxt, PersonalClusterRadius* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 7);
   if (stat != 0) return stat;

   if (*pvalue > 100) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_PersonalCrossingInProgress (OSCTXT* pctxt, PersonalCrossingInProgress* pvalue)
{
   int stat = 0;

   rtxDecBit(pctxt, pvalue);

   return (stat);
}

EXTERN int asn1PD_PersonalCrossingRequest (OSCTXT* pctxt, PersonalCrossingRequest* pvalue)
{
   int stat = 0;

   rtxDecBit(pctxt, pvalue);

   return (stat);
}

EXTERN int asn1PD_PersonalDeviceUsageState (OSCTXT* pctxt, PersonalDeviceUsageState* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(9), OSUINTCONST(9), 
      OSUINTCONST(0), OSUINT32_MAX);

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         PD_BYTE_ALIGN(pctxt);

      }

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return RTERR_NOMEM;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   return (stat);
}

EXTERN int asn1PD_PersonalDeviceUserType (OSCTXT* pctxt, PersonalDeviceUserType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(4));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 4) {
         return RTERR_CONSVIO;
      }
   }

   return (stat);
}

EXTERN int asn1PD_PublicSafetyAndRoadWorkerActivity (OSCTXT* pctxt, PublicSafetyAndRoadWorkerActivity* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 
      OSUINTCONST(0), OSUINT32_MAX);

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         PD_BYTE_ALIGN(pctxt);

      }

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return RTERR_NOMEM;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   return (stat);
}

EXTERN int asn1PD_PublicSafetyDirectingTrafficSubType (OSCTXT* pctxt, PublicSafetyDirectingTrafficSubType* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(7), OSUINTCONST(7), 
      OSUINTCONST(0), OSUINT32_MAX);

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         PD_BYTE_ALIGN(pctxt);

      }

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return RTERR_NOMEM;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   return (stat);
}

EXTERN int asn1PD_PublicSafetyEventResponderWorkerType (OSCTXT* pctxt, PublicSafetyEventResponderWorkerType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(7));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_UserSizeAndBehaviour (OSCTXT* pctxt, UserSizeAndBehaviour* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), 
      OSUINTCONST(0), OSUINT32_MAX);

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         PD_BYTE_ALIGN(pctxt);

      }

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return RTERR_NOMEM;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   return (stat);
}

EXTERN int asn1PD_PropelledInformation (OSCTXT* pctxt, PropelledInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      stat = rtxDecBits(pctxt, &ui, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* human */
         case 0:
            pctxt->level++;

            stat = asn1PD_HumanPropelledType (pctxt, &pvalue->u.human);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* animal */
         case 1:
            pctxt->level++;

            stat = asn1PD_AnimalPropelledType (pctxt, &pvalue->u.animal);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* motor */
         case 2:
            pctxt->level++;

            stat = asn1PD_MotorizedPropelledType (pctxt, &pvalue->u.motor);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_PersonalSafetyMessage_regional (OSCTXT* pctxt, PersonalSafetyMessage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_PersonalSafetyMessage (OSCTXT* pctxt, PersonalSafetyMessage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[18];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 18; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 26; i_++) {
      switch (i_) {
         case 0:
         /* decode basicType */
         pctxt->level++;

         stat = asn1PD_PersonalDeviceUserType (pctxt, &pvalue->basicType);

         pctxt->level--;
         break;

         case 1:
         /* decode secMark */
         pctxt->level++;

         stat = asn1PD_DSecond (pctxt, (DSecond*)&pvalue->secMark);

         pctxt->level--;
         break;

         case 2:
         /* decode msgCnt */
         pctxt->level++;

         stat = asn1PD_Common_MsgCount (pctxt, (Common_MsgCount*)&pvalue->msgCnt);

         pctxt->level--;
         break;

         case 3:
         /* decode id */
         pctxt->level++;

         pvalue->id = rtxMemAllocType (pctxt, TemporaryID);

         if (pvalue->id == NULL)
            return RTERR_NOMEM;

         asn1Init_TemporaryID ((TemporaryID*)pvalue->id);

         stat = asn1PD_TemporaryID (pctxt, (TemporaryID*)pvalue->id);

         pctxt->level--;
         break;

         case 4:
         /* decode position */
         pctxt->level++;

         pvalue->position = rtxMemAllocType (pctxt, Position3D);

         if (pvalue->position == NULL)
            return RTERR_NOMEM;

         asn1Init_Position3D ((Position3D*)pvalue->position);

         stat = asn1PD_Position3D (pctxt, (Position3D*)pvalue->position);

         pctxt->level--;
         break;

         case 5:
         /* decode accuracy */
         pctxt->level++;

         pvalue->accuracy = rtxMemAllocTypeZ (pctxt, PositionalAccuracy);

         if (pvalue->accuracy == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_PositionalAccuracy (pctxt, (PositionalAccuracy*)pvalue->accuracy);

         pctxt->level--;
         break;

         case 6:
         /* decode speed */
         pctxt->level++;

         stat = asn1PD_Velocity (pctxt, (Velocity*)&pvalue->speed);

         pctxt->level--;
         break;

         case 7:
         /* decode heading */
         pctxt->level++;

         stat = asn1PD_Heading (pctxt, (Heading*)&pvalue->heading);

         pctxt->level--;
         break;

         case 8:
         /* decode accelSet */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.accelSetPresent = 1;

            pvalue->accelSet = rtxMemAllocTypeZ (pctxt, AccelerationSet4Way);

            if (pvalue->accelSet == NULL)
               return RTERR_NOMEM;

            stat = asn1PD_AccelerationSet4Way (pctxt, (AccelerationSet4Way*)pvalue->accelSet);

            pctxt->level--;
         }
         break;

         case 9:
         /* decode pathHistory */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.pathHistoryPresent = 1;

            pvalue->pathHistory = rtxMemAllocType (pctxt, PathHistory);

            if (pvalue->pathHistory == NULL)
               return RTERR_NOMEM;

            asn1Init_PathHistory ((PathHistory*)pvalue->pathHistory);

            stat = asn1PD_PathHistory (pctxt, (PathHistory*)pvalue->pathHistory);

            pctxt->level--;
         }
         break;

         case 10:
         /* decode pathPrediction */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.pathPredictionPresent = 1;

            pvalue->pathPrediction = rtxMemAllocType (pctxt, PathPrediction);

            if (pvalue->pathPrediction == NULL)
               return RTERR_NOMEM;

            asn1Init_PathPrediction ((PathPrediction*)pvalue->pathPrediction);

            stat = asn1PD_PathPrediction (pctxt, (PathPrediction*)pvalue->pathPrediction);

            pctxt->level--;
         }
         break;

         case 11:
         /* decode propulsion */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.propulsionPresent = 1;

            stat = asn1PD_PropelledInformation (pctxt, &pvalue->propulsion);

            pctxt->level--;
         }
         break;

         case 12:
         /* decode useState */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.useStatePresent = 1;

            stat = asn1PD_PersonalDeviceUsageState (pctxt, &pvalue->useState);

            pctxt->level--;
         }
         break;

         case 13:
         /* decode crossRequest */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.crossRequestPresent = 1;

            stat = asn1PD_PersonalCrossingRequest (pctxt, &pvalue->crossRequest);

            pctxt->level--;
         }
         break;

         case 14:
         /* decode crossState */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.crossStatePresent = 1;

            stat = asn1PD_PersonalCrossingInProgress (pctxt, &pvalue->crossState);

            pctxt->level--;
         }
         break;

         case 15:
         /* decode clusterSize */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.clusterSizePresent = 1;

            stat = asn1PD_NumberOfParticipantsInCluster (pctxt, &pvalue->clusterSize);

            pctxt->level--;
         }
         break;

         case 16:
         /* decode clusterRadius */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.clusterRadiusPresent = 1;

            stat = asn1PD_PersonalClusterRadius (pctxt, &pvalue->clusterRadius);

            pctxt->level--;
         }
         break;

         case 17:
         /* decode eventResponderType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.eventResponderTypePresent = 1;

            stat = asn1PD_PublicSafetyEventResponderWorkerType (pctxt, &pvalue->eventResponderType);

            pctxt->level--;
         }
         break;

         case 18:
         /* decode activityType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.activityTypePresent = 1;

            stat = asn1PD_PublicSafetyAndRoadWorkerActivity (pctxt, &pvalue->activityType);

            pctxt->level--;
         }
         break;

         case 19:
         /* decode activitySubType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.activitySubTypePresent = 1;

            stat = asn1PD_PublicSafetyDirectingTrafficSubType (pctxt, &pvalue->activitySubType);

            pctxt->level--;
         }
         break;

         case 20:
         /* decode assistType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.assistTypePresent = 1;

            stat = asn1PD_PersonalAssistive (pctxt, &pvalue->assistType);

            pctxt->level--;
         }
         break;

         case 21:
         /* decode sizing */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.sizingPresent = 1;

            stat = asn1PD_UserSizeAndBehaviour (pctxt, &pvalue->sizing);

            pctxt->level--;
         }
         break;

         case 22:
         /* decode attachment */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.attachmentPresent = 1;

            stat = asn1PD_Attachment (pctxt, &pvalue->attachment);

            pctxt->level--;
         }
         break;

         case 23:
         /* decode attachmentRadius */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.attachmentRadiusPresent = 1;

            stat = asn1PD_AttachmentRadius (pctxt, &pvalue->attachmentRadius);

            pctxt->level--;
         }
         break;

         case 24:
         /* decode animalType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.animalTypePresent = 1;

            stat = asn1PD_AnimalType (pctxt, &pvalue->animalType);

            pctxt->level--;
         }
         break;

         case 25:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_PersonalSafetyMessage_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

