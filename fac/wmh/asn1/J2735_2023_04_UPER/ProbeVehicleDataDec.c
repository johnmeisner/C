/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "ProbeVehicleData.h"
#include "REGION.h"
#include "Common.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PD_AccelerationConfidence (OSCTXT* pctxt, AccelerationConfidence* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 3);
   return stat;
}

EXTERN int asn1PD_BrakeAppliedPressure (OSCTXT* pctxt, BrakeAppliedPressure* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 4);
   return stat;
}

EXTERN int asn1PD_DrivingWheelAngle (OSCTXT* pctxt, DrivingWheelAngle* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 256, range_bitcnt = 8 */
   stat = pd_ConsInt8(pctxt, pvalue, -128, 127);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_AxleLocation (OSCTXT* pctxt, AxleLocation* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_AxleWeight (OSCTXT* pctxt, AxleWeight* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, 16);
   if (stat != 0) return stat;

   if (*pvalue > 64255) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_CargoWeight (OSCTXT* pctxt, CargoWeight* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, 16);
   if (stat != 0) return stat;

   if (*pvalue > 64255) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_DriveAxleLiftAirPressure (OSCTXT* pctxt, DriveAxleLiftAirPressure* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 10);
   if (stat != 0) return stat;

   if (*pvalue > 1000) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_DriveAxleLocation (OSCTXT* pctxt, DriveAxleLocation* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_DriveAxleLubePressure (OSCTXT* pctxt, DriveAxleLubePressure* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 250) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_DriveAxleTemperature (OSCTXT* pctxt, DriveAxleTemperature* pvalue)
{
   int stat;

   /* range_value = 251, range_bitcnt = 8 */
   stat = pd_ConsInt16(pctxt, pvalue, -40, 210);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_SteeringAxleLubePressure (OSCTXT* pctxt, SteeringAxleLubePressure* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 250) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_SteeringAxleTemperature (OSCTXT* pctxt, SteeringAxleTemperature* pvalue)
{
   int stat;

   /* range_value = 251, range_bitcnt = 8 */
   stat = pd_ConsInt16(pctxt, pvalue, -40, 210);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_TireLeakageRate (OSCTXT* pctxt, TireLeakageRate* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, 16);
   if (stat != 0) return stat;

   if (*pvalue > 64255) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_TireLocation (OSCTXT* pctxt, TireLocation* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_TirePressureThresholdDetection (OSCTXT* pctxt, TirePressureThresholdDetection* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 3);
   return stat;
}

EXTERN int asn1PD_TirePressure (OSCTXT* pctxt, TirePressure* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 250) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_TireTemp (OSCTXT* pctxt, TireTemp* pvalue)
{
   return pd_ConsInteger(pctxt, pvalue,  -8736,  55519);
}

EXTERN int asn1PD_WheelEndElectFault (OSCTXT* pctxt, WheelEndElectFault* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 2);
   return stat;
}

EXTERN int asn1PD_WheelSensorStatus (OSCTXT* pctxt, WheelSensorStatus* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 2);
   return stat;
}

EXTERN int asn1PD_ProbeSegmentNumber (OSCTXT* pctxt, ProbeSegmentNumber* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 32767) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_RainSensor (OSCTXT* pctxt, RainSensor* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 3);
   return stat;
}

EXTERN int asn1PD_SteeringWheelAngleConfidence (OSCTXT* pctxt, SteeringWheelAngleConfidence* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 2);
   return stat;
}

EXTERN int asn1PD_SteeringWheelAngleRateOfChange (OSCTXT* pctxt, SteeringWheelAngleRateOfChange* pvalue)
{
   int stat;

   /* range_value = 255, range_bitcnt = 8 */
   stat = pd_ConsInt8(pctxt, pvalue, -127, 127);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_SunSensor (OSCTXT* pctxt, SunSensor* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 10);
   if (stat != 0) return stat;

   if (*pvalue > 1000) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_ThrottlePosition (OSCTXT* pctxt, ThrottlePosition* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 200) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_VINstring (OSCTXT* pctxt, VINstring* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(17), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_YawRateConfidence (OSCTXT* pctxt, YawRateConfidence* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 3);
   return stat;
}

EXTERN int asn1PD_VehicleIdent_vehicleClass (OSCTXT* pctxt, VehicleIdent_vehicleClass* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = rtxDecBits(pctxt, &ui, 2);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* vGroup */
      case 0:
         pctxt->level++;

         stat = asn1PD_VehicleGroupAffected (pctxt, &pvalue->u.vGroup);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* rGroup */
      case 1:
         pctxt->level++;

         stat = asn1PD_ResponderGroupAffected (pctxt, &pvalue->u.rGroup);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* rEquip */
      case 2:
         pctxt->level++;

         stat = asn1PD_IncidentResponseEquipment (pctxt, &pvalue->u.rEquip);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_VehicleIdent (OSCTXT* pctxt, VehicleIdent* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[6];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, (DescriptiveName*)&pvalue->name);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode vin */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vinPresent = 1;

            stat = asn1PD_VINstring (pctxt, &pvalue->vin);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode ownerCode */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.ownerCodePresent = 1;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

            stat = pd_ConstrainedStringEx (pctxt, &pvalue->ownerCode, 0, 8, 7, 7);
            if (stat != 0) return stat;

            pctxt->level--;
         }
         break;

         case 3:
         /* decode id */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.idPresent = 1;

            pvalue->id = rtxMemAllocType (pctxt, VehicleID);

            if (pvalue->id == NULL)
               return RTERR_NOMEM;

            asn1Init_VehicleID ((VehicleID*)pvalue->id);

            stat = asn1PD_VehicleID (pctxt, (VehicleID*)pvalue->id);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode vehicleType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vehicleTypePresent = 1;

            stat = asn1PD_VehicleType (pctxt, (VehicleType*)&pvalue->vehicleType);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode vehicleClass */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vehicleClassPresent = 1;

            stat = asn1PD_VehicleIdent_vehicleClass (pctxt, &pvalue->vehicleClass);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_VehicleStatus_steering (OSCTXT* pctxt, VehicleStatus_steering* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode angle */
         pctxt->level++;

         stat = asn1PD_SteeringWheelAngle (pctxt, (SteeringWheelAngle*)&pvalue->angle);

         pctxt->level--;
         break;

         case 1:
         /* decode confidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.confidencePresent = 1;

            stat = asn1PD_SteeringWheelAngleConfidence (pctxt, &pvalue->confidence);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode rate */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.ratePresent = 1;

            stat = asn1PD_SteeringWheelAngleRateOfChange (pctxt, &pvalue->rate);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode wheels */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.wheelsPresent = 1;

            stat = asn1PD_DrivingWheelAngle (pctxt, &pvalue->wheels);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   return (stat);
}

EXTERN int asn1PD_AccelSteerYawRateConfidence (OSCTXT* pctxt, AccelSteerYawRateConfidence* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode yawRate */
   pctxt->level++;

   stat = asn1PD_YawRateConfidence (pctxt, &pvalue->yawRate);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode acceleration */
   pctxt->level++;

   stat = asn1PD_AccelerationConfidence (pctxt, &pvalue->acceleration);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode steeringWheelAngle */
   pctxt->level++;

   stat = asn1PD_SteeringWheelAngleConfidence (pctxt, &pvalue->steeringWheelAngle);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_ConfidenceSet (OSCTXT* pctxt, ConfidenceSet* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[7];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode accelConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.accelConfidencePresent = 1;

            stat = asn1PD_AccelSteerYawRateConfidence (pctxt, &pvalue->accelConfidence);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode speedConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.speedConfidencePresent = 1;

            pvalue->speedConfidence = rtxMemAllocTypeZ (pctxt, 
               SpeedandHeadingandThrottleConfidence);

            if (pvalue->speedConfidence == NULL)
               return RTERR_NOMEM;

            stat = asn1PD_SpeedandHeadingandThrottleConfidence (pctxt, (SpeedandHeadingandThrottleConfidence*)pvalue->speedConfidence);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode timeConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.timeConfidencePresent = 1;

            stat = asn1PD_TimeConfidence (pctxt, (TimeConfidence*)&pvalue->timeConfidence);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode posConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.posConfidencePresent = 1;

            pvalue->posConfidence = rtxMemAllocTypeZ (pctxt, 
               PositionConfidenceSet);

            if (pvalue->posConfidence == NULL)
               return RTERR_NOMEM;

            stat = asn1PD_PositionConfidenceSet (pctxt, (PositionConfidenceSet*)pvalue->posConfidence);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode steerConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.steerConfidencePresent = 1;

            stat = asn1PD_SteeringWheelAngleConfidence (pctxt, &pvalue->steerConfidence);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode headingConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.headingConfidencePresent = 1;

            stat = asn1PD_HeadingConfidence (pctxt, (HeadingConfidence*)&pvalue->headingConfidence);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode throttleConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.throttleConfidencePresent = 1;

            stat = asn1PD_ThrottleConfidence (pctxt, (ThrottleConfidence*)&pvalue->throttleConfidence);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_VehicleStatus_accelSets (OSCTXT* pctxt, VehicleStatus_accelSets* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode accel4way */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.accel4wayPresent = 1;

            pvalue->accel4way = rtxMemAllocTypeZ (pctxt, AccelerationSet4Way);

            if (pvalue->accel4way == NULL)
               return RTERR_NOMEM;

            stat = asn1PD_AccelerationSet4Way (pctxt, (AccelerationSet4Way*)pvalue->accel4way);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode vertAccelThres */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vertAccelThresPresent = 1;

            pvalue->vertAccelThres = rtxMemAllocType (pctxt, 
               VerticalAccelerationThreshold);

            if (pvalue->vertAccelThres == NULL)
               return RTERR_NOMEM;

            asn1Init_VerticalAccelerationThreshold ((VerticalAccelerationThreshold*)pvalue->vertAccelThres);

            stat = asn1PD_VerticalAccelerationThreshold (pctxt, (VerticalAccelerationThreshold*)pvalue->vertAccelThres);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode yawRateCon */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.yawRateConPresent = 1;

            stat = asn1PD_YawRateConfidence (pctxt, &pvalue->yawRateCon);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode hozAccelCon */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.hozAccelConPresent = 1;

            stat = asn1PD_AccelerationConfidence (pctxt, &pvalue->hozAccelCon);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode confidenceSet */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.confidenceSetPresent = 1;

            stat = asn1PD_ConfidenceSet (pctxt, &pvalue->confidenceSet);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   return (stat);
}

EXTERN int asn1PD_VehicleStatus_object (OSCTXT* pctxt, VehicleStatus_object* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode obDist */
   pctxt->level++;

   stat = asn1PD_ObstacleDistance (pctxt, (ObstacleDistance*)&pvalue->obDist);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode obDirect */
   pctxt->level++;

   stat = asn1PD_Common_Angle (pctxt, (Common_Angle*)&pvalue->obDirect);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode dateTime */
   pctxt->level++;

   pvalue->dateTime = rtxMemAllocType (pctxt, DDateTime);

   if (pvalue->dateTime == NULL)
      return RTERR_NOMEM;

   asn1Init_DDateTime ((DDateTime*)pvalue->dateTime);

   stat = asn1PD_DDateTime (pctxt, (DDateTime*)pvalue->dateTime);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_VehicleStatus_vehicleData (OSCTXT* pctxt, VehicleStatus_vehicleData* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode height */
   pctxt->level++;

   stat = asn1PD_VehicleHeight (pctxt, (VehicleHeight*)&pvalue->height);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode bumpers */
   pctxt->level++;

   pvalue->bumpers = rtxMemAllocTypeZ (pctxt, BumperHeights);

   if (pvalue->bumpers == NULL)
      return RTERR_NOMEM;

   stat = asn1PD_BumperHeights (pctxt, (BumperHeights*)pvalue->bumpers);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode mass */
   pctxt->level++;

   stat = asn1PD_VehicleMass (pctxt, (VehicleMass*)&pvalue->mass);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode trailerWeight */
   pctxt->level++;

   stat = asn1PD_TrailerWeight (pctxt, (TrailerWeight*)&pvalue->trailerWeight);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode type */
   pctxt->level++;

   stat = asn1PD_VehicleType (pctxt, (VehicleType*)&pvalue->type);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_TireData (OSCTXT* pctxt, TireData* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[7];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode location */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.locationPresent = 1;

            stat = asn1PD_TireLocation (pctxt, &pvalue->location);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode pressure */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.pressurePresent = 1;

            stat = asn1PD_TirePressure (pctxt, &pvalue->pressure);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode temp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.tempPresent = 1;

            stat = asn1PD_TireTemp (pctxt, &pvalue->temp);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode wheelSensorStatus */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.wheelSensorStatusPresent = 1;

            stat = asn1PD_WheelSensorStatus (pctxt, &pvalue->wheelSensorStatus);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode wheelEndElectFault */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.wheelEndElectFaultPresent = 1;

            stat = asn1PD_WheelEndElectFault (pctxt, &pvalue->wheelEndElectFault);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode leakageRate */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.leakageRatePresent = 1;

            stat = asn1PD_TireLeakageRate (pctxt, &pvalue->leakageRate);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode detection */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.detectionPresent = 1;

            stat = asn1PD_TirePressureThresholdDetection (pctxt, &pvalue->detection);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_TireDataList (OSCTXT* pctxt, TireDataList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TireData* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, TireData);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_TireData (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TireData (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_AxleWeightSet (OSCTXT* pctxt, AxleWeightSet* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode location */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.locationPresent = 1;

      stat = asn1PD_AxleLocation (pctxt, &pvalue->location);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode weight */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.weightPresent = 1;

      stat = asn1PD_AxleWeight (pctxt, &pvalue->weight);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_AxleWeightList (OSCTXT* pctxt, AxleWeightList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AxleWeightSet* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, AxleWeightSet);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_AxleWeightSet (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AxleWeightSet (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_J1939data (OSCTXT* pctxt, J1939data* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[10];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 10; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 10; i_++) {
      switch (i_) {
         case 0:
         /* decode tires */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.tiresPresent = 1;

            stat = asn1PD_TireDataList (pctxt, &pvalue->tires);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode axles */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.axlesPresent = 1;

            stat = asn1PD_AxleWeightList (pctxt, &pvalue->axles);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode trailerWeight */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.trailerWeightPresent = 1;

            stat = asn1PD_TrailerWeight (pctxt, (TrailerWeight*)&pvalue->trailerWeight);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode cargoWeight */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.cargoWeightPresent = 1;

            stat = asn1PD_CargoWeight (pctxt, &pvalue->cargoWeight);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode steeringAxleTemperature */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.steeringAxleTemperaturePresent = 1;

            stat = asn1PD_SteeringAxleTemperature (pctxt, &pvalue->steeringAxleTemperature);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode driveAxleLocation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.driveAxleLocationPresent = 1;

            stat = asn1PD_DriveAxleLocation (pctxt, &pvalue->driveAxleLocation);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode driveAxleLiftAirPressure */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.driveAxleLiftAirPressurePresent = 1;

            stat = asn1PD_DriveAxleLiftAirPressure (pctxt, &pvalue->driveAxleLiftAirPressure);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode driveAxleTemperature */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.driveAxleTemperaturePresent = 1;

            stat = asn1PD_DriveAxleTemperature (pctxt, &pvalue->driveAxleTemperature);

            pctxt->level--;
         }
         break;

         case 8:
         /* decode driveAxleLubePressure */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.driveAxleLubePressurePresent = 1;

            stat = asn1PD_DriveAxleLubePressure (pctxt, &pvalue->driveAxleLubePressure);

            pctxt->level--;
         }
         break;

         case 9:
         /* decode steeringAxleLubePressure */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.steeringAxleLubePressurePresent = 1;

            stat = asn1PD_SteeringAxleLubePressure (pctxt, &pvalue->steeringAxleLubePressure);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_VehicleStatus_weatherReport (OSCTXT* pctxt, VehicleStatus_weatherReport* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode isRaining */
         pctxt->level++;

         stat = asn1PD_EssPrecipYesNo (pctxt, &pvalue->isRaining);

         pctxt->level--;
         break;

         case 1:
         /* decode rainRate */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.rainRatePresent = 1;

            stat = asn1PD_EssPrecipRate (pctxt, &pvalue->rainRate);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode precipSituation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.precipSituationPresent = 1;

            stat = asn1PD_EssPrecipSituation (pctxt, &pvalue->precipSituation);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode solarRadiation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.solarRadiationPresent = 1;

            stat = asn1PD_EssSolarRadiation (pctxt, &pvalue->solarRadiation);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode friction */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.frictionPresent = 1;

            stat = asn1PD_EssMobileFriction (pctxt, &pvalue->friction);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   return (stat);
}

EXTERN int asn1PD_VehicleStatus (OSCTXT* pctxt, VehicleStatus* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[22];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 22; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 22; i_++) {
      switch (i_) {
         case 0:
         /* decode lights */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.lightsPresent = 1;

            pvalue->lights = rtxMemAllocType (pctxt, ExteriorLights);

            if (pvalue->lights == NULL)
               return RTERR_NOMEM;

            asn1Init_ExteriorLights ((ExteriorLights*)pvalue->lights);

            stat = asn1PD_ExteriorLights (pctxt, (ExteriorLights*)pvalue->lights);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode lightBar */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.lightBarPresent = 1;

            stat = asn1PD_LightbarInUse (pctxt, (LightbarInUse*)&pvalue->lightBar);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode wipers */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.wipersPresent = 1;

            pvalue->wipers = rtxMemAllocType (pctxt, WiperSet);

            if (pvalue->wipers == NULL)
               return RTERR_NOMEM;

            asn1Init_WiperSet ((WiperSet*)pvalue->wipers);

            stat = asn1PD_WiperSet (pctxt, (WiperSet*)pvalue->wipers);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode brakeStatus */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.brakeStatusPresent = 1;

            pvalue->brakeStatus = rtxMemAllocType (pctxt, BrakeSystemStatus);

            if (pvalue->brakeStatus == NULL)
               return RTERR_NOMEM;

            asn1Init_BrakeSystemStatus ((BrakeSystemStatus*)pvalue->brakeStatus);

            stat = asn1PD_BrakeSystemStatus (pctxt, (BrakeSystemStatus*)pvalue->brakeStatus);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode brakePressure */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.brakePressurePresent = 1;

            stat = asn1PD_BrakeAppliedPressure (pctxt, &pvalue->brakePressure);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode roadFriction */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.roadFrictionPresent = 1;

            stat = asn1PD_CoefficientOfFriction (pctxt, (CoefficientOfFriction*)&pvalue->roadFriction);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode sunData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.sunDataPresent = 1;

            stat = asn1PD_SunSensor (pctxt, &pvalue->sunData);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode rainData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.rainDataPresent = 1;

            stat = asn1PD_RainSensor (pctxt, &pvalue->rainData);

            pctxt->level--;
         }
         break;

         case 8:
         /* decode airTemp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.airTempPresent = 1;

            stat = asn1PD_AmbientAirTemperature (pctxt, (AmbientAirTemperature*)&pvalue->airTemp);

            pctxt->level--;
         }
         break;

         case 9:
         /* decode airPres */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.airPresPresent = 1;

            stat = asn1PD_AmbientAirPressure (pctxt, (AmbientAirPressure*)&pvalue->airPres);

            pctxt->level--;
         }
         break;

         case 10:
         /* decode steering */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.steeringPresent = 1;

            stat = asn1PD_VehicleStatus_steering (pctxt, &pvalue->steering);

            pctxt->level--;
         }
         break;

         case 11:
         /* decode accelSets */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.accelSetsPresent = 1;

            stat = asn1PD_VehicleStatus_accelSets (pctxt, &pvalue->accelSets);

            pctxt->level--;
         }
         break;

         case 12:
         /* decode object */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.objectPresent = 1;

            stat = asn1PD_VehicleStatus_object (pctxt, &pvalue->object);

            pctxt->level--;
         }
         break;

         case 13:
         /* decode fullPos */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.fullPosPresent = 1;

            pvalue->fullPos = rtxMemAllocType (pctxt, FullPositionVector);

            if (pvalue->fullPos == NULL)
               return RTERR_NOMEM;

            asn1Init_FullPositionVector ((FullPositionVector*)pvalue->fullPos);

            stat = asn1PD_FullPositionVector (pctxt, (FullPositionVector*)pvalue->fullPos);

            pctxt->level--;
         }
         break;

         case 14:
         /* decode throttlePos */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.throttlePosPresent = 1;

            stat = asn1PD_ThrottlePosition (pctxt, &pvalue->throttlePos);

            pctxt->level--;
         }
         break;

         case 15:
         /* decode speedHeadC */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.speedHeadCPresent = 1;

            pvalue->speedHeadC = rtxMemAllocTypeZ (pctxt, 
               SpeedandHeadingandThrottleConfidence);

            if (pvalue->speedHeadC == NULL)
               return RTERR_NOMEM;

            stat = asn1PD_SpeedandHeadingandThrottleConfidence (pctxt, (SpeedandHeadingandThrottleConfidence*)pvalue->speedHeadC);

            pctxt->level--;
         }
         break;

         case 16:
         /* decode speedC */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.speedCPresent = 1;

            stat = asn1PD_SpeedConfidence (pctxt, (SpeedConfidence*)&pvalue->speedC);

            pctxt->level--;
         }
         break;

         case 17:
         /* decode vehicleData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vehicleDataPresent = 1;

            stat = asn1PD_VehicleStatus_vehicleData (pctxt, &pvalue->vehicleData);

            pctxt->level--;
         }
         break;

         case 18:
         /* decode vehicleIdent */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vehicleIdentPresent = 1;

            stat = asn1PD_VehicleIdent (pctxt, &pvalue->vehicleIdent);

            pctxt->level--;
         }
         break;

         case 19:
         /* decode j1939data */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.j1939dataPresent = 1;

            stat = asn1PD_J1939data (pctxt, &pvalue->j1939data);

            pctxt->level--;
         }
         break;

         case 20:
         /* decode weatherReport */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.weatherReportPresent = 1;

            stat = asn1PD_VehicleStatus_weatherReport (pctxt, &pvalue->weatherReport);

            pctxt->level--;
         }
         break;

         case 21:
         /* decode gnssStatus */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.gnssStatusPresent = 1;

            pvalue->gnssStatus = rtxMemAllocType (pctxt, GNSSstatus);

            if (pvalue->gnssStatus == NULL)
               return RTERR_NOMEM;

            asn1Init_GNSSstatus ((GNSSstatus*)pvalue->gnssStatus);

            stat = asn1PD_GNSSstatus (pctxt, (GNSSstatus*)pvalue->gnssStatus);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_Snapshot (OSCTXT* pctxt, Snapshot* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode thePosition */
   pctxt->level++;

   pvalue->thePosition = rtxMemAllocType (pctxt, FullPositionVector);

   if (pvalue->thePosition == NULL)
      return RTERR_NOMEM;

   asn1Init_FullPositionVector ((FullPositionVector*)pvalue->thePosition);

   stat = asn1PD_FullPositionVector (pctxt, (FullPositionVector*)pvalue->thePosition);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode safetyExt */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.safetyExtPresent = 1;

      pvalue->safetyExt = rtxMemAllocType (pctxt, VehicleSafetyExtensions);

      if (pvalue->safetyExt == NULL)
         return RTERR_NOMEM;

      asn1Init_VehicleSafetyExtensions ((VehicleSafetyExtensions*)pvalue->safetyExt);

      stat = asn1PD_VehicleSafetyExtensions (pctxt, (VehicleSafetyExtensions*)pvalue->safetyExt);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode dataSet */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.dataSetPresent = 1;

      stat = asn1PD_VehicleStatus (pctxt, &pvalue->dataSet);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_ProbeVehicleData_snapshots (OSCTXT* pctxt, ProbeVehicleData_snapshots* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      Snapshot* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, Snapshot);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_Snapshot (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_Snapshot (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_ProbeVehicleData_regional (OSCTXT* pctxt, ProbeVehicleData_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_ProbeVehicleData (OSCTXT* pctxt, ProbeVehicleData* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, (MinuteOfTheYear*)&pvalue->timeStamp);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode segNum */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.segNumPresent = 1;

            stat = asn1PD_ProbeSegmentNumber (pctxt, &pvalue->segNum);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode probeID */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.probeIDPresent = 1;

            stat = asn1PD_VehicleIdent (pctxt, &pvalue->probeID);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode startVector */
         pctxt->level++;

         pvalue->startVector = rtxMemAllocType (pctxt, FullPositionVector);

         if (pvalue->startVector == NULL)
            return RTERR_NOMEM;

         asn1Init_FullPositionVector ((FullPositionVector*)pvalue->startVector);

         stat = asn1PD_FullPositionVector (pctxt, (FullPositionVector*)pvalue->startVector);

         pctxt->level--;
         break;

         case 4:
         /* decode vehicleType */
         pctxt->level++;

         pvalue->vehicleType = rtxMemAllocType (pctxt, VehicleClassification);

         if (pvalue->vehicleType == NULL)
            return RTERR_NOMEM;

         asn1Init_VehicleClassification ((VehicleClassification*)pvalue->vehicleType);

         stat = asn1PD_VehicleClassification (pctxt, (VehicleClassification*)pvalue->vehicleType);

         pctxt->level--;
         break;

         case 5:
         /* decode snapshots */
         pctxt->level++;

         stat = asn1PD_ProbeVehicleData_snapshots (pctxt, &pvalue->snapshots);

         pctxt->level--;
         break;

         case 6:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_ProbeVehicleData_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

