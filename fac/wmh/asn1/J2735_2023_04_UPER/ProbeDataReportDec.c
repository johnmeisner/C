/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "ProbeDataReport.h"
#include "Common.h"
#include "RoadWeatherMessage.h"
#include "ProbeDataConfig.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PD_RptVehicleClass (OSCTXT* pctxt, RptVehicleClass* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(12));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 12) {
         return RTERR_CONSVIO;
      }
      *pvalue += 1;
   }

   return (stat);
}

EXTERN int asn1PD_ProbeDataReport_MeanVariation (OSCTXT* pctxt, ProbeDataReport_MeanVariation* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 25000) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_StdDev (OSCTXT* pctxt, StdDev* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 14);
   if (stat != 0) return stat;

   if (*pvalue > 10000) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_RptWiperStatus (OSCTXT* pctxt, RptWiperStatus* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(3));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_RptCommSysPerfEvents_rfDataRsuInfo (OSCTXT* pctxt, RptCommSysPerfEvents_rfDataRsuInfo* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_RptVelocity (OSCTXT* pctxt, RptVelocity* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode speed */
   pctxt->level++;

   stat = asn1PD_Speed (pctxt, (Speed*)&pvalue->speed);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode speedStdDev */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.speedStdDevPresent = 1;

      stat = asn1PD_StdDev (pctxt, &pvalue->speedStdDev);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode heading */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.headingPresent = 1;

      stat = asn1PD_Heading (pctxt, (Heading*)&pvalue->heading);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RptDevType (OSCTXT* pctxt, RptDevType* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode oemOrAftermarket */
   pctxt->level++;

   rtxDecBit(pctxt, &pvalue->oemOrAftermarket);

   pctxt->level--;

   /* decode canOrIvnConnected */
   pctxt->level++;

   rtxDecBit(pctxt, &pvalue->canOrIvnConnected);

   pctxt->level--;

   /* decode mcoCapable */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.mcoCapablePresent = 1;

      rtxDecBit(pctxt, &pvalue->mcoCapable);

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_ReportCharacteristics (OSCTXT* pctxt, ReportCharacteristics* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 9; i_++) {
      switch (i_) {
         case 0:
         /* decode timeStamp */
         pctxt->level++;

         pvalue->timeStamp = rtxMemAllocType (pctxt, DDateTime);

         if (pvalue->timeStamp == NULL)
            return RTERR_NOMEM;

         asn1Init_DDateTime ((DDateTime*)pvalue->timeStamp);

         stat = asn1PD_DDateTime (pctxt, (DDateTime*)pvalue->timeStamp);

         pctxt->level--;
         break;

         case 1:
         /* decode position */
         pctxt->level++;

         pvalue->position = rtxMemAllocType (pctxt, Position3D);

         if (pvalue->position == NULL)
            return RTERR_NOMEM;

         asn1Init_Position3D ((Position3D*)pvalue->position);

         stat = asn1PD_Position3D (pctxt, (Position3D*)pvalue->position);

         pctxt->level--;
         break;

         case 2:
         /* decode posAccuracy */
         pctxt->level++;

         pvalue->posAccuracy = rtxMemAllocTypeZ (pctxt, PositionalAccuracy);

         if (pvalue->posAccuracy == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_PositionalAccuracy (pctxt, (PositionalAccuracy*)pvalue->posAccuracy);

         pctxt->level--;
         break;

         case 3:
         /* decode velocity */
         pctxt->level++;

         stat = asn1PD_RptVelocity (pctxt, &pvalue->velocity);

         pctxt->level--;
         break;

         case 4:
         /* decode vehicleClass */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vehicleClassPresent = 1;

            stat = asn1PD_RptVehicleClass (pctxt, &pvalue->vehicleClass);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode devType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.devTypePresent = 1;

            stat = asn1PD_RptDevType (pctxt, &pvalue->devType);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode vehicleSize */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vehicleSizePresent = 1;

            pvalue->vehicleSize = rtxMemAllocTypeZ (pctxt, VehicleSize);

            if (pvalue->vehicleSize == NULL)
               return RTERR_NOMEM;

            stat = asn1PD_VehicleSize (pctxt, (VehicleSize*)pvalue->vehicleSize);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode vehicleMass */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vehicleMassPresent = 1;

            stat = asn1PD_VehicleMass (pctxt, (VehicleMass*)&pvalue->vehicleMass);

            pctxt->level--;
         }
         break;

         case 8:
         /* decode vehPassengerCount */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vehPassengerCountPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->vehPassengerCount, 8);
            if (stat != 0) return stat;

            if (pvalue->vehPassengerCount > 254) {
               return RTERR_CONSVIO;
            }

            pvalue->vehPassengerCount += 1;

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RptVehicleReport (OSCTXT* pctxt, RptVehicleReport* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NtcipEssData* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, NtcipEssData);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_NtcipEssData ((NtcipEssData*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NtcipEssData (pctxt, (NtcipEssData*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_RptTransitVehData (OSCTXT* pctxt, RptTransitVehData* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 3; i_++) {
      switch (i_) {
         case 0:
         /* decode currNumPasngers */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.currNumPasngersPresent = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToByte(pctxt, &pvalue->currNumPasngers, 8);
            if (stat != 0) return stat;

            pctxt->level--;
         }
         break;

         case 1:
         /* decode avgNumPasngers */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgNumPasngersPresent = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToByte(pctxt, &pvalue->avgNumPasngers, 8);
            if (stat != 0) return stat;

            pctxt->level--;
         }
         break;

         case 2:
         /* decode trnstVehSchAdh */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.trnstVehSchAdhPresent = 1;

            PD_BYTE_ALIGN(pctxt);
            /* range_value = 256, range_bitcnt = 8 */
            stat = pd_ConsInt16(pctxt, &pvalue->trnstVehSchAdh, -200, 55);
            if (stat != 0) return stat;

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RptIntervalEvents (OSCTXT* pctxt, RptIntervalEvents* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode wiperStatus */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.wiperStatusPresent = 1;

            stat = asn1PD_RptWiperStatus (pctxt, &pvalue->wiperStatus);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode vehCount */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.vehCountPresent = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->vehCount, pctxt->buffer.aligned ? 16 : 14);
            if (stat != 0) return stat;

            if (pvalue->vehCount > 10000) {
               return RTERR_CONSVIO;
            }

            pctxt->level--;
         }
         break;

         case 2:
         /* decode weatherData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.weatherDataPresent = 1;

            stat = asn1PD_RptVehicleReport (pctxt, &pvalue->weatherData);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode transitVehData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.transitVehDataPresent = 1;

            stat = asn1PD_RptTransitVehData (pctxt, &pvalue->transitVehData);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode numOfOccupants */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.numOfOccupantsPresent = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToByte(pctxt, &pvalue->numOfOccupants, 8);
            if (stat != 0) return stat;

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RptEvents (OSCTXT* pctxt, RptEvents* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      stat = rtxDecBits(pctxt, &ui, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* absActive */
         case 0:
            pctxt->level++;

            rtxDecBit(pctxt, &pvalue->u.absActive);

            pctxt->level--;

            break;

         /* tractionCtlLoss */
         case 1:
            pctxt->level++;

            rtxDecBit(pctxt, &pvalue->u.tractionCtlLoss);

            pctxt->level--;

            break;

         /* stabilityCtlActive */
         case 2:
            pctxt->level++;

            rtxDecBit(pctxt, &pvalue->u.stabilityCtlActive);

            pctxt->level--;

            break;

         /* hardBraking */
         case 3:
            pctxt->level++;

            rtxDecBit(pctxt, &pvalue->u.hardBraking);

            pctxt->level--;

            break;

         /* swerve */
         case 4:
            pctxt->level++;

            rtxDecBit(pctxt, &pvalue->u.swerve);

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 6;

      if (pvalue->t < 6) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_RptHysteresis (OSCTXT* pctxt, RptHysteresis* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode time_ */
   pctxt->level++;

   pvalue->time_ = rtxMemAllocType (pctxt, DTime);

   if (pvalue->time_ == NULL)
      return RTERR_NOMEM;

   asn1Init_DTime ((DTime*)pvalue->time_);

   stat = asn1PD_DTime (pctxt, (DTime*)pvalue->time_);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode position */
   pctxt->level++;

   pvalue->position = rtxMemAllocType (pctxt, Position3D);

   if (pvalue->position == NULL)
      return RTERR_NOMEM;

   asn1Init_Position3D ((Position3D*)pvalue->position);

   stat = asn1PD_Position3D (pctxt, (Position3D*)pvalue->position);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode positionalAccuracy */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.positionalAccuracyPresent = 1;

      pvalue->positionalAccuracy = rtxMemAllocTypeZ (pctxt, 
         PositionalAccuracy);

      if (pvalue->positionalAccuracy == NULL)
         return RTERR_NOMEM;

      stat = asn1PD_PositionalAccuracy (pctxt, (PositionalAccuracy*)pvalue->positionalAccuracy);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode velocity */
   pctxt->level++;

   stat = asn1PD_RptVelocity (pctxt, &pvalue->velocity);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RptHysteresisRecord (OSCTXT* pctxt, RptHysteresisRecord* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(20), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RptHysteresis* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RptHysteresis);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RptHysteresis (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RptHysteresis (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_RptKinematicEvents (OSCTXT* pctxt, RptKinematicEvents* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode events */
   pctxt->level++;

   stat = asn1PD_RptEvents (pctxt, &pvalue->events);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode hysteresis */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.hysteresisPresent = 1;

      stat = asn1PD_RptHysteresisRecord (pctxt, &pvalue->hysteresis);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RptDriverAlertsAndWarnings (OSCTXT* pctxt, RptDriverAlertsAndWarnings* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      stat = rtxDecBits(pctxt, &ui, 4);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* j2945Slash1Eebl */
         case 0:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* j2945Slash1Fcw */
         case 1:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* j2945Slash1BswLcw */
         case 2:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* j2945Slash1Ima */
         case 3:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* j2945Slash1Lta */
         case 4:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* j2945Slash1Clw */
         case 5:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* redLightViolationWarn */
         case 6:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* emerVehAlert */
         case 7:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* otherAlert */
         case 8:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* otherWarning */
         case 9:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 11;

      if (pvalue->t < 11) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_RptVehicleEvents (OSCTXT* pctxt, RptVehicleEvents* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      stat = rtxDecBits(pctxt, &ui, 4);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* headLights */
         case 0:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* fogLights */
         case 1:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* hazardLights */
         case 2:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* kinematicEvents */
         case 3:
            pctxt->level++;

            pvalue->u.kinematicEvents = rtxMemAllocType (pctxt, 
               RptKinematicEvents);

            if (pvalue->u.kinematicEvents == NULL)
               return RTERR_NOMEM;

            asn1Init_RptKinematicEvents (pvalue->u.kinematicEvents);

            stat = asn1PD_RptKinematicEvents (pctxt, pvalue->u.kinematicEvents);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* wiperStatusChange */
         case 4:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* lowSpeed */
         case 5:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* resumedSpeed */
         case 6:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* vehEntrsExitsRegion */
         case 7:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* emerVehDetect */
         case 8:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* emerVehLightBar */
         case 9:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* reqTspEvp */
         case 10:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* transitVehPassCnt */
         case 11:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* transitVehDoor */
         case 12:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* v2xMsgRecption */
         case 13:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* driverAlertsAndWarnings */
         case 14:
            pctxt->level++;

            pvalue->u.driverAlertsAndWarnings = rtxMemAllocType (pctxt, 
               RptDriverAlertsAndWarnings);

            if (pvalue->u.driverAlertsAndWarnings == NULL)
               return RTERR_NOMEM;

            asn1Init_RptDriverAlertsAndWarnings (pvalue->u.driverAlertsAndWarnings);

            stat = asn1PD_RptDriverAlertsAndWarnings (pctxt, pvalue->u.driverAlertsAndWarnings);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 16;

      if (pvalue->t < 16) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_RptRoadRoughness (OSCTXT* pctxt, RptRoadRoughness* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode meanVerticalVariation */
         pctxt->level++;

         stat = asn1PD_ProbeDataReport_MeanVariation (pctxt, &pvalue->meanVerticalVariation);

         pctxt->level--;
         break;

         case 1:
         /* decode verticalVariationStdDev */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.verticalVariationStdDevPresent = 1;

            stat = asn1PD_StdDev (pctxt, &pvalue->verticalVariationStdDev);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode meanHorizontalVariation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.meanHorizontalVariationPresent = 1;

            stat = asn1PD_ProbeDataReport_MeanVariation (pctxt, &pvalue->meanHorizontalVariation);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode horizontalVariationStdDev */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.horizontalVariationStdDevPresent = 1;

            stat = asn1PD_StdDev (pctxt, &pvalue->horizontalVariationStdDev);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RptTrafficMetrics (OSCTXT* pctxt, RptTrafficMetrics* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      stat = rtxDecBits(pctxt, &ui, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* trfsigApproachDelay */
         case 0:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* trfsigApproachSpeed */
         case 1:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* trfsigArrivalGreen */
         case 2:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* trfsigArrivalRed */
         case 3:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* trfsigPedDelay */
         case 4:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* trfsigSpatMismatch */
         case 5:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* trfsigSpatTimingError */
         case 6:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 8;

      if (pvalue->t < 8) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_RptTrafficSigEncounters (OSCTXT* pctxt, RptTrafficSigEncounters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode intersectionID */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.intersectionIDPresent = 1;

      stat = asn1PD_IntersectionID (pctxt, (IntersectionID*)&pvalue->intersectionID);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode trafficMetrics */
   pctxt->level++;

   stat = asn1PD_RptTrafficMetrics (pctxt, &pvalue->trafficMetrics);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RptRoadwayEvents (OSCTXT* pctxt, RptRoadwayEvents* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      stat = rtxDecBits(pctxt, &ui, 4);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* obstacleDetected */
         case 0:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* adverseRoadSurface */
         case 1:
            pctxt->level++;

            pvalue->u.adverseRoadSurface = rtxMemAllocType (pctxt, 
               RptRoadRoughness);

            if (pvalue->u.adverseRoadSurface == NULL)
               return RTERR_NOMEM;

            asn1Init_RptRoadRoughness (pvalue->u.adverseRoadSurface);

            stat = asn1PD_RptRoadRoughness (pctxt, pvalue->u.adverseRoadSurface);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* trfsigEncounters */
         case 2:
            pctxt->level++;

            pvalue->u.trfsigEncounters = rtxMemAllocType (pctxt, 
               RptTrafficSigEncounters);

            if (pvalue->u.trfsigEncounters == NULL)
               return RTERR_NOMEM;

            asn1Init_RptTrafficSigEncounters (pvalue->u.trfsigEncounters);

            stat = asn1PD_RptTrafficSigEncounters (pctxt, pvalue->u.trfsigEncounters);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* trfsigLightOut */
         case 3:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* trfsigRoadGeoMismatch */
         case 4:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* roadsignDetection */
         case 5:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* lowRoadsignReflect */
         case 6:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* lowLaneMarkReflect */
         case 7:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* roadsignIncnstncy */
         case 8:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* laneGeoIncnstncy */
         case 9:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* incidentDetect */
         case 10:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* workZoneCharDetect */
         case 11:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* inclWeatherDetect */
         case 12:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* railrdCrossActiv */
         case 13:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* drawBridgeActiv */
         case 14:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 16;

      if (pvalue->t < 16) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_RptCommSysPerfEvents (OSCTXT* pctxt, RptCommSysPerfEvents* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      stat = rtxDecBits(pctxt, &ui, 4);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* j2945_1ChanBusy */
         case 0:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* rfDataRsuInfo */
         case 1:
            pctxt->level++;

            pvalue->u.rfDataRsuInfo = rtxMemAllocType (pctxt, 
               RptCommSysPerfEvents_rfDataRsuInfo);

            if (pvalue->u.rfDataRsuInfo == NULL)
               return RTERR_NOMEM;

            asn1Init_RptCommSysPerfEvents_rfDataRsuInfo (pvalue->u.rfDataRsuInfo);

            stat = asn1PD_RptCommSysPerfEvents_rfDataRsuInfo (pctxt, pvalue->u.rfDataRsuInfo);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* numOfRsusObserved */
         case 2:
            pctxt->level++;

            stat = rtxDecBitsToByte(pctxt, &pvalue->u.numOfRsusObserved, 8);
            if (stat != 0) return stat;

            if (pvalue->u.numOfRsusObserved > 254) {
               return RTERR_CONSVIO;
            }

            pvalue->u.numOfRsusObserved += 1;

            pctxt->level--;

            break;

         /* rfV2xJamDetect */
         case 3:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* j2945_1VehDens */
         case 4:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* j2945_1CqiBelow */
         case 5:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* j2945_1TrackingError */
         case 6:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* gnssHdopExceeds */
         case 7:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* gnssErrElipse */
         case 8:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* gnssSatsBelow */
         case 9:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         /* jammingDetect */
         case 10:
            pctxt->level++;

            /* NULL */

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 12;

      if (pvalue->t < 12) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_RptInstantaneousRecordData (OSCTXT* pctxt, RptInstantaneousRecordData* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      stat = rtxDecBits(pctxt, &ui, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* intervalEvents */
         case 0:
            pctxt->level++;

            pvalue->u.intervalEvents = rtxMemAllocType (pctxt, 
               RptIntervalEvents);

            if (pvalue->u.intervalEvents == NULL)
               return RTERR_NOMEM;

            asn1Init_RptIntervalEvents (pvalue->u.intervalEvents);

            stat = asn1PD_RptIntervalEvents (pctxt, pvalue->u.intervalEvents);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* vehEvents */
         case 1:
            pctxt->level++;

            pvalue->u.vehEvents = rtxMemAllocType (pctxt, RptVehicleEvents);

            if (pvalue->u.vehEvents == NULL)
               return RTERR_NOMEM;

            asn1Init_RptVehicleEvents (pvalue->u.vehEvents);

            stat = asn1PD_RptVehicleEvents (pctxt, pvalue->u.vehEvents);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* roadwayEvents */
         case 2:
            pctxt->level++;

            pvalue->u.roadwayEvents = rtxMemAllocType (pctxt, 
               RptRoadwayEvents);

            if (pvalue->u.roadwayEvents == NULL)
               return RTERR_NOMEM;

            asn1Init_RptRoadwayEvents (pvalue->u.roadwayEvents);

            stat = asn1PD_RptRoadwayEvents (pctxt, pvalue->u.roadwayEvents);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* commSysPerfEvents */
         case 3:
            pctxt->level++;

            pvalue->u.commSysPerfEvents = rtxMemAllocType (pctxt, 
               RptCommSysPerfEvents);

            if (pvalue->u.commSysPerfEvents == NULL)
               return RTERR_NOMEM;

            asn1Init_RptCommSysPerfEvents (pvalue->u.commSysPerfEvents);

            stat = asn1PD_RptCommSysPerfEvents (pctxt, pvalue->u.commSysPerfEvents);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_RptInstantaneousRecord (OSCTXT* pctxt, RptInstantaneousRecord* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode timeOfInstantRec */
   pctxt->level++;

   pvalue->timeOfInstantRec = rtxMemAllocType (pctxt, DDateTime);

   if (pvalue->timeOfInstantRec == NULL)
      return RTERR_NOMEM;

   asn1Init_DDateTime ((DDateTime*)pvalue->timeOfInstantRec);

   stat = asn1PD_DDateTime (pctxt, (DDateTime*)pvalue->timeOfInstantRec);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode locOfInstantRec */
   pctxt->level++;

   pvalue->locOfInstantRec = rtxMemAllocType (pctxt, Position3D);

   if (pvalue->locOfInstantRec == NULL)
      return RTERR_NOMEM;

   asn1Init_Position3D ((Position3D*)pvalue->locOfInstantRec);

   stat = asn1PD_Position3D (pctxt, (Position3D*)pvalue->locOfInstantRec);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode accOfPosition */
   pctxt->level++;

   pvalue->accOfPosition = rtxMemAllocTypeZ (pctxt, PositionalAccuracy);

   if (pvalue->accOfPosition == NULL)
      return RTERR_NOMEM;

   stat = asn1PD_PositionalAccuracy (pctxt, (PositionalAccuracy*)pvalue->accOfPosition);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode velOfInstantRec */
   pctxt->level++;

   stat = asn1PD_RptVelocity (pctxt, &pvalue->velOfInstantRec);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode record */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.recordPresent = 1;

      stat = asn1PD_RptInstantaneousRecordData (pctxt, &pvalue->record);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RptInstantaneousRecords (OSCTXT* pctxt, RptInstantaneousRecords* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RptInstantaneousRecord* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RptInstantaneousRecord);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RptInstantaneousRecord (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RptInstantaneousRecord (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_RptEmissions (OSCTXT* pctxt, RptEmissions* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[9];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 9; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 9; i_++) {
      switch (i_) {
         case 0:
         /* decode hydrocarbons */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.hydrocarbonsPresent = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->hydrocarbons, pctxt->buffer.aligned ? 16 : 10);
            if (stat != 0) return stat;

            if (pvalue->hydrocarbons > 999) {
               return RTERR_CONSVIO;
            }

            pvalue->hydrocarbons += 1;

            pctxt->level--;
         }
         break;

         case 1:
         /* decode co */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.coPresent = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->co, pctxt->buffer.aligned ? 16 : 10);
            if (stat != 0) return stat;

            if (pvalue->co > 999) {
               return RTERR_CONSVIO;
            }

            pvalue->co += 1;

            pctxt->level--;
         }
         break;

         case 2:
         /* decode co2 */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.co2Present = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->co2, pctxt->buffer.aligned ? 16 : 10);
            if (stat != 0) return stat;

            if (pvalue->co2 > 999) {
               return RTERR_CONSVIO;
            }

            pvalue->co2 += 1;

            pctxt->level--;
         }
         break;

         case 3:
         /* decode no */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.noPresent = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->no, pctxt->buffer.aligned ? 16 : 10);
            if (stat != 0) return stat;

            if (pvalue->no > 999) {
               return RTERR_CONSVIO;
            }

            pvalue->no += 1;

            pctxt->level--;
         }
         break;

         case 4:
         /* decode no2 */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.no2Present = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->no2, pctxt->buffer.aligned ? 16 : 10);
            if (stat != 0) return stat;

            if (pvalue->no2 > 999) {
               return RTERR_CONSVIO;
            }

            pvalue->no2 += 1;

            pctxt->level--;
         }
         break;

         case 5:
         /* decode so2 */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.so2Present = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->so2, pctxt->buffer.aligned ? 16 : 10);
            if (stat != 0) return stat;

            if (pvalue->so2 > 999) {
               return RTERR_CONSVIO;
            }

            pvalue->so2 += 1;

            pctxt->level--;
         }
         break;

         case 6:
         /* decode o3 */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.o3Present = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->o3, pctxt->buffer.aligned ? 16 : 10);
            if (stat != 0) return stat;

            if (pvalue->o3 > 999) {
               return RTERR_CONSVIO;
            }

            pvalue->o3 += 1;

            pctxt->level--;
         }
         break;

         case 7:
         /* decode pm10 */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.pm10Present = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->pm10, pctxt->buffer.aligned ? 16 : 10);
            if (stat != 0) return stat;

            if (pvalue->pm10 > 999) {
               return RTERR_CONSVIO;
            }

            pvalue->pm10 += 1;

            pctxt->level--;
         }
         break;

         case 8:
         /* decode pm25 */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.pm25Present = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->pm25, pctxt->buffer.aligned ? 16 : 10);
            if (stat != 0) return stat;

            if (pvalue->pm25 > 999) {
               return RTERR_CONSVIO;
            }

            pvalue->pm25 += 1;

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RptAveragedRecord (OSCTXT* pctxt, RptAveragedRecord* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[7];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode avgSpeed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgSpeedPresent = 1;

            stat = asn1PD_Speed (pctxt, (Speed*)&pvalue->avgSpeed);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode speedStdDev */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.speedStdDevPresent = 1;

            stat = asn1PD_StdDev (pctxt, &pvalue->speedStdDev);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode avgStopDuration */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgStopDurationPresent = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->avgStopDuration, 16);
            if (stat != 0) return stat;

            if (pvalue->avgStopDuration > 35999) {
               return RTERR_CONSVIO;
            }

            pvalue->avgStopDuration += 1;

            pctxt->level--;
         }
         break;

         case 3:
         /* decode avgStopStdDev */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgStopStdDevPresent = 1;

            stat = asn1PD_StdDev (pctxt, &pvalue->avgStopStdDev);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode avgFuelConsumption */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgFuelConsumptionPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->avgFuelConsumption, 8);
            if (stat != 0) return stat;

            if (pvalue->avgFuelConsumption > 254) {
               return RTERR_CONSVIO;
            }

            pvalue->avgFuelConsumption += 1;

            pctxt->level--;
         }
         break;

         case 5:
         /* decode avgEmissions */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgEmissionsPresent = 1;

            stat = asn1PD_RptEmissions (pctxt, &pvalue->avgEmissions);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode avgNumOfOccupants */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgNumOfOccupantsPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->avgNumOfOccupants, 8);
            if (stat != 0) return stat;

            if (pvalue->avgNumOfOccupants > 254) {
               return RTERR_CONSVIO;
            }

            pvalue->avgNumOfOccupants += 1;

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RptLocOfStops (OSCTXT* pctxt, RptLocOfStops* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode locationOfStop */
   pctxt->level++;

   pvalue->locationOfStop = rtxMemAllocType (pctxt, Position3D);

   if (pvalue->locationOfStop == NULL)
      return RTERR_NOMEM;

   asn1Init_Position3D ((Position3D*)pvalue->locationOfStop);

   stat = asn1PD_Position3D (pctxt, (Position3D*)pvalue->locationOfStop);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode locAccOfStop */
   pctxt->level++;

   pvalue->locAccOfStop = rtxMemAllocTypeZ (pctxt, PositionalAccuracy);

   if (pvalue->locAccOfStop == NULL)
      return RTERR_NOMEM;

   stat = asn1PD_PositionalAccuracy (pctxt, (PositionalAccuracy*)pvalue->locAccOfStop);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode durationOfStop */
   pctxt->level++;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, &pvalue->durationOfStop, 16);
   if (stat != 0) return stat;

   if (pvalue->durationOfStop > 35999) {
      return RTERR_CONSVIO;
   }

   pvalue->durationOfStop += 1;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RptSummaryRecord (OSCTXT* pctxt, RptSummaryRecord* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[12];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 12; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 12; i_++) {
      switch (i_) {
         case 0:
         /* decode regTravelTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regTravelTimePresent = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->regTravelTime, pctxt->buffer.aligned ? 16 : 12);
            if (stat != 0) return stat;

            if (pvalue->regTravelTime > 3599) {
               return RTERR_CONSVIO;
            }

            pvalue->regTravelTime += 1;

            pctxt->level--;
         }
         break;

         case 1:
         /* decode regVehDistTraveled */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regVehDistTraveledPresent = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->regVehDistTraveled, pctxt->buffer.aligned ? 16 : 9);
            if (stat != 0) return stat;

            if (pvalue->regVehDistTraveled > 499) {
               return RTERR_CONSVIO;
            }

            pvalue->regVehDistTraveled += 1;

            pctxt->level--;
         }
         break;

         case 2:
         /* decode regVehTimeTraveled */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regVehTimeTraveledPresent = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->regVehTimeTraveled, pctxt->buffer.aligned ? 16 : 12);
            if (stat != 0) return stat;

            if (pvalue->regVehTimeTraveled > 3599) {
               return RTERR_CONSVIO;
            }

            pvalue->regVehTimeTraveled += 1;

            pctxt->level--;
         }
         break;

         case 3:
         /* decode fuelConsumption */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.fuelConsumptionPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->fuelConsumption, 8);
            if (stat != 0) return stat;

            if (pvalue->fuelConsumption > 254) {
               return RTERR_CONSVIO;
            }

            pvalue->fuelConsumption += 1;

            pctxt->level--;
         }
         break;

         case 4:
         /* decode totalVehEmissions */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.totalVehEmissionsPresent = 1;

            stat = asn1PD_RptEmissions (pctxt, &pvalue->totalVehEmissions);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode numOfLowSpeedEvents */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.numOfLowSpeedEventsPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->numOfLowSpeedEvents, 8);
            if (stat != 0) return stat;

            if (pvalue->numOfLowSpeedEvents > 254) {
               return RTERR_CONSVIO;
            }

            pvalue->numOfLowSpeedEvents += 1;

            pctxt->level--;
         }
         break;

         case 6:
         /* decode timeStopped */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.timeStoppedPresent = 1;

            PD_BYTE_ALIGN(pctxt);
            stat = rtxDecBitsToUInt16(pctxt, &pvalue->timeStopped, 16);
            if (stat != 0) return stat;

            if (pvalue->timeStopped > 35999) {
               return RTERR_CONSVIO;
            }

            pvalue->timeStopped += 1;

            pctxt->level--;
         }
         break;

         case 7:
         /* decode numOfStopped */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.numOfStoppedPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->numOfStopped, 8);
            if (stat != 0) return stat;

            if (pvalue->numOfStopped > 254) {
               return RTERR_CONSVIO;
            }

            pvalue->numOfStopped += 1;

            pctxt->level--;
         }
         break;

         case 8:
         /* decode locOfStops */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.locOfStopsPresent = 1;

            stat = asn1PD_RptLocOfStops (pctxt, &pvalue->locOfStops);

            pctxt->level--;
         }
         break;

         case 9:
         /* decode regNumOfVehPassed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regNumOfVehPassedPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->regNumOfVehPassed, 8);
            if (stat != 0) return stat;

            if (pvalue->regNumOfVehPassed > 254) {
               return RTERR_CONSVIO;
            }

            pvalue->regNumOfVehPassed += 1;

            pctxt->level--;
         }
         break;

         case 10:
         /* decode regNumOfSurpassedVeh */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regNumOfSurpassedVehPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->regNumOfSurpassedVeh, 8);
            if (stat != 0) return stat;

            if (pvalue->regNumOfSurpassedVeh > 254) {
               return RTERR_CONSVIO;
            }

            pvalue->regNumOfSurpassedVeh += 1;

            pctxt->level--;
         }
         break;

         case 11:
         /* decode totalMsgsReceived */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.totalMsgsReceivedPresent = 1;

            stat = rtxDecBitsToByte(pctxt, &pvalue->totalMsgsReceived, 8);
            if (stat != 0) return stat;

            if (pvalue->totalMsgsReceived > 254) {
               return RTERR_CONSVIO;
            }

            pvalue->totalMsgsReceived += 1;

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RptAvgAndSummaryRecordData (OSCTXT* pctxt, RptAvgAndSummaryRecordData* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      {
         OSBOOL b_ = 0;
         DEC_BIT (pctxt, &b_);
         ui = b_;
      }
      pvalue->t = ui + 1;

      switch (ui) {
         /* averagedRecord */
         case 0:
            pctxt->level++;

            pvalue->u.averagedRecord = rtxMemAllocType (pctxt, 
               RptAveragedRecord);

            if (pvalue->u.averagedRecord == NULL)
               return RTERR_NOMEM;

            asn1Init_RptAveragedRecord (pvalue->u.averagedRecord);

            stat = asn1PD_RptAveragedRecord (pctxt, pvalue->u.averagedRecord);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* summaryRecord */
         case 1:
            pctxt->level++;

            pvalue->u.summaryRecord = rtxMemAllocType (pctxt, 
               RptSummaryRecord);

            if (pvalue->u.summaryRecord == NULL)
               return RTERR_NOMEM;

            asn1Init_RptSummaryRecord (pvalue->u.summaryRecord);

            stat = asn1PD_RptSummaryRecord (pctxt, pvalue->u.summaryRecord);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_RptAveragedAndSummaryRecord (OSCTXT* pctxt, RptAveragedAndSummaryRecord* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode startTime */
   pctxt->level++;

   pvalue->startTime = rtxMemAllocType (pctxt, DDateTime);

   if (pvalue->startTime == NULL)
      return RTERR_NOMEM;

   asn1Init_DDateTime ((DDateTime*)pvalue->startTime);

   stat = asn1PD_DDateTime (pctxt, (DDateTime*)pvalue->startTime);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode startLoc */
   pctxt->level++;

   pvalue->startLoc = rtxMemAllocType (pctxt, Position3D);

   if (pvalue->startLoc == NULL)
      return RTERR_NOMEM;

   asn1Init_Position3D ((Position3D*)pvalue->startLoc);

   stat = asn1PD_Position3D (pctxt, (Position3D*)pvalue->startLoc);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode startAccOfPos */
   pctxt->level++;

   pvalue->startAccOfPos = rtxMemAllocTypeZ (pctxt, PositionalAccuracy);

   if (pvalue->startAccOfPos == NULL)
      return RTERR_NOMEM;

   stat = asn1PD_PositionalAccuracy (pctxt, (PositionalAccuracy*)pvalue->startAccOfPos);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode endTime */
   pctxt->level++;

   pvalue->endTime = rtxMemAllocType (pctxt, DDateTime);

   if (pvalue->endTime == NULL)
      return RTERR_NOMEM;

   asn1Init_DDateTime ((DDateTime*)pvalue->endTime);

   stat = asn1PD_DDateTime (pctxt, (DDateTime*)pvalue->endTime);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode endLoc */
   pctxt->level++;

   pvalue->endLoc = rtxMemAllocType (pctxt, Position3D);

   if (pvalue->endLoc == NULL)
      return RTERR_NOMEM;

   asn1Init_Position3D ((Position3D*)pvalue->endLoc);

   stat = asn1PD_Position3D (pctxt, (Position3D*)pvalue->endLoc);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode endAccOfPos */
   pctxt->level++;

   pvalue->endAccOfPos = rtxMemAllocTypeZ (pctxt, PositionalAccuracy);

   if (pvalue->endAccOfPos == NULL)
      return RTERR_NOMEM;

   stat = asn1PD_PositionalAccuracy (pctxt, (PositionalAccuracy*)pvalue->endAccOfPos);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode record */
   pctxt->level++;

   stat = asn1PD_RptAvgAndSummaryRecordData (pctxt, &pvalue->record);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_ProbeDataReportMessage (OSCTXT* pctxt, ProbeDataReportMessage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode configId */
         pctxt->level++;

         stat = asn1PD_ConfigId (pctxt, (ConfigId*)&pvalue->configId);

         pctxt->level--;
         break;

         case 1:
         /* decode reportChar */
         pctxt->level++;

         stat = asn1PD_ReportCharacteristics (pctxt, &pvalue->reportChar);

         pctxt->level--;
         break;

         case 2:
         /* decode roadAuthorityID */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.roadAuthorityIDPresent = 1;

            pvalue->roadAuthorityID = rtxMemAllocType (pctxt, 
               RoadAuthorityID);

            if (pvalue->roadAuthorityID == NULL)
               return RTERR_NOMEM;

            asn1Init_RoadAuthorityID ((RoadAuthorityID*)pvalue->roadAuthorityID);

            stat = asn1PD_RoadAuthorityID (pctxt, (RoadAuthorityID*)pvalue->roadAuthorityID);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode instantaneousRecs */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.instantaneousRecsPresent = 1;

            stat = asn1PD_RptInstantaneousRecords (pctxt, &pvalue->instantaneousRecs);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode avgAndSumRec */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.avgAndSumRecPresent = 1;

            stat = asn1PD_RptAveragedAndSummaryRecord (pctxt, &pvalue->avgAndSumRec);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

