/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "AddGrpB.h"
#include "SPAT.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PD_Angle (OSCTXT* pctxt, Angle* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 239) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_Day (OSCTXT* pctxt, Day* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_DayOfWeek (OSCTXT* pctxt, DayOfWeek* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 3);
   return stat;
}

EXTERN int asn1PD_DegreesLat (OSCTXT* pctxt, DegreesLat* pvalue)
{
   int stat;

   /* range_value = 181, range_bitcnt = 8 */
   stat = pd_ConsInt8(pctxt, pvalue, -90, 90);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_DegreesLong (OSCTXT* pctxt, DegreesLong* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 361, range_bitcnt = 9 */
   stat = pd_ConsInt16(pctxt, pvalue, -180, 180);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_Elevation (OSCTXT* pctxt, Elevation* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 65536, range_bitcnt = 16 */
   stat = pd_ConsInt16(pctxt, pvalue, -32768, 32767);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_Holiday (OSCTXT* pctxt, Holiday* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 1);
   return stat;
}

EXTERN int asn1PD_Hour (OSCTXT* pctxt, Hour* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_LatitudeDMS (OSCTXT* pctxt, LatitudeDMS* pvalue)
{
   return pd_ConsInteger(pctxt, pvalue,  -32400000,  32400000);
}

EXTERN int asn1PD_LongitudeDMS (OSCTXT* pctxt, LongitudeDMS* pvalue)
{
   return pd_ConsInteger(pctxt, pvalue,  -64800000,  64800000);
}

EXTERN int asn1PD_MaxTimetoChange (OSCTXT* pctxt, MaxTimetoChange* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 12);
   if (stat != 0) return stat;

   if (*pvalue > 2402) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_MinTimetoChange (OSCTXT* pctxt, MinTimetoChange* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 12);
   if (stat != 0) return stat;

   if (*pvalue > 2402) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_Minute (OSCTXT* pctxt, Minute* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_MinutesAngle (OSCTXT* pctxt, MinutesAngle* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 6);
   if (stat != 0) return stat;

   if (*pvalue > 59) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_Month (OSCTXT* pctxt, Month* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 254) {
      return RTERR_CONSVIO;
   }

   *pvalue += 1;

   return stat;
}

EXTERN int asn1PD_MsgCount (OSCTXT* pctxt, MsgCount* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToByte(pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_Second (OSCTXT* pctxt, Second* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 6);
   if (stat != 0) return stat;

   if (*pvalue > 60) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_SecondsAngle (OSCTXT* pctxt, SecondsAngle* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 13);
   if (stat != 0) return stat;

   if (*pvalue > 5999) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_SummerTime (OSCTXT* pctxt, SummerTime* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 1);
   return stat;
}

EXTERN int asn1PD_TenthSecond (OSCTXT* pctxt, TenthSecond* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 4);
   if (stat != 0) return stat;

   if (*pvalue > 9) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_TimeRemaining (OSCTXT* pctxt, TimeRemaining* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 14);
   if (stat != 0) return stat;

   if (*pvalue > 9001) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_Year (OSCTXT* pctxt, Year* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, 16);
   if (stat != 0) return stat;

   if (*pvalue > 65534) {
      return RTERR_CONSVIO;
   }

   *pvalue += 1;

   return stat;
}

EXTERN int asn1PD_LatitudeDMS2 (OSCTXT* pctxt, LatitudeDMS2* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode d */
   pctxt->level++;

   stat = asn1PD_DegreesLat (pctxt, &pvalue->d);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode m_ */
   pctxt->level++;

   stat = asn1PD_MinutesAngle (pctxt, &pvalue->m_);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode s */
   pctxt->level++;

   stat = asn1PD_SecondsAngle (pctxt, &pvalue->s);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_LongitudeDMS2 (OSCTXT* pctxt, LongitudeDMS2* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode d */
   pctxt->level++;

   stat = asn1PD_DegreesLong (pctxt, &pvalue->d);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode m_ */
   pctxt->level++;

   stat = asn1PD_MinutesAngle (pctxt, &pvalue->m_);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode s */
   pctxt->level++;

   stat = asn1PD_SecondsAngle (pctxt, &pvalue->s);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_Node_LLdms_48b (OSCTXT* pctxt, Node_LLdms_48b* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode lon */
   pctxt->level++;

   stat = asn1PD_LongitudeDMS (pctxt, &pvalue->lon);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode lat */
   pctxt->level++;

   stat = asn1PD_LatitudeDMS (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_Node_LLdms_80b (OSCTXT* pctxt, Node_LLdms_80b* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode lon */
   pctxt->level++;

   stat = asn1PD_LongitudeDMS2 (pctxt, &pvalue->lon);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode lat */
   pctxt->level++;

   stat = asn1PD_LatitudeDMS2 (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_LaneDataAttribute_addGrpB (OSCTXT* pctxt, LaneDataAttribute_addGrpB* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OS_UNUSED_ARG (pvalue) ;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_MovementEvent_addGrpB (OSCTXT* pctxt, MovementEvent_addGrpB* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode startTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.startTimePresent = 1;

            stat = asn1PD_TimeRemaining (pctxt, &pvalue->startTime);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode minEndTime */
         pctxt->level++;

         stat = asn1PD_MinTimetoChange (pctxt, &pvalue->minEndTime);

         pctxt->level--;
         break;

         case 2:
         /* decode maxEndTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.maxEndTimePresent = 1;

            stat = asn1PD_MaxTimetoChange (pctxt, &pvalue->maxEndTime);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode likelyTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.likelyTimePresent = 1;

            stat = asn1PD_TimeRemaining (pctxt, &pvalue->likelyTime);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode confidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.confidencePresent = 1;

            stat = asn1PD_TimeIntervalConfidence (pctxt, (TimeIntervalConfidence*)&pvalue->confidence);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode nextTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.nextTimePresent = 1;

            stat = asn1PD_TimeRemaining (pctxt, &pvalue->nextTime);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_NodeOffsetPointXY_addGrpB (OSCTXT* pctxt, NodeOffsetPointXY_addGrpB* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      {
         OSBOOL b_ = 0;
         DEC_BIT (pctxt, &b_);
         ui = b_;
      }
      pvalue->t = ui + 1;

      switch (ui) {
         /* posA */
         case 0:
            pctxt->level++;

            pvalue->u.posA = rtxMemAllocTypeZ (pctxt, Node_LLdms_48b);

            if (pvalue->u.posA == NULL)
               return RTERR_NOMEM;

            stat = asn1PD_Node_LLdms_48b (pctxt, pvalue->u.posA);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* posB */
         case 1:
            pctxt->level++;

            pvalue->u.posB = rtxMemAllocTypeZ (pctxt, Node_LLdms_80b);

            if (pvalue->u.posB == NULL)
               return RTERR_NOMEM;

            stat = asn1PD_Node_LLdms_80b (pctxt, pvalue->u.posB);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_Position3D_addGrpB (OSCTXT* pctxt, Position3D_addGrpB* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode latitude */
   pctxt->level++;

   stat = asn1PD_LatitudeDMS2 (pctxt, &pvalue->latitude);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode longitude */
   pctxt->level++;

   stat = asn1PD_LongitudeDMS2 (pctxt, &pvalue->longitude);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode elevation */
   pctxt->level++;

   stat = asn1PD_Elevation (pctxt, &pvalue->elevation);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

EXTERN int asn1PD_TimeMark (OSCTXT* pctxt, TimeMark* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode year */
   pctxt->level++;

   stat = asn1PD_Year (pctxt, &pvalue->year);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode month */
   pctxt->level++;

   stat = asn1PD_Month (pctxt, &pvalue->month);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode day */
   pctxt->level++;

   stat = asn1PD_Day (pctxt, &pvalue->day);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode summerTime */
   pctxt->level++;

   stat = asn1PD_SummerTime (pctxt, &pvalue->summerTime);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode holiday */
   pctxt->level++;

   stat = asn1PD_Holiday (pctxt, &pvalue->holiday);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode dayofWeek */
   pctxt->level++;

   stat = asn1PD_DayOfWeek (pctxt, &pvalue->dayofWeek);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode hour */
   pctxt->level++;

   stat = asn1PD_Hour (pctxt, &pvalue->hour);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode minute */
   pctxt->level++;

   stat = asn1PD_Minute (pctxt, &pvalue->minute);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode second */
   pctxt->level++;

   stat = asn1PD_Second (pctxt, &pvalue->second);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode tenthSecond */
   pctxt->level++;

   stat = asn1PD_TenthSecond (pctxt, &pvalue->tenthSecond);
   if (stat != 0) return stat;

   pctxt->level--;

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

