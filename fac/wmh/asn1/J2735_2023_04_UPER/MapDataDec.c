/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "MapData.h"
#include "REGION.h"
#include "Common.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PD_AllowedManeuvers (OSCTXT* pctxt, AllowedManeuvers* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(12), OSUINTCONST(12), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_LaneAttributes_Barrier (OSCTXT* pctxt, LaneAttributes_Barrier* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_LaneAttributes_Bike (OSCTXT* pctxt, LaneAttributes_Bike* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_LaneAttributes_Crosswalk (OSCTXT* pctxt, LaneAttributes_Crosswalk* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_LaneAttributes_Parking (OSCTXT* pctxt, LaneAttributes_Parking* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_LaneAttributes_Sidewalk (OSCTXT* pctxt, LaneAttributes_Sidewalk* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_LaneAttributes_Striping (OSCTXT* pctxt, LaneAttributes_Striping* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_LaneAttributes_TrackedVehicle (OSCTXT* pctxt, LaneAttributes_TrackedVehicle* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_LaneAttributes_Vehicle (OSCTXT* pctxt, LaneAttributes_Vehicle* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 
      OSUINTCONST(0), OSUINT32_MAX);

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         PD_BYTE_ALIGN(pctxt);

      }

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return RTERR_NOMEM;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   return (stat);
}

EXTERN int asn1PD_LaneDirection (OSCTXT* pctxt, LaneDirection* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_LaneSharing (OSCTXT* pctxt, LaneSharing* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(10), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_LayerID (OSCTXT* pctxt, LayerID* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte(pctxt, pvalue, 7);
   if (stat != 0) return stat;

   if (*pvalue > 100) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_LayerType (OSCTXT* pctxt, LayerType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(7));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_RestrictionAppliesTo (OSCTXT* pctxt, RestrictionAppliesTo* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(13));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 13) {
         return RTERR_CONSVIO;
      }
   }

   return (stat);
}

EXTERN int asn1PD_LaneTypeAttributes (OSCTXT* pctxt, LaneTypeAttributes* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      stat = rtxDecBits(pctxt, &ui, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* vehicle */
         case 0:
            pctxt->level++;

            pvalue->u.vehicle = rtxMemAllocType (pctxt, 
               LaneAttributes_Vehicle);

            if (pvalue->u.vehicle == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_Vehicle (pvalue->u.vehicle);

            stat = asn1PD_LaneAttributes_Vehicle (pctxt, pvalue->u.vehicle);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* crosswalk */
         case 1:
            pctxt->level++;

            pvalue->u.crosswalk = rtxMemAllocType (pctxt, 
               LaneAttributes_Crosswalk);

            if (pvalue->u.crosswalk == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_Crosswalk (pvalue->u.crosswalk);

            stat = asn1PD_LaneAttributes_Crosswalk (pctxt, pvalue->u.crosswalk);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* bikeLane */
         case 2:
            pctxt->level++;

            pvalue->u.bikeLane = rtxMemAllocType (pctxt, LaneAttributes_Bike);

            if (pvalue->u.bikeLane == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_Bike (pvalue->u.bikeLane);

            stat = asn1PD_LaneAttributes_Bike (pctxt, pvalue->u.bikeLane);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* sidewalk */
         case 3:
            pctxt->level++;

            pvalue->u.sidewalk = rtxMemAllocType (pctxt, 
               LaneAttributes_Sidewalk);

            if (pvalue->u.sidewalk == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_Sidewalk (pvalue->u.sidewalk);

            stat = asn1PD_LaneAttributes_Sidewalk (pctxt, pvalue->u.sidewalk);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* median */
         case 4:
            pctxt->level++;

            pvalue->u.median = rtxMemAllocType (pctxt, 
               LaneAttributes_Barrier);

            if (pvalue->u.median == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_Barrier (pvalue->u.median);

            stat = asn1PD_LaneAttributes_Barrier (pctxt, pvalue->u.median);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* striping */
         case 5:
            pctxt->level++;

            pvalue->u.striping = rtxMemAllocType (pctxt, 
               LaneAttributes_Striping);

            if (pvalue->u.striping == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_Striping (pvalue->u.striping);

            stat = asn1PD_LaneAttributes_Striping (pctxt, pvalue->u.striping);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* trackedVehicle */
         case 6:
            pctxt->level++;

            pvalue->u.trackedVehicle = rtxMemAllocType (pctxt, 
               LaneAttributes_TrackedVehicle);

            if (pvalue->u.trackedVehicle == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_TrackedVehicle (pvalue->u.trackedVehicle);

            stat = asn1PD_LaneAttributes_TrackedVehicle (pctxt, pvalue->u.trackedVehicle);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* parking */
         case 7:
            pctxt->level++;

            pvalue->u.parking = rtxMemAllocType (pctxt, 
               LaneAttributes_Parking);

            if (pvalue->u.parking == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_Parking (pvalue->u.parking);

            stat = asn1PD_LaneAttributes_Parking (pctxt, pvalue->u.parking);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 9;

      if (pvalue->t < 9) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_LaneAttributes (OSCTXT* pctxt, LaneAttributes* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode directionalUse */
   pctxt->level++;

   stat = asn1PD_LaneDirection (pctxt, &pvalue->directionalUse);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode sharedWith */
   pctxt->level++;

   stat = asn1PD_LaneSharing (pctxt, &pvalue->sharedWith);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode laneType */
   pctxt->level++;

   stat = asn1PD_LaneTypeAttributes (pctxt, &pvalue->laneType);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode regional */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.regionalPresent = 1;

      pvalue->regional = rtxMemAllocType (pctxt, RegionalExtension);

      if (pvalue->regional == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pvalue->regional);

      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pvalue->regional);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_ConnectingLane (OSCTXT* pctxt, ConnectingLane* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode lane */
   pctxt->level++;

   stat = asn1PD_LaneID (pctxt, (LaneID*)&pvalue->lane);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode maneuver */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.maneuverPresent = 1;

      stat = asn1PD_AllowedManeuvers (pctxt, &pvalue->maneuver);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_Connection (OSCTXT* pctxt, Connection* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode connectingLane */
         pctxt->level++;

         stat = asn1PD_ConnectingLane (pctxt, &pvalue->connectingLane);

         pctxt->level--;
         break;

         case 1:
         /* decode remoteIntersection */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.remoteIntersectionPresent = 1;

            pvalue->remoteIntersection = rtxMemAllocType (pctxt, 
               IntersectionReferenceID);

            if (pvalue->remoteIntersection == NULL)
               return RTERR_NOMEM;

            asn1Init_IntersectionReferenceID ((IntersectionReferenceID*)pvalue->remoteIntersection);

            stat = asn1PD_IntersectionReferenceID (pctxt, (IntersectionReferenceID*)pvalue->remoteIntersection);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode signalGroup */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.signalGroupPresent = 1;

            stat = asn1PD_SignalGroupID (pctxt, (SignalGroupID*)&pvalue->signalGroup);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode userClass */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.userClassPresent = 1;

            stat = asn1PD_RestrictionClassID (pctxt, (RestrictionClassID*)&pvalue->userClass);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode connectionID */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.connectionIDPresent = 1;

            stat = asn1PD_LaneConnectionID (pctxt, (LaneConnectionID*)&pvalue->connectionID);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   return (stat);
}

EXTERN int asn1PD_ConnectsToList (OSCTXT* pctxt, ConnectsToList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      Connection* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, Connection);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_Connection (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_Connection (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_OverlayLaneList (OSCTXT* pctxt, OverlayLaneList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 5) {
      return RTERR_CONSVIO;
   }

   /* decode elements */

   pvalue->elem = rtxMemAllocArray (pctxt, pvalue->n, LaneID);
   if (0 == pvalue->elem) return rtxErrGetStatus(pctxt);

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      pctxt->level++;

      stat = asn1PD_LaneID (pctxt, (LaneID*)&pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_GenericLane_regional (OSCTXT* pctxt, GenericLane_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_GenericLane (OSCTXT* pctxt, GenericLane* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[7];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 10; i_++) {
      switch (i_) {
         case 0:
         /* decode laneID */
         pctxt->level++;

         stat = asn1PD_LaneID (pctxt, (LaneID*)&pvalue->laneID);

         pctxt->level--;
         break;

         case 1:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, (DescriptiveName*)&pvalue->name);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode ingressApproach */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.ingressApproachPresent = 1;

            stat = asn1PD_ApproachID (pctxt, (ApproachID*)&pvalue->ingressApproach);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode egressApproach */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.egressApproachPresent = 1;

            stat = asn1PD_ApproachID (pctxt, (ApproachID*)&pvalue->egressApproach);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode laneAttributes */
         pctxt->level++;

         stat = asn1PD_LaneAttributes (pctxt, &pvalue->laneAttributes);

         pctxt->level--;
         break;

         case 5:
         /* decode maneuvers */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.maneuversPresent = 1;

            stat = asn1PD_AllowedManeuvers (pctxt, &pvalue->maneuvers);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode nodeList */
         pctxt->level++;

         pvalue->nodeList = rtxMemAllocType (pctxt, NodeListXY);

         if (pvalue->nodeList == NULL)
            return RTERR_NOMEM;

         asn1Init_NodeListXY ((NodeListXY*)pvalue->nodeList);

         stat = asn1PD_NodeListXY (pctxt, (NodeListXY*)pvalue->nodeList);

         pctxt->level--;
         break;

         case 7:
         /* decode connectsTo */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.connectsToPresent = 1;

            stat = asn1PD_ConnectsToList (pctxt, &pvalue->connectsTo);

            pctxt->level--;
         }
         break;

         case 8:
         /* decode overlays */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.overlaysPresent = 1;

            stat = asn1PD_OverlayLaneList (pctxt, &pvalue->overlays);

            pctxt->level--;
         }
         break;

         case 9:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_GenericLane_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_LaneList (OSCTXT* pctxt, LaneList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      GenericLane* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, GenericLane);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_GenericLane (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_GenericLane (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_SignalControlZone (OSCTXT* pctxt, SignalControlZone* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode zone */
   pctxt->level++;

   pvalue->zone = rtxMemAllocType (pctxt, RegionalExtension);

   if (pvalue->zone == NULL)
      return RTERR_NOMEM;

   asn1Init_RegionalExtension ((RegionalExtension*)pvalue->zone);

   stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pvalue->zone);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_PreemptPriorityList (OSCTXT* pctxt, PreemptPriorityList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SignalControlZone* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, SignalControlZone);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_SignalControlZone (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SignalControlZone (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_IntersectionGeometry_regional (OSCTXT* pctxt, IntersectionGeometry_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_IntersectionGeometry (OSCTXT* pctxt, IntersectionGeometry* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 9; i_++) {
      switch (i_) {
         case 0:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, (DescriptiveName*)&pvalue->name);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode id */
         pctxt->level++;

         pvalue->id = rtxMemAllocType (pctxt, IntersectionReferenceID);

         if (pvalue->id == NULL)
            return RTERR_NOMEM;

         asn1Init_IntersectionReferenceID ((IntersectionReferenceID*)pvalue->id);

         stat = asn1PD_IntersectionReferenceID (pctxt, (IntersectionReferenceID*)pvalue->id);

         pctxt->level--;
         break;

         case 2:
         /* decode revision */
         pctxt->level++;

         stat = asn1PD_Common_MsgCount (pctxt, (Common_MsgCount*)&pvalue->revision);

         pctxt->level--;
         break;

         case 3:
         /* decode refPoint */
         pctxt->level++;

         pvalue->refPoint = rtxMemAllocType (pctxt, Position3D);

         if (pvalue->refPoint == NULL)
            return RTERR_NOMEM;

         asn1Init_Position3D ((Position3D*)pvalue->refPoint);

         stat = asn1PD_Position3D (pctxt, (Position3D*)pvalue->refPoint);

         pctxt->level--;
         break;

         case 4:
         /* decode laneWidth */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.laneWidthPresent = 1;

            stat = asn1PD_LaneWidth (pctxt, (LaneWidth*)&pvalue->laneWidth);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode speedLimits */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.speedLimitsPresent = 1;

            stat = asn1PD_SpeedLimitList (pctxt, (SpeedLimitList*)&pvalue->speedLimits);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode laneSet */
         pctxt->level++;

         stat = asn1PD_LaneList (pctxt, &pvalue->laneSet);

         pctxt->level--;
         break;

         case 7:
         /* decode preemptPriorityData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.preemptPriorityDataPresent = 1;

            stat = asn1PD_PreemptPriorityList (pctxt, &pvalue->preemptPriorityData);

            pctxt->level--;
         }
         break;

         case 8:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_IntersectionGeometry_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            if (i_ < 1) {  /* known element */
               OSUINT32 openTypeLen;
               size_t bitStartOffset, bitLength;
               size_t bitEndOffset, bitsConsumed;

               stat = pd_UnconsLength (pctxt, &openTypeLen);
               if (stat < 0) {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return stat;
               }
               else if (stat == RT_OK_FRAG) {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return RTERR_NOTSUPP;
               }
               bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
               bitLength = openTypeLen * 8;

               if (openTypeLen > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.roadAuthorityIDPresent = 1;
                        pctxt->level++;

                        pvalue->roadAuthorityID = rtxMemAllocType (pctxt, 
                           RoadAuthorityID);

                        if (pvalue->roadAuthorityID == NULL)
                           return RTERR_NOMEM;

                        asn1Init_RoadAuthorityID ((RoadAuthorityID*)pvalue->roadAuthorityID);

                        stat = asn1PD_RoadAuthorityID (pctxt, (RoadAuthorityID*)pvalue->roadAuthorityID);

                        if (stat != 0) break;

                        pctxt->level--;

                        break;

                  }
               }

               if (0 == stat) {
                  bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
                  bitsConsumed = bitEndOffset - bitStartOffset;
                  if (bitsConsumed < bitLength) {
                     stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
                  }
                  else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
               }
            }
            else {
               stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

               if (0 == stat) {
                  pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
                  if (0 != pOpenType) {
                     pOpenType->numocts = openType.numocts;
                     pOpenType->data = openType.data;
                     rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
                  }
                  else stat = RTERR_NOMEM;
               }
               else {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return stat;
               }
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_IntersectionGeometryList (OSCTXT* pctxt, IntersectionGeometryList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      IntersectionGeometry* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, IntersectionGeometry);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_IntersectionGeometry (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_IntersectionGeometry (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_RoadLaneSetList (OSCTXT* pctxt, RoadLaneSetList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      GenericLane* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, GenericLane);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_GenericLane (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_GenericLane (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_RoadSegment_regional (OSCTXT* pctxt, RoadSegment_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_RoadSegment (OSCTXT* pctxt, RoadSegment* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 8; i_++) {
      switch (i_) {
         case 0:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, (DescriptiveName*)&pvalue->name);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode id */
         pctxt->level++;

         pvalue->id = rtxMemAllocType (pctxt, RoadSegmentReferenceID);

         if (pvalue->id == NULL)
            return RTERR_NOMEM;

         asn1Init_RoadSegmentReferenceID ((RoadSegmentReferenceID*)pvalue->id);

         stat = asn1PD_RoadSegmentReferenceID (pctxt, (RoadSegmentReferenceID*)pvalue->id);

         pctxt->level--;
         break;

         case 2:
         /* decode revision */
         pctxt->level++;

         stat = asn1PD_Common_MsgCount (pctxt, (Common_MsgCount*)&pvalue->revision);

         pctxt->level--;
         break;

         case 3:
         /* decode refPoint */
         pctxt->level++;

         pvalue->refPoint = rtxMemAllocType (pctxt, Position3D);

         if (pvalue->refPoint == NULL)
            return RTERR_NOMEM;

         asn1Init_Position3D ((Position3D*)pvalue->refPoint);

         stat = asn1PD_Position3D (pctxt, (Position3D*)pvalue->refPoint);

         pctxt->level--;
         break;

         case 4:
         /* decode laneWidth */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.laneWidthPresent = 1;

            stat = asn1PD_LaneWidth (pctxt, (LaneWidth*)&pvalue->laneWidth);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode speedLimits */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.speedLimitsPresent = 1;

            stat = asn1PD_SpeedLimitList (pctxt, (SpeedLimitList*)&pvalue->speedLimits);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode roadLaneSet */
         pctxt->level++;

         stat = asn1PD_RoadLaneSetList (pctxt, &pvalue->roadLaneSet);

         pctxt->level--;
         break;

         case 7:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_RoadSegment_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RoadSegmentList (OSCTXT* pctxt, RoadSegmentList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RoadSegment* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RoadSegment);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RoadSegment (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RoadSegment (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_DataParameters (OSCTXT* pctxt, DataParameters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode processMethod */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.processMethodPresent = 1;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

            stat = pd_ConstrainedStringEx (pctxt, &pvalue->processMethod, 0, 8, 7, 7);
            if (stat != 0) return stat;

            pctxt->level--;
         }
         break;

         case 1:
         /* decode processAgency */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.processAgencyPresent = 1;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

            stat = pd_ConstrainedStringEx (pctxt, &pvalue->processAgency, 0, 8, 7, 7);
            if (stat != 0) return stat;

            pctxt->level--;
         }
         break;

         case 2:
         /* decode lastCheckedDate */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.lastCheckedDatePresent = 1;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

            stat = pd_ConstrainedStringEx (pctxt, &pvalue->lastCheckedDate, 0, 8, 7, 7);
            if (stat != 0) return stat;

            pctxt->level--;
         }
         break;

         case 3:
         /* decode geoidUsed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.geoidUsedPresent = 1;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

            stat = pd_ConstrainedStringEx (pctxt, &pvalue->geoidUsed, 0, 8, 7, 7);
            if (stat != 0) return stat;

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RestrictionUserType_regional (OSCTXT* pctxt, RestrictionUserType_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_RestrictionUserType (OSCTXT* pctxt, RestrictionUserType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      {
         OSBOOL b_ = 0;
         DEC_BIT (pctxt, &b_);
         ui = b_;
      }
      pvalue->t = ui + 1;

      switch (ui) {
         /* basicType */
         case 0:
            pctxt->level++;

            stat = asn1PD_RestrictionAppliesTo (pctxt, &pvalue->u.basicType);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* regional */
         case 1:
            pctxt->level++;

            pvalue->u.regional = rtxMemAllocType (pctxt, 
               RestrictionUserType_regional);

            if (pvalue->u.regional == NULL)
               return RTERR_NOMEM;

            asn1Init_RestrictionUserType_regional (pvalue->u.regional);

            stat = asn1PD_RestrictionUserType_regional (pctxt, pvalue->u.regional);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_RestrictionUserTypeList (OSCTXT* pctxt, RestrictionUserTypeList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RestrictionUserType* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RestrictionUserType);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RestrictionUserType (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RestrictionUserType (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_RestrictionClassAssignment (OSCTXT* pctxt, RestrictionClassAssignment* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode id */
   pctxt->level++;

   stat = asn1PD_RestrictionClassID (pctxt, (RestrictionClassID*)&pvalue->id);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode users */
   pctxt->level++;

   stat = asn1PD_RestrictionUserTypeList (pctxt, &pvalue->users);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_RestrictionClassList (OSCTXT* pctxt, RestrictionClassList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(254), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RestrictionClassAssignment* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RestrictionClassAssignment);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RestrictionClassAssignment (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RestrictionClassAssignment (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_MapData_regional (OSCTXT* pctxt, MapData_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_MapData (OSCTXT* pctxt, MapData* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[8];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 8; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 9; i_++) {
      switch (i_) {
         case 0:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, (MinuteOfTheYear*)&pvalue->timeStamp);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode msgIssueRevision */
         pctxt->level++;

         stat = asn1PD_Common_MsgCount (pctxt, (Common_MsgCount*)&pvalue->msgIssueRevision);

         pctxt->level--;
         break;

         case 2:
         /* decode layerType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.layerTypePresent = 1;

            stat = asn1PD_LayerType (pctxt, &pvalue->layerType);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode layerID */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.layerIDPresent = 1;

            stat = asn1PD_LayerID (pctxt, &pvalue->layerID);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode intersections */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.intersectionsPresent = 1;

            stat = asn1PD_IntersectionGeometryList (pctxt, &pvalue->intersections);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode roadSegments */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.roadSegmentsPresent = 1;

            stat = asn1PD_RoadSegmentList (pctxt, &pvalue->roadSegments);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode dataParameters */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.dataParametersPresent = 1;

            stat = asn1PD_DataParameters (pctxt, &pvalue->dataParameters);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode restrictionList */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.restrictionListPresent = 1;

            stat = asn1PD_RestrictionClassList (pctxt, &pvalue->restrictionList);

            pctxt->level--;
         }
         break;

         case 8:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_MapData_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

