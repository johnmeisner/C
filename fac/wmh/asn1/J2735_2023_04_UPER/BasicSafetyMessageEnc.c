/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "BasicSafetyMessage.h"
#include "REGION.h"
#include "Common.h"
#include "ProbeDataReport.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PE_PartII_Id (OSCTXT* pctxt, PartII_Id value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  63);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_IsDolly (OSCTXT* pctxt, IsDolly value)
{
   int stat = 0;

   stat = rtxEncBit (pctxt, (OSBOOL)value);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_ObstacleDirection (OSCTXT* pctxt, ObstacleDirection value)
{
   int stat = 0;

   stat = asn1PE_Common_Angle (pctxt, value);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PivotingAllowed (OSCTXT* pctxt, PivotingAllowed value)
{
   int stat = 0;

   stat = rtxEncBit (pctxt, (OSBOOL)value);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SpeedProfileMeasurement (OSCTXT* pctxt, SpeedProfileMeasurement value)
{
   int stat = 0;

   stat = asn1PE_GrossSpeed (pctxt, value);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_TrailerMass (OSCTXT* pctxt, TrailerMass value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  255);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_VertOffset_B07 (OSCTXT* pctxt, VertOffset_B07 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -64,  63);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_PartIIcontent (OSCTXT* pctxt, PartIIcontent* pvalue)
{
   int stat = 0;

   /* encode partII_Id */

   stat = asn1PE_PartII_Id (pctxt, pvalue->partII_Id);
   if (stat != 0) return stat;

   /* encode partII_Value */

   stat = pe_OpenType (pctxt, pvalue->partII_Value.numocts, pvalue->partII_Value.data);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_BasicSafetyMessage_partII (OSCTXT* pctxt, BasicSafetyMessage_partII* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_PartIIcontent (pctxt, ((PartIIcontent*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_BasicSafetyMessage_regional (OSCTXT* pctxt, BasicSafetyMessage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_BasicSafetyMessage (OSCTXT* pctxt, BasicSafetyMessage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.partIIPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode coreData */

   stat = asn1PE_BSMcoreData (pctxt, (BSMcoreData*)pvalue->coreData);
   if (stat != 0) return stat;

   /* encode partII */

   if (pvalue->m.partIIPresent) {
      stat = asn1PE_BasicSafetyMessage_partII (pctxt, &pvalue->partII);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_BasicSafetyMessage_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_DisabledVehicle (OSCTXT* pctxt, DisabledVehicle* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.locationDetailsPresent);

   /* encode statusDetails */

   stat = pe_ConsUnsigned(pctxt, pvalue->statusDetails,  523,  541);
   if (stat != 0) return stat;

   /* encode locationDetails */

   if (pvalue->m.locationDetailsPresent) {
      stat = asn1PE_GenericLocations (pctxt, pvalue->locationDetails);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_EventDescription_description (OSCTXT* pctxt, EventDescription_description* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_ITIScodes (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_EventDescription_regional (OSCTXT* pctxt, EventDescription_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_EventDescription (OSCTXT* pctxt, EventDescription* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.descriptionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.priorityPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headingPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.extentPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode typeEvent */

   stat = asn1PE_ITIScodes (pctxt, pvalue->typeEvent);
   if (stat != 0) return stat;

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = asn1PE_EventDescription_description (pctxt, &pvalue->description);
      if (stat != 0) return stat;
   }

   /* encode priority */

   if (pvalue->m.priorityPresent) {
      stat = asn1PE_Priority (pctxt, (Priority*)pvalue->priority);
      if (stat != 0) return stat;
   }

   /* encode heading */

   if (pvalue->m.headingPresent) {
      stat = asn1PE_HeadingSlice (pctxt, (HeadingSlice*)pvalue->heading);
      if (stat != 0) return stat;
   }

   /* encode extent */

   if (pvalue->m.extentPresent) {
      stat = asn1PE_Extent (pctxt, pvalue->extent);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_EventDescription_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_ObstacleDetection (OSCTXT* pctxt, ObstacleDetection* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.descriptionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.locationDetailsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vertEventPresent);

   /* encode obDist */

   stat = asn1PE_ObstacleDistance (pctxt, pvalue->obDist);
   if (stat != 0) return stat;

   /* encode obDirect */

   stat = asn1PE_ObstacleDirection (pctxt, pvalue->obDirect);
   if (stat != 0) return stat;

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = pe_ConsUnsigned(pctxt, pvalue->description,  523,  541);
      if (stat != 0) return stat;

   }

   /* encode locationDetails */

   if (pvalue->m.locationDetailsPresent) {
      stat = asn1PE_GenericLocations (pctxt, pvalue->locationDetails);
      if (stat != 0) return stat;
   }

   /* encode dateTime */

   stat = asn1PE_DDateTime (pctxt, (DDateTime*)pvalue->dateTime);
   if (stat != 0) return stat;

   /* encode vertEvent */

   if (pvalue->m.vertEventPresent) {
      stat = asn1PE_VerticalAccelerationThreshold (pctxt, (VerticalAccelerationThreshold*)pvalue->vertEvent);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_PivotPointDescription (OSCTXT* pctxt, PivotPointDescription* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode pivotOffset */

   stat = asn1PE_Offset_B11 (pctxt, pvalue->pivotOffset);
   if (stat != 0) return stat;

   /* encode pivotAngle */

   stat = asn1PE_Common_Angle (pctxt, pvalue->pivotAngle);
   if (stat != 0) return stat;

   /* encode pivots */

   stat = asn1PE_PivotingAllowed (pctxt, pvalue->pivots);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RTCMPackage (OSCTXT* pctxt, RTCMPackage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rtcmHeaderPresent);

   /* encode rtcmHeader */

   if (pvalue->m.rtcmHeaderPresent) {
      stat = asn1PE_RTCMheader (pctxt, (RTCMheader*)pvalue->rtcmHeader);
      if (stat != 0) return stat;
   }

   /* encode msgs */

   stat = asn1PE_RTCMmessageList (pctxt, (RTCMmessageList*)pvalue->msgs);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_TrailerHistoryPoint (OSCTXT* pctxt, TrailerHistoryPoint* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.elevationOffsetPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headingPresent);

   /* encode pivotAngle */

   stat = asn1PE_Common_Angle (pctxt, pvalue->pivotAngle);
   if (stat != 0) return stat;

   /* encode timeOffset */

   stat = asn1PE_TimeOffset (pctxt, pvalue->timeOffset);
   if (stat != 0) return stat;

   /* encode positionOffset */

   stat = asn1PE_Node_XY_24b (pctxt, (Node_XY_24b*)pvalue->positionOffset);
   if (stat != 0) return stat;

   /* encode elevationOffset */

   if (pvalue->m.elevationOffsetPresent) {
      stat = asn1PE_VertOffset_B07 (pctxt, pvalue->elevationOffset);
      if (stat != 0) return stat;
   }

   /* encode heading */

   if (pvalue->m.headingPresent) {
      stat = asn1PE_CoarseHeading (pctxt, pvalue->heading);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_TrailerHistoryPointList (OSCTXT* pctxt, TrailerHistoryPointList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(23), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_TrailerHistoryPoint (pctxt, ((TrailerHistoryPoint*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_TrailerUnitDescription (OSCTXT* pctxt, TrailerUnitDescription* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.heightPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.massPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.bumperHeightsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.centerOfGravityPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rearPivotPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rearWheelOffsetPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.elevationOffsetPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.crumbDataPresent);

   /* encode isDolly */

   stat = asn1PE_IsDolly (pctxt, pvalue->isDolly);
   if (stat != 0) return stat;

   /* encode width */

   stat = asn1PE_VehicleWidth (pctxt, pvalue->width);
   if (stat != 0) return stat;

   /* encode length */

   stat = asn1PE_VehicleLength (pctxt, pvalue->length);
   if (stat != 0) return stat;

   /* encode height */

   if (pvalue->m.heightPresent) {
      stat = asn1PE_VehicleHeight (pctxt, pvalue->height);
      if (stat != 0) return stat;
   }

   /* encode mass */

   if (pvalue->m.massPresent) {
      stat = asn1PE_TrailerMass (pctxt, pvalue->mass);
      if (stat != 0) return stat;
   }

   /* encode bumperHeights */

   if (pvalue->m.bumperHeightsPresent) {
      stat = asn1PE_BumperHeights (pctxt, (BumperHeights*)pvalue->bumperHeights);
      if (stat != 0) return stat;
   }

   /* encode centerOfGravity */

   if (pvalue->m.centerOfGravityPresent) {
      stat = asn1PE_VehicleHeight (pctxt, pvalue->centerOfGravity);
      if (stat != 0) return stat;
   }

   /* encode frontPivot */

   stat = asn1PE_PivotPointDescription (pctxt, &pvalue->frontPivot);
   if (stat != 0) return stat;

   /* encode rearPivot */

   if (pvalue->m.rearPivotPresent) {
      stat = asn1PE_PivotPointDescription (pctxt, &pvalue->rearPivot);
      if (stat != 0) return stat;
   }

   /* encode rearWheelOffset */

   if (pvalue->m.rearWheelOffsetPresent) {
      stat = asn1PE_Offset_B12 (pctxt, pvalue->rearWheelOffset);
      if (stat != 0) return stat;
   }

   /* encode positionOffset */

   stat = asn1PE_Node_XY_24b (pctxt, (Node_XY_24b*)pvalue->positionOffset);
   if (stat != 0) return stat;

   /* encode elevationOffset */

   if (pvalue->m.elevationOffsetPresent) {
      stat = asn1PE_VertOffset_B07 (pctxt, pvalue->elevationOffset);
      if (stat != 0) return stat;
   }

   /* encode crumbData */

   if (pvalue->m.crumbDataPresent) {
      stat = asn1PE_TrailerHistoryPointList (pctxt, &pvalue->crumbData);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_TrailerUnitDescriptionList (OSCTXT* pctxt, TrailerUnitDescriptionList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_TrailerUnitDescription (pctxt, ((TrailerUnitDescription*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_TrailerData (OSCTXT* pctxt, TrailerData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode notUsed */

   stat = asn1PE_SSPindex (pctxt, pvalue->notUsed);
   if (stat != 0) return stat;

   /* encode connection */

   stat = asn1PE_PivotPointDescription (pctxt, &pvalue->connection);
   if (stat != 0) return stat;

   /* encode units */

   stat = asn1PE_TrailerUnitDescriptionList (pctxt, &pvalue->units);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_SpecialVehicleExtensions (OSCTXT* pctxt, SpecialVehicleExtensions* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehicleAlertsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.descriptionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.deprecatedPresent);

   /* encode vehicleAlerts */

   if (pvalue->m.vehicleAlertsPresent) {
      stat = asn1PE_EmergencyDetails (pctxt, (EmergencyDetails*)pvalue->vehicleAlerts);
      if (stat != 0) return stat;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = asn1PE_EventDescription (pctxt, &pvalue->description);
      if (stat != 0) return stat;
   }

   /* encode deprecated */

   if (pvalue->m.deprecatedPresent) {
      stat = asn1PE_TrailerData (pctxt, &pvalue->deprecated);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_SpeedProfileMeasurementList (OSCTXT* pctxt, SpeedProfileMeasurementList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(20), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_SpeedProfileMeasurement (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_SpeedProfile (OSCTXT* pctxt, SpeedProfile* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode speedReports */

   stat = asn1PE_SpeedProfileMeasurementList (pctxt, &pvalue->speedReports);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_VehicleData (OSCTXT* pctxt, VehicleData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.heightPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.trailerPresentPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.bumpersPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.massPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pivotPointPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.axlesPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rollAnglePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.deprecatedPresent);

   /* encode height */

   if (pvalue->m.heightPresent) {
      stat = asn1PE_VehicleHeight (pctxt, pvalue->height);
      if (stat != 0) return stat;
   }

   /* encode trailerPresent */

   if (pvalue->m.trailerPresentPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->trailerPresent);
      if (stat != 0) return stat;
   }

   /* encode bumpers */

   if (pvalue->m.bumpersPresent) {
      stat = asn1PE_BumperHeights (pctxt, (BumperHeights*)pvalue->bumpers);
      if (stat != 0) return stat;
   }

   /* encode mass */

   if (pvalue->m.massPresent) {
      stat = asn1PE_VehicleMass (pctxt, pvalue->mass);
      if (stat != 0) return stat;
   }

   /* encode pivotPoint */

   if (pvalue->m.pivotPointPresent) {
      stat = asn1PE_PivotPointDescription (pctxt, &pvalue->pivotPoint);
      if (stat != 0) return stat;
   }

   /* encode axles */

   if (pvalue->m.axlesPresent) {
      stat = asn1PE_Axles (pctxt, (Axles*)pvalue->axles);
      if (stat != 0) return stat;
   }

   /* encode rollAngle */

   if (pvalue->m.rollAnglePresent) {
      stat = pe_ConsInteger(pctxt, pvalue->rollAngle,  -90,  90);
      if (stat != 0) return stat;

   }

   /* encode deprecated */

   if (pvalue->m.deprecatedPresent) {
      stat = asn1PE_TrailerWeight (pctxt, pvalue->deprecated);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_WeatherReport (OSCTXT* pctxt, WeatherReport* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rainRatePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.precipSituationPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.solarRadiationPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.frictionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.roadFrictionPresent);

   /* encode isRaining */

   stat = asn1PE_EssPrecipYesNo (pctxt, pvalue->isRaining);
   if (stat != 0) return stat;

   /* encode rainRate */

   if (pvalue->m.rainRatePresent) {
      stat = asn1PE_EssPrecipRate (pctxt, pvalue->rainRate);
      if (stat != 0) return stat;
   }

   /* encode precipSituation */

   if (pvalue->m.precipSituationPresent) {
      stat = asn1PE_EssPrecipSituation (pctxt, pvalue->precipSituation);
      if (stat != 0) return stat;
   }

   /* encode solarRadiation */

   if (pvalue->m.solarRadiationPresent) {
      stat = asn1PE_EssSolarRadiation (pctxt, pvalue->solarRadiation);
      if (stat != 0) return stat;
   }

   /* encode friction */

   if (pvalue->m.frictionPresent) {
      stat = asn1PE_EssMobileFriction (pctxt, pvalue->friction);
      if (stat != 0) return stat;
   }

   /* encode roadFriction */

   if (pvalue->m.roadFrictionPresent) {
      stat = asn1PE_CoefficientOfFriction (pctxt, pvalue->roadFriction);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_WeatherProbe (OSCTXT* pctxt, WeatherProbe* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.airTempPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.airPressurePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rainRatesPresent);

   /* encode airTemp */

   if (pvalue->m.airTempPresent) {
      stat = asn1PE_AmbientAirTemperature (pctxt, pvalue->airTemp);
      if (stat != 0) return stat;
   }

   /* encode airPressure */

   if (pvalue->m.airPressurePresent) {
      stat = asn1PE_AmbientAirPressure (pctxt, pvalue->airPressure);
      if (stat != 0) return stat;
   }

   /* encode rainRates */

   if (pvalue->m.rainRatesPresent) {
      stat = asn1PE_WiperSet (pctxt, (WiperSet*)pvalue->rainRates);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_SupplementalVehicleExtensions_regional (OSCTXT* pctxt, SupplementalVehicleExtensions_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_SupplementalVehicleExtensions (OSCTXT* pctxt, SupplementalVehicleExtensions* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   extbit = (OSBOOL)(pvalue->m.fhwaVehicleClassPresent ||
   pvalue->m.trailersPresent ||
   pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.classificationPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.classDetailsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehicleDataPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.deprecated1Present);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.deprecated2Present);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.deprecated3Present);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.statusPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.deprecated4Present);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.deprecated5Present);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode classification */

   if (pvalue->m.classificationPresent) {
      stat = asn1PE_BasicVehicleClass (pctxt, pvalue->classification);
      if (stat != 0) return stat;
   }

   /* encode classDetails */

   if (pvalue->m.classDetailsPresent) {
      stat = asn1PE_VehicleClassification (pctxt, (VehicleClassification*)pvalue->classDetails);
      if (stat != 0) return stat;
   }

   /* encode vehicleData */

   if (pvalue->m.vehicleDataPresent) {
      stat = asn1PE_VehicleData (pctxt, &pvalue->vehicleData);
      if (stat != 0) return stat;
   }

   /* encode deprecated1 */

   if (pvalue->m.deprecated1Present) {
      stat = asn1PE_WeatherReport (pctxt, &pvalue->deprecated1);
      if (stat != 0) return stat;
   }

   /* encode deprecated2 */

   if (pvalue->m.deprecated2Present) {
      stat = asn1PE_WeatherProbe (pctxt, &pvalue->deprecated2);
      if (stat != 0) return stat;
   }

   /* encode deprecated3 */

   if (pvalue->m.deprecated3Present) {
      stat = asn1PE_ObstacleDetection (pctxt, &pvalue->deprecated3);
      if (stat != 0) return stat;
   }

   /* encode status */

   if (pvalue->m.statusPresent) {
      stat = asn1PE_DisabledVehicle (pctxt, &pvalue->status);
      if (stat != 0) return stat;
   }

   /* encode deprecated4 */

   if (pvalue->m.deprecated4Present) {
      stat = asn1PE_SpeedProfile (pctxt, &pvalue->deprecated4);
      if (stat != 0) return stat;
   }

   /* encode deprecated5 */

   if (pvalue->m.deprecated5Present) {
      stat = asn1PE_RTCMPackage (pctxt, &pvalue->deprecated5);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_SupplementalVehicleExtensions_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count + 2);
      if (stat != 0) return stat;

      /* encode optional bits */

      rtxEncBit (pctxt, (OSBOOL)pvalue->m.fhwaVehicleClassPresent);

      rtxEncBit (pctxt, (OSBOOL)pvalue->m.trailersPresent);

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->m.fhwaVehicleClassPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return stat;

         stat = asn1PE_RptVehicleClass (pctxt, pvalue->fhwaVehicleClass);
         if (stat != 0) return stat;

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return stat;
      }

      if (pvalue->m.trailersPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return stat;

         stat = asn1PE_TrailersJ2945Slash1B (pctxt, (TrailersJ2945Slash1B*)&pvalue->trailers);
         if (stat != 0) return stat;

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return stat;
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

