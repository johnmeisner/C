/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "TravelerInformation.h"
#include "REGION.h"
#include "Common.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PD_DirectionOfUse (OSCTXT* pctxt, DirectionOfUse* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 2);
   return stat;
}

EXTERN int asn1PD_DistanceUnits (OSCTXT* pctxt, DistanceUnits* pvalue)
{
   int stat = rtxDecBitsToByte (pctxt, pvalue, 3);
   return stat;
}

EXTERN int asn1PD_ITIStextPhrase (OSCTXT* pctxt, ITIStextPhrase* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_ConstrainedStringEx (pctxt, pvalue, 0, 8, 7, 7);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_MinutesDuration (OSCTXT* pctxt, MinutesDuration* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 32000) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_MsgCRC (OSCTXT* pctxt, MsgCRC* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_MUTCDCode (OSCTXT* pctxt, MUTCDCode* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(6));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 6) {
         return RTERR_CONSVIO;
      }
   }

   return (stat);
}

EXTERN int asn1PD_NodeAttributeLL (OSCTXT* pctxt, NodeAttributeLL* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(11));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 11) {
         return RTERR_CONSVIO;
      }
   }

   return (stat);
}

EXTERN int asn1PD_OffsetLL_B12 (OSCTXT* pctxt, OffsetLL_B12* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 4096, range_bitcnt = 12 */
   stat = pd_ConsInt16(pctxt, pvalue, -2048, 2047);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_OffsetLL_B14 (OSCTXT* pctxt, OffsetLL_B14* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 16384, range_bitcnt = 14 */
   stat = pd_ConsInt16(pctxt, pvalue, -8192, 8191);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_OffsetLL_B16 (OSCTXT* pctxt, OffsetLL_B16* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   /* range_value = 65536, range_bitcnt = 16 */
   stat = pd_ConsInt16(pctxt, pvalue, -32768, 32767);
   if (stat != 0) return stat;
   return stat;
}

EXTERN int asn1PD_OffsetLL_B22 (OSCTXT* pctxt, OffsetLL_B22* pvalue)
{
   return pd_ConsInteger(pctxt, pvalue,  -2097152,  2097151);
}

EXTERN int asn1PD_OffsetLL_B24 (OSCTXT* pctxt, OffsetLL_B24* pvalue)
{
   return pd_ConsInteger(pctxt, pvalue,  -8388608,  8388607);
}

EXTERN int asn1PD_Radius_B12 (OSCTXT* pctxt, Radius_B12* pvalue)
{
   int stat;

   PD_BYTE_ALIGN(pctxt);
   stat = rtxDecBitsToUInt16(pctxt, pvalue, pctxt->buffer.aligned ? 16 : 12);
   if (stat != 0) return stat;

   if (*pvalue > 4095) {
      return RTERR_CONSVIO;
   }

   return stat;
}

EXTERN int asn1PD_SegmentAttributeLL (OSCTXT* pctxt, SegmentAttributeLL* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(37));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }

      if (*pvalue > 37) {
         return RTERR_CONSVIO;
      }
   }

   return (stat);
}

EXTERN int asn1PD_SignPrority (OSCTXT* pctxt, SignPrority* pvalue)
{
   return rtxDecBitsToByte(pctxt, pvalue, 3);
}

EXTERN int asn1PD_TravelerInfoType (OSCTXT* pctxt, TravelerInfoType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber(pctxt, NULL);
      if (stat != 0) return stat;

      *pvalue = (OSUINT8)-1;
   }
   else {
      {
         OSUINT32 tmpval;
         stat = pd_ConsUnsigned (pctxt, &tmpval, 0, OSUINTCONST(3));
         if (stat != 0) return stat;
         *pvalue = (OSUINT8)tmpval;
      }
   }

   return (stat);
}

EXTERN int asn1PD_UniqueMSGID (OSCTXT* pctxt, UniqueMSGID* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(9), OSUINTCONST(9), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_URL_Base (OSCTXT* pctxt, URL_Base* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(45), 0, 0);

   stat = pd_ConstrainedStringEx (pctxt, pvalue, 0, 8, 7, 7);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_URL_Short (OSCTXT* pctxt, URL_Short* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(15), 0, 0);

   stat = pd_ConstrainedStringEx (pctxt, pvalue, 0, 8, 7, 7);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PD_Zoom (OSCTXT* pctxt, Zoom* pvalue)
{
   return rtxDecBitsToByte(pctxt, pvalue, 4);
}

EXTERN int asn1PD_RoadSignID (OSCTXT* pctxt, RoadSignID* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode position */
   pctxt->level++;

   pvalue->position = rtxMemAllocType (pctxt, Position3D);

   if (pvalue->position == NULL)
      return RTERR_NOMEM;

   asn1Init_Position3D ((Position3D*)pvalue->position);

   stat = asn1PD_Position3D (pctxt, (Position3D*)pvalue->position);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode viewAngle */
   pctxt->level++;

   pvalue->viewAngle = rtxMemAllocType (pctxt, HeadingSlice);

   if (pvalue->viewAngle == NULL)
      return RTERR_NOMEM;

   asn1Init_HeadingSlice ((HeadingSlice*)pvalue->viewAngle);

   stat = asn1PD_HeadingSlice (pctxt, (HeadingSlice*)pvalue->viewAngle);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode mutcdCode */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.mutcdCodePresent = 1;

      stat = asn1PD_MUTCDCode (pctxt, &pvalue->mutcdCode);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode crc */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.crcPresent = 1;

      stat = asn1PD_MsgCRC (pctxt, &pvalue->crc);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_TravelerDataFrame_msgId (OSCTXT* pctxt, TravelerDataFrame_msgId* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   {
      OSBOOL b_ = 0;
      DEC_BIT (pctxt, &b_);
      ui = b_;
   }
   pvalue->t = ui + 1;

   switch (ui) {
      /* furtherInfoID */
      case 0:
         pctxt->level++;

         pvalue->u.furtherInfoID = rtxMemAllocType (pctxt, FurtherInfoID);

         if (pvalue->u.furtherInfoID == NULL)
            return RTERR_NOMEM;

         asn1Init_FurtherInfoID ((FurtherInfoID*)pvalue->u.furtherInfoID);

         stat = asn1PD_FurtherInfoID (pctxt, (FurtherInfoID*)pvalue->u.furtherInfoID);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* roadSignID */
      case 1:
         pctxt->level++;

         pvalue->u.roadSignID = rtxMemAllocType (pctxt, RoadSignID);

         if (pvalue->u.roadSignID == NULL)
            return RTERR_NOMEM;

         asn1Init_RoadSignID (pvalue->u.roadSignID);

         stat = asn1PD_RoadSignID (pctxt, pvalue->u.roadSignID);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_Node_LL_24B (OSCTXT* pctxt, Node_LL_24B* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode lon */
   pctxt->level++;

   stat = asn1PD_OffsetLL_B12 (pctxt, &pvalue->lon);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode lat */
   pctxt->level++;

   stat = asn1PD_OffsetLL_B12 (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_Node_LL_28B (OSCTXT* pctxt, Node_LL_28B* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode lon */
   pctxt->level++;

   stat = asn1PD_OffsetLL_B14 (pctxt, &pvalue->lon);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode lat */
   pctxt->level++;

   stat = asn1PD_OffsetLL_B14 (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_Node_LL_32B (OSCTXT* pctxt, Node_LL_32B* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode lon */
   pctxt->level++;

   stat = asn1PD_OffsetLL_B16 (pctxt, &pvalue->lon);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode lat */
   pctxt->level++;

   stat = asn1PD_OffsetLL_B16 (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_Node_LL_36B (OSCTXT* pctxt, Node_LL_36B* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode lon */
   pctxt->level++;

   stat = asn1PD_OffsetLL_B18 (pctxt, (OffsetLL_B18*)&pvalue->lon);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode lat */
   pctxt->level++;

   stat = asn1PD_OffsetLL_B18 (pctxt, (OffsetLL_B18*)&pvalue->lat);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_Node_LL_44B (OSCTXT* pctxt, Node_LL_44B* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode lon */
   pctxt->level++;

   stat = asn1PD_OffsetLL_B22 (pctxt, &pvalue->lon);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode lat */
   pctxt->level++;

   stat = asn1PD_OffsetLL_B22 (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_Node_LL_48B (OSCTXT* pctxt, Node_LL_48B* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode lon */
   pctxt->level++;

   stat = asn1PD_OffsetLL_B24 (pctxt, &pvalue->lon);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode lat */
   pctxt->level++;

   stat = asn1PD_OffsetLL_B24 (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_NodeOffsetPointLL (OSCTXT* pctxt, NodeOffsetPointLL* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = rtxDecBits(pctxt, &ui, 3);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* node_LL1 */
      case 0:
         pctxt->level++;

         pvalue->u.node_LL1 = rtxMemAllocTypeZ (pctxt, Node_LL_24B);

         if (pvalue->u.node_LL1 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LL_24B (pctxt, pvalue->u.node_LL1);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* node_LL2 */
      case 1:
         pctxt->level++;

         pvalue->u.node_LL2 = rtxMemAllocTypeZ (pctxt, Node_LL_28B);

         if (pvalue->u.node_LL2 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LL_28B (pctxt, pvalue->u.node_LL2);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* node_LL3 */
      case 2:
         pctxt->level++;

         pvalue->u.node_LL3 = rtxMemAllocTypeZ (pctxt, Node_LL_32B);

         if (pvalue->u.node_LL3 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LL_32B (pctxt, pvalue->u.node_LL3);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* node_LL4 */
      case 3:
         pctxt->level++;

         pvalue->u.node_LL4 = rtxMemAllocTypeZ (pctxt, Node_LL_36B);

         if (pvalue->u.node_LL4 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LL_36B (pctxt, pvalue->u.node_LL4);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* node_LL5 */
      case 4:
         pctxt->level++;

         pvalue->u.node_LL5 = rtxMemAllocTypeZ (pctxt, Node_LL_44B);

         if (pvalue->u.node_LL5 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LL_44B (pctxt, pvalue->u.node_LL5);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* node_LL6 */
      case 5:
         pctxt->level++;

         pvalue->u.node_LL6 = rtxMemAllocTypeZ (pctxt, Node_LL_48B);

         if (pvalue->u.node_LL6 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LL_48B (pctxt, pvalue->u.node_LL6);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* node_LatLon */
      case 6:
         pctxt->level++;

         pvalue->u.node_LatLon = rtxMemAllocTypeZ (pctxt, Node_LLmD_64b);

         if (pvalue->u.node_LatLon == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LLmD_64b (pctxt, (Node_LLmD_64b*)pvalue->u.node_LatLon);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* regional */
      case 7:
         pctxt->level++;

         pvalue->u.regional = rtxMemAllocType (pctxt, RegionalExtension);

         if (pvalue->u.regional == NULL)
            return RTERR_NOMEM;

         asn1Init_RegionalExtension ((RegionalExtension*)pvalue->u.regional);

         stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pvalue->u.regional);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_NodeAttributeLLList (OSCTXT* pctxt, NodeAttributeLLList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 8) {
      return RTERR_CONSVIO;
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      pctxt->level++;

      stat = asn1PD_NodeAttributeLL (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_SegmentAttributeLLList (OSCTXT* pctxt, SegmentAttributeLLList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 8) {
      return RTERR_CONSVIO;
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      pctxt->level++;

      stat = asn1PD_SegmentAttributeLL (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_NodeAttributeSetLL_regional (OSCTXT* pctxt, NodeAttributeSetLL_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_NodeAttributeSetLL (OSCTXT* pctxt, NodeAttributeSetLL* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[7];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode localNode */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.localNodePresent = 1;

            stat = asn1PD_NodeAttributeLLList (pctxt, &pvalue->localNode);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode disabled */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.disabledPresent = 1;

            stat = asn1PD_SegmentAttributeLLList (pctxt, &pvalue->disabled);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode enabled */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.enabledPresent = 1;

            stat = asn1PD_SegmentAttributeLLList (pctxt, &pvalue->enabled);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode data */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.dataPresent = 1;

            stat = asn1PD_LaneDataAttributeList (pctxt, (LaneDataAttributeList*)&pvalue->data);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode dWidth */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.dWidthPresent = 1;

            stat = asn1PD_Offset_B10 (pctxt, (Offset_B10*)&pvalue->dWidth);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode dElevation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.dElevationPresent = 1;

            stat = asn1PD_Offset_B10 (pctxt, (Offset_B10*)&pvalue->dElevation);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_NodeAttributeSetLL_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NodeLL (OSCTXT* pctxt, NodeLL* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode delta */
   pctxt->level++;

   stat = asn1PD_NodeOffsetPointLL (pctxt, &pvalue->delta);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode attributes */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.attributesPresent = 1;

      stat = asn1PD_NodeAttributeSetLL (pctxt, &pvalue->attributes);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_NodeSetLL (OSCTXT* pctxt, NodeSetLL* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(63), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NodeLL* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, NodeLL);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_NodeLL (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NodeLL (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_NodeListLL (OSCTXT* pctxt, NodeListLL* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      ui = 0;
      pvalue->t = ui + 1;

      switch (ui) {
         /* nodes */
         case 0:
            pctxt->level++;

            pvalue->u.nodes = rtxMemAllocType (pctxt, NodeSetLL);

            if (pvalue->u.nodes == NULL)
               return RTERR_NOMEM;

            asn1Init_NodeSetLL (pvalue->u.nodes);

            stat = asn1PD_NodeSetLL (pctxt, pvalue->u.nodes);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_OffsetSystem_offset (OSCTXT* pctxt, OffsetSystem_offset* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   {
      OSBOOL b_ = 0;
      DEC_BIT (pctxt, &b_);
      ui = b_;
   }
   pvalue->t = ui + 1;

   switch (ui) {
      /* xy */
      case 0:
         pctxt->level++;

         pvalue->u.xy = rtxMemAllocType (pctxt, NodeListXY);

         if (pvalue->u.xy == NULL)
            return RTERR_NOMEM;

         asn1Init_NodeListXY ((NodeListXY*)pvalue->u.xy);

         stat = asn1PD_NodeListXY (pctxt, (NodeListXY*)pvalue->u.xy);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* ll */
      case 1:
         pctxt->level++;

         pvalue->u.ll = rtxMemAllocType (pctxt, NodeListLL);

         if (pvalue->u.ll == NULL)
            return RTERR_NOMEM;

         asn1Init_NodeListLL (pvalue->u.ll);

         stat = asn1PD_NodeListLL (pctxt, pvalue->u.ll);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_OffsetSystem (OSCTXT* pctxt, OffsetSystem* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode scale */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.scalePresent = 1;

      stat = asn1PD_Zoom (pctxt, &pvalue->scale);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode offset */
   pctxt->level++;

   stat = asn1PD_OffsetSystem_offset (pctxt, &pvalue->offset);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_Circle (OSCTXT* pctxt, Circle* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode center */
   pctxt->level++;

   pvalue->center = rtxMemAllocType (pctxt, Position3D);

   if (pvalue->center == NULL)
      return RTERR_NOMEM;

   asn1Init_Position3D ((Position3D*)pvalue->center);

   stat = asn1PD_Position3D (pctxt, (Position3D*)pvalue->center);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode radius */
   pctxt->level++;

   stat = asn1PD_Radius_B12 (pctxt, &pvalue->radius);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode units */
   pctxt->level++;

   stat = asn1PD_DistanceUnits (pctxt, &pvalue->units);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_GeometricProjection_regional (OSCTXT* pctxt, GeometricProjection_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_GeometricProjection (OSCTXT* pctxt, GeometricProjection* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode direction */
         pctxt->level++;

         pvalue->direction = rtxMemAllocType (pctxt, HeadingSlice);

         if (pvalue->direction == NULL)
            return RTERR_NOMEM;

         asn1Init_HeadingSlice ((HeadingSlice*)pvalue->direction);

         stat = asn1PD_HeadingSlice (pctxt, (HeadingSlice*)pvalue->direction);

         pctxt->level--;
         break;

         case 1:
         /* decode extent */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.extentPresent = 1;

            stat = asn1PD_Extent (pctxt, (Extent*)&pvalue->extent);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode laneWidth */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.laneWidthPresent = 1;

            stat = asn1PD_LaneWidth (pctxt, (LaneWidth*)&pvalue->laneWidth);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode circle */
         pctxt->level++;

         stat = asn1PD_Circle (pctxt, &pvalue->circle);

         pctxt->level--;
         break;

         case 4:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_GeometricProjection_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_ShapePointSet (OSCTXT* pctxt, ShapePointSet* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode anchor */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.anchorPresent = 1;

            pvalue->anchor = rtxMemAllocType (pctxt, Position3D);

            if (pvalue->anchor == NULL)
               return RTERR_NOMEM;

            asn1Init_Position3D ((Position3D*)pvalue->anchor);

            stat = asn1PD_Position3D (pctxt, (Position3D*)pvalue->anchor);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode laneWidth */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.laneWidthPresent = 1;

            stat = asn1PD_LaneWidth (pctxt, (LaneWidth*)&pvalue->laneWidth);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode directionality */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.directionalityPresent = 1;

            stat = asn1PD_DirectionOfUse (pctxt, &pvalue->directionality);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode nodeList */
         pctxt->level++;

         pvalue->nodeList = rtxMemAllocType (pctxt, NodeListXY);

         if (pvalue->nodeList == NULL)
            return RTERR_NOMEM;

         asn1Init_NodeListXY ((NodeListXY*)pvalue->nodeList);

         stat = asn1PD_NodeListXY (pctxt, (NodeListXY*)pvalue->nodeList);

         pctxt->level--;
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_RegionOffsets (OSCTXT* pctxt, RegionOffsets* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode xOffset */
   pctxt->level++;

   stat = asn1PD_OffsetLL_B16 (pctxt, &pvalue->xOffset);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode yOffset */
   pctxt->level++;

   stat = asn1PD_OffsetLL_B16 (pctxt, &pvalue->yOffset);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode zOffset */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.zOffsetPresent = 1;

      stat = asn1PD_OffsetLL_B16 (pctxt, &pvalue->zOffset);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_RegionList (OSCTXT* pctxt, RegionList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionOffsets* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionOffsets);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionOffsets (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionOffsets (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_RegionPointSet (OSCTXT* pctxt, RegionPointSet* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode anchor */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.anchorPresent = 1;

      pvalue->anchor = rtxMemAllocType (pctxt, Position3D);

      if (pvalue->anchor == NULL)
         return RTERR_NOMEM;

      asn1Init_Position3D ((Position3D*)pvalue->anchor);

      stat = asn1PD_Position3D (pctxt, (Position3D*)pvalue->anchor);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode scale */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.scalePresent = 1;

      stat = asn1PD_Zoom (pctxt, &pvalue->scale);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode nodeList */
   pctxt->level++;

   stat = asn1PD_RegionList (pctxt, &pvalue->nodeList);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_ValidRegion_area (OSCTXT* pctxt, ValidRegion_area* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = rtxDecBits(pctxt, &ui, 2);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* shapePointSet */
      case 0:
         pctxt->level++;

         pvalue->u.shapePointSet = rtxMemAllocType (pctxt, ShapePointSet);

         if (pvalue->u.shapePointSet == NULL)
            return RTERR_NOMEM;

         asn1Init_ShapePointSet (pvalue->u.shapePointSet);

         stat = asn1PD_ShapePointSet (pctxt, pvalue->u.shapePointSet);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* circle */
      case 1:
         pctxt->level++;

         pvalue->u.circle = rtxMemAllocType (pctxt, Circle);

         if (pvalue->u.circle == NULL)
            return RTERR_NOMEM;

         asn1Init_Circle (pvalue->u.circle);

         stat = asn1PD_Circle (pctxt, pvalue->u.circle);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* regionPointSet */
      case 2:
         pctxt->level++;

         pvalue->u.regionPointSet = rtxMemAllocType (pctxt, RegionPointSet);

         if (pvalue->u.regionPointSet == NULL)
            return RTERR_NOMEM;

         asn1Init_RegionPointSet (pvalue->u.regionPointSet);

         stat = asn1PD_RegionPointSet (pctxt, pvalue->u.regionPointSet);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_ValidRegion (OSCTXT* pctxt, ValidRegion* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode direction */
   pctxt->level++;

   pvalue->direction = rtxMemAllocType (pctxt, HeadingSlice);

   if (pvalue->direction == NULL)
      return RTERR_NOMEM;

   asn1Init_HeadingSlice ((HeadingSlice*)pvalue->direction);

   stat = asn1PD_HeadingSlice (pctxt, (HeadingSlice*)pvalue->direction);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode extent */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.extentPresent = 1;

      stat = asn1PD_Extent (pctxt, (Extent*)&pvalue->extent);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode area */
   pctxt->level++;

   stat = asn1PD_ValidRegion_area (pctxt, &pvalue->area);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_GeographicalPath_description (OSCTXT* pctxt, GeographicalPath_description* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      stat = rtxDecBits(pctxt, &ui, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      switch (ui) {
         /* path */
         case 0:
            pctxt->level++;

            pvalue->u.path = rtxMemAllocType (pctxt, OffsetSystem);

            if (pvalue->u.path == NULL)
               return RTERR_NOMEM;

            asn1Init_OffsetSystem (pvalue->u.path);

            stat = asn1PD_OffsetSystem (pctxt, pvalue->u.path);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* geometry */
         case 1:
            pctxt->level++;

            pvalue->u.geometry = rtxMemAllocType (pctxt, GeometricProjection);

            if (pvalue->u.geometry == NULL)
               return RTERR_NOMEM;

            asn1Init_GeometricProjection (pvalue->u.geometry);

            stat = asn1PD_GeometricProjection (pctxt, pvalue->u.geometry);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         /* oldRegion */
         case 2:
            pctxt->level++;

            pvalue->u.oldRegion = rtxMemAllocType (pctxt, ValidRegion);

            if (pvalue->u.oldRegion == NULL)
               return RTERR_NOMEM;

            asn1Init_ValidRegion (pvalue->u.oldRegion);

            stat = asn1PD_ValidRegion (pctxt, pvalue->u.oldRegion);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_GeographicalPath_regional (OSCTXT* pctxt, GeographicalPath_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_GeographicalPath (OSCTXT* pctxt, GeographicalPath* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[9];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 9; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 9; i_++) {
      switch (i_) {
         case 0:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, (DescriptiveName*)&pvalue->name);

            pctxt->level--;
         }
         break;

         case 1:
         /* decode id */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.idPresent = 1;

            pvalue->id = rtxMemAllocType (pctxt, RoadSegmentReferenceID);

            if (pvalue->id == NULL)
               return RTERR_NOMEM;

            asn1Init_RoadSegmentReferenceID ((RoadSegmentReferenceID*)pvalue->id);

            stat = asn1PD_RoadSegmentReferenceID (pctxt, (RoadSegmentReferenceID*)pvalue->id);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode anchor */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.anchorPresent = 1;

            pvalue->anchor = rtxMemAllocType (pctxt, Position3D);

            if (pvalue->anchor == NULL)
               return RTERR_NOMEM;

            asn1Init_Position3D ((Position3D*)pvalue->anchor);

            stat = asn1PD_Position3D (pctxt, (Position3D*)pvalue->anchor);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode laneWidth */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.laneWidthPresent = 1;

            stat = asn1PD_LaneWidth (pctxt, (LaneWidth*)&pvalue->laneWidth);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode directionality */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.directionalityPresent = 1;

            stat = asn1PD_DirectionOfUse (pctxt, &pvalue->directionality);

            pctxt->level--;
         }
         break;

         case 5:
         /* decode closedPath */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.closedPathPresent = 1;

            rtxDecBit(pctxt, &pvalue->closedPath);

            pctxt->level--;
         }
         break;

         case 6:
         /* decode direction */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.directionPresent = 1;

            pvalue->direction = rtxMemAllocType (pctxt, HeadingSlice);

            if (pvalue->direction == NULL)
               return RTERR_NOMEM;

            asn1Init_HeadingSlice ((HeadingSlice*)pvalue->direction);

            stat = asn1PD_HeadingSlice (pctxt, (HeadingSlice*)pvalue->direction);

            pctxt->level--;
         }
         break;

         case 7:
         /* decode description */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.descriptionPresent = 1;

            stat = asn1PD_GeographicalPath_description (pctxt, &pvalue->description);

            pctxt->level--;
         }
         break;

         case 8:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_GeographicalPath_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_TravelerDataFrame_regions (OSCTXT* pctxt, TravelerDataFrame_regions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      GeographicalPath* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, GeographicalPath);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_GeographicalPath (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_GeographicalPath (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_WorkZone_element_item (OSCTXT* pctxt, WorkZone_element_item* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   {
      OSBOOL b_ = 0;
      DEC_BIT (pctxt, &b_);
      ui = b_;
   }
   pvalue->t = ui + 1;

   switch (ui) {
      /* itis */
      case 0:
         pctxt->level++;

         stat = asn1PD_ITIScodes (pctxt, &pvalue->u.itis);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* text */
      case 1:
         pctxt->level++;

         stat = asn1PD_ITIStextPhrase (pctxt, &pvalue->u.text);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_WorkZone_element (OSCTXT* pctxt, WorkZone_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode item */
   pctxt->level++;

   stat = asn1PD_WorkZone_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_WorkZone (OSCTXT* pctxt, WorkZone* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      WorkZone_element* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, WorkZone_element);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_WorkZone_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_WorkZone_element (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_GenericSignage_element_item (OSCTXT* pctxt, GenericSignage_element_item* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   {
      OSBOOL b_ = 0;
      DEC_BIT (pctxt, &b_);
      ui = b_;
   }
   pvalue->t = ui + 1;

   switch (ui) {
      /* itis */
      case 0:
         pctxt->level++;

         stat = asn1PD_ITIScodes (pctxt, &pvalue->u.itis);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* text */
      case 1:
         pctxt->level++;

         stat = asn1PD_ITIStextPhrase (pctxt, &pvalue->u.text);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_GenericSignage_element (OSCTXT* pctxt, GenericSignage_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode item */
   pctxt->level++;

   stat = asn1PD_GenericSignage_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_GenericSignage (OSCTXT* pctxt, GenericSignage* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      GenericSignage_element* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, GenericSignage_element);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_GenericSignage_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_GenericSignage_element (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_SpeedLimit_element_item (OSCTXT* pctxt, SpeedLimit_element_item* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   {
      OSBOOL b_ = 0;
      DEC_BIT (pctxt, &b_);
      ui = b_;
   }
   pvalue->t = ui + 1;

   switch (ui) {
      /* itis */
      case 0:
         pctxt->level++;

         stat = asn1PD_ITIScodes (pctxt, &pvalue->u.itis);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* text */
      case 1:
         pctxt->level++;

         stat = asn1PD_ITIStextPhrase (pctxt, &pvalue->u.text);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_SpeedLimit_element (OSCTXT* pctxt, SpeedLimit_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode item */
   pctxt->level++;

   stat = asn1PD_SpeedLimit_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_SpeedLimit (OSCTXT* pctxt, SpeedLimit* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SpeedLimit_element* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, SpeedLimit_element);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_SpeedLimit_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SpeedLimit_element (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_ExitService_element_item (OSCTXT* pctxt, ExitService_element_item* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   {
      OSBOOL b_ = 0;
      DEC_BIT (pctxt, &b_);
      ui = b_;
   }
   pvalue->t = ui + 1;

   switch (ui) {
      /* itis */
      case 0:
         pctxt->level++;

         stat = asn1PD_ITIScodes (pctxt, &pvalue->u.itis);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* text */
      case 1:
         pctxt->level++;

         stat = asn1PD_ITIStextPhrase (pctxt, &pvalue->u.text);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_ExitService_element (OSCTXT* pctxt, ExitService_element* pvalue)
{
   int stat = 0;

   /* decode root elements */
   /* decode item */
   pctxt->level++;

   stat = asn1PD_ExitService_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   pctxt->level--;

   return (stat);
}

EXTERN int asn1PD_ExitService (OSCTXT* pctxt, ExitService* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ExitService_element* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, ExitService_element);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_ExitService_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ExitService_element (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_TravelerDataFrame_content (OSCTXT* pctxt, TravelerDataFrame_content* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = rtxDecBits(pctxt, &ui, 3);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   switch (ui) {
      /* advisory */
      case 0:
         pctxt->level++;

         pvalue->u.advisory = rtxMemAllocType (pctxt, ITIScodesAndText);

         if (pvalue->u.advisory == NULL)
            return RTERR_NOMEM;

         asn1Init_ITIScodesAndText (pvalue->u.advisory);

         stat = asn1PD_ITIScodesAndText (pctxt, pvalue->u.advisory);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* workZone */
      case 1:
         pctxt->level++;

         pvalue->u.workZone = rtxMemAllocType (pctxt, WorkZone);

         if (pvalue->u.workZone == NULL)
            return RTERR_NOMEM;

         asn1Init_WorkZone (pvalue->u.workZone);

         stat = asn1PD_WorkZone (pctxt, pvalue->u.workZone);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* genericSign */
      case 2:
         pctxt->level++;

         pvalue->u.genericSign = rtxMemAllocType (pctxt, GenericSignage);

         if (pvalue->u.genericSign == NULL)
            return RTERR_NOMEM;

         asn1Init_GenericSignage (pvalue->u.genericSign);

         stat = asn1PD_GenericSignage (pctxt, pvalue->u.genericSign);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* speedLimit */
      case 3:
         pctxt->level++;

         pvalue->u.speedLimit = rtxMemAllocType (pctxt, SpeedLimit);

         if (pvalue->u.speedLimit == NULL)
            return RTERR_NOMEM;

         asn1Init_SpeedLimit (pvalue->u.speedLimit);

         stat = asn1PD_SpeedLimit (pctxt, pvalue->u.speedLimit);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      /* exitService */
      case 4:
         pctxt->level++;

         pvalue->u.exitService = rtxMemAllocType (pctxt, ExitService);

         if (pvalue->u.exitService == NULL)
            return RTERR_NOMEM;

         asn1Init_ExitService (pvalue->u.exitService);

         stat = asn1PD_ExitService (pctxt, pvalue->u.exitService);
         if (stat != 0) return stat;

         pctxt->level--;

         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PD_TravelerDataFrameNewPartIIIContent (OSCTXT* pctxt, TravelerDataFrameNewPartIIIContent* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   if (!extbit) {
      ui = 0;
      pvalue->t = ui + 1;

      switch (ui) {
         /* frictionInfo */
         case 0:
            pctxt->level++;

            pvalue->u.frictionInfo = rtxMemAllocType (pctxt, 
               FrictionInformation);

            if (pvalue->u.frictionInfo == NULL)
               return RTERR_NOMEM;

            asn1Init_FrictionInformation ((FrictionInformation*)pvalue->u.frictionInfo);

            stat = asn1PD_FrictionInformation (pctxt, (FrictionInformation*)pvalue->u.frictionInfo);
            if (stat != 0) return stat;

            pctxt->level--;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return RTERR_INVOPT;

      PD_BYTE_ALIGN(pctxt);

      pctxt->level++;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      pctxt->level--;

   }

   return (stat);
}

EXTERN int asn1PD_TravelerDataFrame (OSCTXT* pctxt, TravelerDataFrame* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   /* decode notUsed */
   pctxt->level++;

   stat = asn1PD_SSPindex (pctxt, (SSPindex*)&pvalue->notUsed);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode frameType */
   pctxt->level++;

   stat = asn1PD_TravelerInfoType (pctxt, &pvalue->frameType);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode msgId */
   pctxt->level++;

   stat = asn1PD_TravelerDataFrame_msgId (pctxt, &pvalue->msgId);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode startYear */
   if (optbits[0]) {
      pctxt->level++;

      pvalue->m.startYearPresent = 1;

      stat = asn1PD_DYear (pctxt, (DYear*)&pvalue->startYear);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode startTime */
   pctxt->level++;

   stat = asn1PD_MinuteOfTheYear (pctxt, (MinuteOfTheYear*)&pvalue->startTime);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode durationTime */
   pctxt->level++;

   stat = asn1PD_MinutesDuration (pctxt, &pvalue->durationTime);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode priority */
   pctxt->level++;

   stat = asn1PD_SignPrority (pctxt, &pvalue->priority);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode notUsed1 */
   pctxt->level++;

   stat = asn1PD_SSPindex (pctxt, (SSPindex*)&pvalue->notUsed1);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode regions */
   pctxt->level++;

   stat = asn1PD_TravelerDataFrame_regions (pctxt, &pvalue->regions);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode notUsed2 */
   pctxt->level++;

   stat = asn1PD_SSPindex (pctxt, (SSPindex*)&pvalue->notUsed2);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode notUsed3 */
   pctxt->level++;

   stat = asn1PD_SSPindex (pctxt, (SSPindex*)&pvalue->notUsed3);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode content */
   pctxt->level++;

   stat = asn1PD_TravelerDataFrame_content (pctxt, &pvalue->content);
   if (stat != 0) return stat;

   pctxt->level--;

   /* decode url */
   if (optbits[1]) {
      pctxt->level++;

      pvalue->m.urlPresent = 1;

      stat = asn1PD_URL_Short (pctxt, &pvalue->url);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            if (i_ < 1) {  /* known element */
               OSUINT32 openTypeLen;
               size_t bitStartOffset, bitLength;
               size_t bitEndOffset, bitsConsumed;

               stat = pd_UnconsLength (pctxt, &openTypeLen);
               if (stat < 0) {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return stat;
               }
               else if (stat == RT_OK_FRAG) {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return RTERR_NOTSUPP;
               }
               bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
               bitLength = openTypeLen * 8;

               if (openTypeLen > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.contentNewPresent = 1;
                        pctxt->level++;

                        stat = asn1PD_TravelerDataFrameNewPartIIIContent (pctxt, &pvalue->contentNew);

                        if (stat != 0) break;

                        pctxt->level--;

                        break;

                  }
               }

               if (0 == stat) {
                  bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
                  bitsConsumed = bitEndOffset - bitStartOffset;
                  if (bitsConsumed < bitLength) {
                     stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
                  }
                  else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
               }
            }
            else {
               stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

               if (0 == stat) {
                  pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
                  if (0 != pOpenType) {
                     pOpenType->numocts = openType.numocts;
                     pOpenType->data = openType.data;
                     rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
                  }
                  else stat = RTERR_NOMEM;
               }
               else {
                  rtxMemFreePtr (pctxt, extOptBits.data);
                  return stat;
               }
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   return (stat);
}

EXTERN int asn1PD_TravelerDataFrameList (OSCTXT* pctxt, TravelerDataFrameList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TravelerDataFrame* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, TravelerDataFrame);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_TravelerDataFrame (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TravelerDataFrame (pctxt, pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_TravelerInformation_regional (OSCTXT* pctxt, TravelerInformation_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      pctxt->level++;

      pdata = rtxMemAllocType (pctxt, RegionalExtension);
      if(pdata)  {
         pnode = (OSRTDListNode*) rtxMemAlloc (pctxt, sizeof(OSRTDListNode));
         if ( pnode != 0 ) pnode->data = pdata;
      }
      else pnode = 0;

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension ((RegionalExtension*)pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, (RegionalExtension*)pdata);
      if (stat != 0) return stat;

      pctxt->level--;
   }

   return (stat);
}

EXTERN int asn1PD_TravelerInformation (OSCTXT* pctxt, TravelerInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   /* extension bit */

   rtxDecBit(pctxt, &extbit);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode msgCnt */
         pctxt->level++;

         stat = asn1PD_Common_MsgCount (pctxt, (Common_MsgCount*)&pvalue->msgCnt);

         pctxt->level--;
         break;

         case 1:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, (MinuteOfTheYear*)&pvalue->timeStamp);

            pctxt->level--;
         }
         break;

         case 2:
         /* decode packetID */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.packetIDPresent = 1;

            stat = asn1PD_UniqueMSGID (pctxt, &pvalue->packetID);

            pctxt->level--;
         }
         break;

         case 3:
         /* decode urlB */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.urlBPresent = 1;

            stat = asn1PD_URL_Base (pctxt, &pvalue->urlB);

            pctxt->level--;
         }
         break;

         case 4:
         /* decode dataFrames */
         pctxt->level++;

         stat = asn1PD_TravelerDataFrameList (pctxt, &pvalue->dataFrames);

         pctxt->level--;
         break;

         case 5:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pctxt->level++;

            pvalue->m.regionalPresent = 1;

            stat = asn1PD_TravelerInformation_regional (pctxt, &pvalue->regional);

            pctxt->level--;
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSDynOctStr extOptBits;

      /* decode extension optional bits */

      stat = pd_ExtOptElemBits(pctxt, &extOptBits);
      if (stat != 0) return stat;
      for (i_ = 0; i_ < extOptBits.numocts; i_++) {
         if (stat != 0) break;
         if (extOptBits.data[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, extOptBits.data);
   }

   if (stat == 0) {
      stat = rtxErrCheckNonFatal (pctxt);
   }
   return (stat);
}

