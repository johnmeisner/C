/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "TravelerInformation.h"
#include "REGION.h"
#include "Common.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PE_DirectionOfUse (OSCTXT* pctxt, DirectionOfUse value)
{
   int stat = 0;

   if (value >= 4) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_DistanceUnits (OSCTXT* pctxt, DistanceUnits value)
{
   int stat = 0;

   if (value >= 8) {
      return RTERR_INVENUM;
   }
   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_ITIStextPhrase (OSCTXT* pctxt, ITIStextPhrase value)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_ConstrainedStringEx (pctxt, value, 0, 8, 7, 7);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_MinutesDuration (OSCTXT* pctxt, MinutesDuration value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  32000);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_MsgCRC (OSCTXT* pctxt, MsgCRC* pvalue)
{
   int stat = 0;

   if (pvalue->numocts != 2) {
      return RTERR_CONSVIO;
   }
   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 16);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_MUTCDCode (OSCTXT* pctxt, MUTCDCode value)
{
   int stat = 0;

   if (value >= 7) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NodeAttributeLL (OSCTXT* pctxt, NodeAttributeLL value)
{
   int stat = 0;

   if (value >= 12) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_OffsetLL_B12 (OSCTXT* pctxt, OffsetLL_B12 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -2048,  2047);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_OffsetLL_B14 (OSCTXT* pctxt, OffsetLL_B14 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -8192,  8191);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_OffsetLL_B16 (OSCTXT* pctxt, OffsetLL_B16 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -32768,  32767);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_OffsetLL_B22 (OSCTXT* pctxt, OffsetLL_B22 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -2097152,  2097151);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_OffsetLL_B24 (OSCTXT* pctxt, OffsetLL_B24 value)
{
   int stat = 0;

   stat = pe_ConsInteger(pctxt, value,  -8388608,  8388607);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Radius_B12 (OSCTXT* pctxt, Radius_B12 value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  4095);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SegmentAttributeLL (OSCTXT* pctxt, SegmentAttributeLL value)
{
   int stat = 0;

   if (value >= 38) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 6);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SignPrority (OSCTXT* pctxt, SignPrority value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  7);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_TravelerInfoType (OSCTXT* pctxt, TravelerInfoType value)
{
   int stat = 0;

   if (value >= 4) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_UniqueMSGID (OSCTXT* pctxt, UniqueMSGID* pvalue)
{
   int stat = 0;

   if (pvalue->numocts != 9) {
      return RTERR_CONSVIO;
   }
   stat = pe_byte_align (pctxt);
   if (stat != 0) return stat;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 72);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_URL_Base (OSCTXT* pctxt, URL_Base value)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(45), 0, 0);

   stat = pe_ConstrainedStringEx (pctxt, value, 0, 8, 7, 7);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_URL_Short (OSCTXT* pctxt, URL_Short value)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(15), 0, 0);

   stat = pe_ConstrainedStringEx (pctxt, value, 0, 8, 7, 7);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Zoom (OSCTXT* pctxt, Zoom value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  15);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RoadSignID (OSCTXT* pctxt, RoadSignID* pvalue)
{
   int stat = 0;

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.mutcdCodePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.crcPresent);

   /* encode position */

   stat = asn1PE_Position3D (pctxt, (Position3D*)pvalue->position);
   if (stat != 0) return stat;

   /* encode viewAngle */

   stat = asn1PE_HeadingSlice (pctxt, (HeadingSlice*)pvalue->viewAngle);
   if (stat != 0) return stat;

   /* encode mutcdCode */

   if (pvalue->m.mutcdCodePresent) {
      stat = asn1PE_MUTCDCode (pctxt, pvalue->mutcdCode);
      if (stat != 0) return stat;
   }

   /* encode crc */

   if (pvalue->m.crcPresent) {
      stat = asn1PE_MsgCRC (pctxt, &pvalue->crc);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_TravelerDataFrame_msgId (OSCTXT* pctxt, TravelerDataFrame_msgId* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* furtherInfoID */
      case 1:
         stat = asn1PE_FurtherInfoID (pctxt, (FurtherInfoID*)pvalue->u.furtherInfoID);
         if (stat != 0) return stat;
         break;

      /* roadSignID */
      case 2:
         stat = asn1PE_RoadSignID (pctxt, pvalue->u.roadSignID);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_Node_LL_24B (OSCTXT* pctxt, Node_LL_24B* pvalue)
{
   int stat = 0;

   /* encode lon */

   stat = asn1PE_OffsetLL_B12 (pctxt, pvalue->lon);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_OffsetLL_B12 (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Node_LL_28B (OSCTXT* pctxt, Node_LL_28B* pvalue)
{
   int stat = 0;

   /* encode lon */

   stat = asn1PE_OffsetLL_B14 (pctxt, pvalue->lon);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_OffsetLL_B14 (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Node_LL_32B (OSCTXT* pctxt, Node_LL_32B* pvalue)
{
   int stat = 0;

   /* encode lon */

   stat = asn1PE_OffsetLL_B16 (pctxt, pvalue->lon);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_OffsetLL_B16 (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Node_LL_36B (OSCTXT* pctxt, Node_LL_36B* pvalue)
{
   int stat = 0;

   /* encode lon */

   stat = asn1PE_OffsetLL_B18 (pctxt, pvalue->lon);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_OffsetLL_B18 (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Node_LL_44B (OSCTXT* pctxt, Node_LL_44B* pvalue)
{
   int stat = 0;

   /* encode lon */

   stat = asn1PE_OffsetLL_B22 (pctxt, pvalue->lon);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_OffsetLL_B22 (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Node_LL_48B (OSCTXT* pctxt, Node_LL_48B* pvalue)
{
   int stat = 0;

   /* encode lon */

   stat = asn1PE_OffsetLL_B24 (pctxt, pvalue->lon);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_OffsetLL_B24 (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_NodeOffsetPointLL (OSCTXT* pctxt, NodeOffsetPointLL* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 3);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* node_LL1 */
      case 1:
         stat = asn1PE_Node_LL_24B (pctxt, pvalue->u.node_LL1);
         if (stat != 0) return stat;
         break;

      /* node_LL2 */
      case 2:
         stat = asn1PE_Node_LL_28B (pctxt, pvalue->u.node_LL2);
         if (stat != 0) return stat;
         break;

      /* node_LL3 */
      case 3:
         stat = asn1PE_Node_LL_32B (pctxt, pvalue->u.node_LL3);
         if (stat != 0) return stat;
         break;

      /* node_LL4 */
      case 4:
         stat = asn1PE_Node_LL_36B (pctxt, pvalue->u.node_LL4);
         if (stat != 0) return stat;
         break;

      /* node_LL5 */
      case 5:
         stat = asn1PE_Node_LL_44B (pctxt, pvalue->u.node_LL5);
         if (stat != 0) return stat;
         break;

      /* node_LL6 */
      case 6:
         stat = asn1PE_Node_LL_48B (pctxt, pvalue->u.node_LL6);
         if (stat != 0) return stat;
         break;

      /* node_LatLon */
      case 7:
         stat = asn1PE_Node_LLmD_64b (pctxt, (Node_LLmD_64b*)pvalue->u.node_LatLon);
         if (stat != 0) return stat;
         break;

      /* regional */
      case 8:
         stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)pvalue->u.regional);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_NodeAttributeLLList (OSCTXT* pctxt, NodeAttributeLLList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_NodeAttributeLL (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_SegmentAttributeLLList (OSCTXT* pctxt, SegmentAttributeLLList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_SegmentAttributeLL (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_NodeAttributeSetLL_regional (OSCTXT* pctxt, NodeAttributeSetLL_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_NodeAttributeSetLL (OSCTXT* pctxt, NodeAttributeSetLL* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.localNodePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.disabledPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.enabledPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dWidthPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dElevationPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode localNode */

   if (pvalue->m.localNodePresent) {
      stat = asn1PE_NodeAttributeLLList (pctxt, &pvalue->localNode);
      if (stat != 0) return stat;
   }

   /* encode disabled */

   if (pvalue->m.disabledPresent) {
      stat = asn1PE_SegmentAttributeLLList (pctxt, &pvalue->disabled);
      if (stat != 0) return stat;
   }

   /* encode enabled */

   if (pvalue->m.enabledPresent) {
      stat = asn1PE_SegmentAttributeLLList (pctxt, &pvalue->enabled);
      if (stat != 0) return stat;
   }

   /* encode data */

   if (pvalue->m.dataPresent) {
      stat = asn1PE_LaneDataAttributeList (pctxt, (LaneDataAttributeList*)&pvalue->data);
      if (stat != 0) return stat;
   }

   /* encode dWidth */

   if (pvalue->m.dWidthPresent) {
      stat = asn1PE_Offset_B10 (pctxt, pvalue->dWidth);
      if (stat != 0) return stat;
   }

   /* encode dElevation */

   if (pvalue->m.dElevationPresent) {
      stat = asn1PE_Offset_B10 (pctxt, pvalue->dElevation);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_NodeAttributeSetLL_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NodeLL (OSCTXT* pctxt, NodeLL* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.attributesPresent);

   /* encode delta */

   stat = asn1PE_NodeOffsetPointLL (pctxt, &pvalue->delta);
   if (stat != 0) return stat;

   /* encode attributes */

   if (pvalue->m.attributesPresent) {
      stat = asn1PE_NodeAttributeSetLL (pctxt, &pvalue->attributes);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_NodeSetLL (OSCTXT* pctxt, NodeSetLL* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(63), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_NodeLL (pctxt, ((NodeLL*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_NodeListLL (OSCTXT* pctxt, NodeListLL* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 1);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* nodes */
         case 1:
            stat = asn1PE_NodeSetLL (pctxt, pvalue->u.nodes);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_OffsetSystem_offset (OSCTXT* pctxt, OffsetSystem_offset* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* xy */
      case 1:
         stat = asn1PE_NodeListXY (pctxt, (NodeListXY*)pvalue->u.xy);
         if (stat != 0) return stat;
         break;

      /* ll */
      case 2:
         stat = asn1PE_NodeListLL (pctxt, pvalue->u.ll);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_OffsetSystem (OSCTXT* pctxt, OffsetSystem* pvalue)
{
   int stat = 0;

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.scalePresent);

   /* encode scale */

   if (pvalue->m.scalePresent) {
      stat = asn1PE_Zoom (pctxt, pvalue->scale);
      if (stat != 0) return stat;
   }

   /* encode offset */

   stat = asn1PE_OffsetSystem_offset (pctxt, &pvalue->offset);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_Circle (OSCTXT* pctxt, Circle* pvalue)
{
   int stat = 0;

   /* encode center */

   stat = asn1PE_Position3D (pctxt, (Position3D*)pvalue->center);
   if (stat != 0) return stat;

   /* encode radius */

   stat = asn1PE_Radius_B12 (pctxt, pvalue->radius);
   if (stat != 0) return stat;

   /* encode units */

   stat = asn1PE_DistanceUnits (pctxt, pvalue->units);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_GeometricProjection_regional (OSCTXT* pctxt, GeometricProjection_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_GeometricProjection (OSCTXT* pctxt, GeometricProjection* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.extentPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.laneWidthPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode direction */

   stat = asn1PE_HeadingSlice (pctxt, (HeadingSlice*)pvalue->direction);
   if (stat != 0) return stat;

   /* encode extent */

   if (pvalue->m.extentPresent) {
      stat = asn1PE_Extent (pctxt, pvalue->extent);
      if (stat != 0) return stat;
   }

   /* encode laneWidth */

   if (pvalue->m.laneWidthPresent) {
      stat = asn1PE_LaneWidth (pctxt, pvalue->laneWidth);
      if (stat != 0) return stat;
   }

   /* encode circle */

   stat = asn1PE_Circle (pctxt, &pvalue->circle);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_GeometricProjection_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_ShapePointSet (OSCTXT* pctxt, ShapePointSet* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.anchorPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.laneWidthPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.directionalityPresent);

   /* encode anchor */

   if (pvalue->m.anchorPresent) {
      stat = asn1PE_Position3D (pctxt, (Position3D*)pvalue->anchor);
      if (stat != 0) return stat;
   }

   /* encode laneWidth */

   if (pvalue->m.laneWidthPresent) {
      stat = asn1PE_LaneWidth (pctxt, pvalue->laneWidth);
      if (stat != 0) return stat;
   }

   /* encode directionality */

   if (pvalue->m.directionalityPresent) {
      stat = asn1PE_DirectionOfUse (pctxt, pvalue->directionality);
      if (stat != 0) return stat;
   }

   /* encode nodeList */

   stat = asn1PE_NodeListXY (pctxt, (NodeListXY*)pvalue->nodeList);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RegionOffsets (OSCTXT* pctxt, RegionOffsets* pvalue)
{
   int stat = 0;

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.zOffsetPresent);

   /* encode xOffset */

   stat = asn1PE_OffsetLL_B16 (pctxt, pvalue->xOffset);
   if (stat != 0) return stat;

   /* encode yOffset */

   stat = asn1PE_OffsetLL_B16 (pctxt, pvalue->yOffset);
   if (stat != 0) return stat;

   /* encode zOffset */

   if (pvalue->m.zOffsetPresent) {
      stat = asn1PE_OffsetLL_B16 (pctxt, pvalue->zOffset);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_RegionList (OSCTXT* pctxt, RegionList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionOffsets (pctxt, ((RegionOffsets*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_RegionPointSet (OSCTXT* pctxt, RegionPointSet* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.anchorPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.scalePresent);

   /* encode anchor */

   if (pvalue->m.anchorPresent) {
      stat = asn1PE_Position3D (pctxt, (Position3D*)pvalue->anchor);
      if (stat != 0) return stat;
   }

   /* encode scale */

   if (pvalue->m.scalePresent) {
      stat = asn1PE_Zoom (pctxt, pvalue->scale);
      if (stat != 0) return stat;
   }

   /* encode nodeList */

   stat = asn1PE_RegionList (pctxt, &pvalue->nodeList);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_ValidRegion_area (OSCTXT* pctxt, ValidRegion_area* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 2);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* shapePointSet */
      case 1:
         stat = asn1PE_ShapePointSet (pctxt, pvalue->u.shapePointSet);
         if (stat != 0) return stat;
         break;

      /* circle */
      case 2:
         stat = asn1PE_Circle (pctxt, pvalue->u.circle);
         if (stat != 0) return stat;
         break;

      /* regionPointSet */
      case 3:
         stat = asn1PE_RegionPointSet (pctxt, pvalue->u.regionPointSet);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_ValidRegion (OSCTXT* pctxt, ValidRegion* pvalue)
{
   int stat = 0;

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.extentPresent);

   /* encode direction */

   stat = asn1PE_HeadingSlice (pctxt, (HeadingSlice*)pvalue->direction);
   if (stat != 0) return stat;

   /* encode extent */

   if (pvalue->m.extentPresent) {
      stat = asn1PE_Extent (pctxt, pvalue->extent);
      if (stat != 0) return stat;
   }

   /* encode area */

   stat = asn1PE_ValidRegion_area (pctxt, &pvalue->area);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_GeographicalPath_description (OSCTXT* pctxt, GeographicalPath_description* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 3);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 2);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* path */
         case 1:
            stat = asn1PE_OffsetSystem (pctxt, pvalue->u.path);
            if (stat != 0) return stat;
            break;

         /* geometry */
         case 2:
            stat = asn1PE_GeometricProjection (pctxt, pvalue->u.geometry);
            if (stat != 0) return stat;
            break;

         /* oldRegion */
         case 3:
            stat = asn1PE_ValidRegion (pctxt, pvalue->u.oldRegion);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_GeographicalPath_regional (OSCTXT* pctxt, GeographicalPath_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_GeographicalPath (OSCTXT* pctxt, GeographicalPath* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.namePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.idPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.anchorPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.laneWidthPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.directionalityPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.closedPathPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.directionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.descriptionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode name */

   if (pvalue->m.namePresent) {
      stat = asn1PE_DescriptiveName (pctxt, pvalue->name);
      if (stat != 0) return stat;
   }

   /* encode id */

   if (pvalue->m.idPresent) {
      stat = asn1PE_RoadSegmentReferenceID (pctxt, (RoadSegmentReferenceID*)pvalue->id);
      if (stat != 0) return stat;
   }

   /* encode anchor */

   if (pvalue->m.anchorPresent) {
      stat = asn1PE_Position3D (pctxt, (Position3D*)pvalue->anchor);
      if (stat != 0) return stat;
   }

   /* encode laneWidth */

   if (pvalue->m.laneWidthPresent) {
      stat = asn1PE_LaneWidth (pctxt, pvalue->laneWidth);
      if (stat != 0) return stat;
   }

   /* encode directionality */

   if (pvalue->m.directionalityPresent) {
      stat = asn1PE_DirectionOfUse (pctxt, pvalue->directionality);
      if (stat != 0) return stat;
   }

   /* encode closedPath */

   if (pvalue->m.closedPathPresent) {
      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->closedPath);
      if (stat != 0) return stat;
   }

   /* encode direction */

   if (pvalue->m.directionPresent) {
      stat = asn1PE_HeadingSlice (pctxt, (HeadingSlice*)pvalue->direction);
      if (stat != 0) return stat;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = asn1PE_GeographicalPath_description (pctxt, &pvalue->description);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_GeographicalPath_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_TravelerDataFrame_regions (OSCTXT* pctxt, TravelerDataFrame_regions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_GeographicalPath (pctxt, ((GeographicalPath*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_WorkZone_element_item (OSCTXT* pctxt, WorkZone_element_item* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* itis */
      case 1:
         stat = asn1PE_ITIScodes (pctxt, pvalue->u.itis);
         if (stat != 0) return stat;
         break;

      /* text */
      case 2:
         stat = asn1PE_ITIStextPhrase (pctxt, pvalue->u.text);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_WorkZone_element (OSCTXT* pctxt, WorkZone_element* pvalue)
{
   int stat = 0;

   /* encode item */

   stat = asn1PE_WorkZone_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_WorkZone (OSCTXT* pctxt, WorkZone* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_WorkZone_element (pctxt, ((WorkZone_element*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_GenericSignage_element_item (OSCTXT* pctxt, GenericSignage_element_item* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* itis */
      case 1:
         stat = asn1PE_ITIScodes (pctxt, pvalue->u.itis);
         if (stat != 0) return stat;
         break;

      /* text */
      case 2:
         stat = asn1PE_ITIStextPhrase (pctxt, pvalue->u.text);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_GenericSignage_element (OSCTXT* pctxt, GenericSignage_element* pvalue)
{
   int stat = 0;

   /* encode item */

   stat = asn1PE_GenericSignage_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_GenericSignage (OSCTXT* pctxt, GenericSignage* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_GenericSignage_element (pctxt, ((GenericSignage_element*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_SpeedLimit_element_item (OSCTXT* pctxt, SpeedLimit_element_item* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* itis */
      case 1:
         stat = asn1PE_ITIScodes (pctxt, pvalue->u.itis);
         if (stat != 0) return stat;
         break;

      /* text */
      case 2:
         stat = asn1PE_ITIStextPhrase (pctxt, pvalue->u.text);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_SpeedLimit_element (OSCTXT* pctxt, SpeedLimit_element* pvalue)
{
   int stat = 0;

   /* encode item */

   stat = asn1PE_SpeedLimit_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_SpeedLimit (OSCTXT* pctxt, SpeedLimit* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_SpeedLimit_element (pctxt, ((SpeedLimit_element*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_ExitService_element_item (OSCTXT* pctxt, ExitService_element_item* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* itis */
      case 1:
         stat = asn1PE_ITIScodes (pctxt, pvalue->u.itis);
         if (stat != 0) return stat;
         break;

      /* text */
      case 2:
         stat = asn1PE_ITIStextPhrase (pctxt, pvalue->u.text);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_ExitService_element (OSCTXT* pctxt, ExitService_element* pvalue)
{
   int stat = 0;

   /* encode item */

   stat = asn1PE_ExitService_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_ExitService (OSCTXT* pctxt, ExitService* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_ExitService_element (pctxt, ((ExitService_element*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_TravelerDataFrame_content (OSCTXT* pctxt, TravelerDataFrame_content* pvalue)
{
   int stat = 0;

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 3);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* advisory */
      case 1:
         stat = asn1PE_ITIScodesAndText (pctxt, pvalue->u.advisory);
         if (stat != 0) return stat;
         break;

      /* workZone */
      case 2:
         stat = asn1PE_WorkZone (pctxt, pvalue->u.workZone);
         if (stat != 0) return stat;
         break;

      /* genericSign */
      case 3:
         stat = asn1PE_GenericSignage (pctxt, pvalue->u.genericSign);
         if (stat != 0) return stat;
         break;

      /* speedLimit */
      case 4:
         stat = asn1PE_SpeedLimit (pctxt, pvalue->u.speedLimit);
         if (stat != 0) return stat;
         break;

      /* exitService */
      case 5:
         stat = asn1PE_ExitService (pctxt, pvalue->u.exitService);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   return (stat);
}

EXTERN int asn1PE_TravelerDataFrameNewPartIIIContent (OSCTXT* pctxt, TravelerDataFrameNewPartIIIContent* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 1);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* frictionInfo */
         case 1:
            stat = asn1PE_FrictionInformation (pctxt, (FrictionInformation*)pvalue->u.frictionInfo);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_TravelerDataFrame (OSCTXT* pctxt, TravelerDataFrame* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   extbit = (OSBOOL)(pvalue->m.contentNewPresent ||
   pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.startYearPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.urlPresent);

   /* encode notUsed */

   stat = asn1PE_SSPindex (pctxt, pvalue->notUsed);
   if (stat != 0) return stat;

   /* encode frameType */

   stat = asn1PE_TravelerInfoType (pctxt, pvalue->frameType);
   if (stat != 0) return stat;

   /* encode msgId */

   stat = asn1PE_TravelerDataFrame_msgId (pctxt, &pvalue->msgId);
   if (stat != 0) return stat;

   /* encode startYear */

   if (pvalue->m.startYearPresent) {
      stat = asn1PE_DYear (pctxt, pvalue->startYear);
      if (stat != 0) return stat;
   }

   /* encode startTime */

   stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->startTime);
   if (stat != 0) return stat;

   /* encode durationTime */

   stat = asn1PE_MinutesDuration (pctxt, pvalue->durationTime);
   if (stat != 0) return stat;

   /* encode priority */

   stat = asn1PE_SignPrority (pctxt, pvalue->priority);
   if (stat != 0) return stat;

   /* encode notUsed1 */

   stat = asn1PE_SSPindex (pctxt, pvalue->notUsed1);
   if (stat != 0) return stat;

   /* encode regions */

   stat = asn1PE_TravelerDataFrame_regions (pctxt, &pvalue->regions);
   if (stat != 0) return stat;

   /* encode notUsed2 */

   stat = asn1PE_SSPindex (pctxt, pvalue->notUsed2);
   if (stat != 0) return stat;

   /* encode notUsed3 */

   stat = asn1PE_SSPindex (pctxt, pvalue->notUsed3);
   if (stat != 0) return stat;

   /* encode content */

   stat = asn1PE_TravelerDataFrame_content (pctxt, &pvalue->content);
   if (stat != 0) return stat;

   /* encode url */

   if (pvalue->m.urlPresent) {
      stat = asn1PE_URL_Short (pctxt, pvalue->url);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return stat;

      /* encode optional bits */

      rtxEncBit (pctxt, (OSBOOL)pvalue->m.contentNewPresent);

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->m.contentNewPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return stat;

         stat = asn1PE_TravelerDataFrameNewPartIIIContent (pctxt, &pvalue->contentNew);
         if (stat != 0) return stat;

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return stat;
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_TravelerDataFrameList (OSCTXT* pctxt, TravelerDataFrameList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_TravelerDataFrame (pctxt, ((TravelerDataFrame*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_TravelerInformation_regional (OSCTXT* pctxt, TravelerInformation_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_TravelerInformation (OSCTXT* pctxt, TravelerInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.packetIDPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.urlBPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode msgCnt */

   stat = asn1PE_Common_MsgCount (pctxt, pvalue->msgCnt);
   if (stat != 0) return stat;

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode packetID */

   if (pvalue->m.packetIDPresent) {
      stat = asn1PE_UniqueMSGID (pctxt, &pvalue->packetID);
      if (stat != 0) return stat;
   }

   /* encode urlB */

   if (pvalue->m.urlBPresent) {
      stat = asn1PE_URL_Base (pctxt, pvalue->urlB);
      if (stat != 0) return stat;
   }

   /* encode dataFrames */

   stat = asn1PE_TravelerDataFrameList (pctxt, &pvalue->dataFrames);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_TravelerInformation_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

