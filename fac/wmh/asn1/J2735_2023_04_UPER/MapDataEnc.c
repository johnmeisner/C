/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.7.0, Date: 25-May-2023.
 *
 * Command:  asn1c CooperativeControlMsg-v1-ph.asn J2735-AddGrpB.asn J2735-AddGrpC.asn J2735-BasicSafetyMessage-v4.asn J2735-CommonSafetyRequest.asn J2735-Common-v7.asn J2735-EmergencyVehicleAlert.asn J2735-IntersectionCollision.asn J2735-ITIS.asn J2735-MapData-v1.asn J2735-MessageFrame-v5.asn J2735-NMEAcorrections.asn J2735-NTCIP.asn J2735-PersonalSafetyMessage.asn J2735-ProbeDataManagement.asn J2735-ProbeVehicleData.asn J2735-REGION.asn J2735-RoadSideAlert.asn J2735-RTCMcorrections.asn J2735-SignalRequestMessage.asn J2735-SignalStatusMessage.asn J2735-SPAT-v2.asn J2735-TestMessage00.asn J2735-TestMessage01.asn J2735-TestMessage02.asn J2735-TestMessage03.asn J2735-TestMessage04.asn J2735-TestMessage05.asn J2735-TestMessage06.asn J2735-TestMessage07.asn J2735-TestMessage08.asn J2735-TestMessage09.asn J2735-TestMessage10.asn J2735-TestMessage11.asn J2735-TestMessage12.asn J2735-TestMessage13.asn J2735-TestMessage14.asn J2735-TestMessage15.asn J2735-TravelerInformation-v2.asn MnvrSharingCoordMsg-v1-ph.asn PersonalSafetyMsg2-v1-ph.asn ProbeDataConfig-v0.30.asn ProbeDataReport-v0.30.asn RoadGeoAttributes-v2-ph.asn RoadSafetyMsg-v1-ph.asn RoadWeatherMessage.asn SensorDataSharingMsg-v1-ph.asn SignalControlAndPrioritizationRequest-v1-ph.asn SignalControlAndPrioritizationStatus-v1-ph.asn TollAdvertisementMsg-v0.10-ph.asn TollUsageAckMsg-v0.10-ph.asn TollUsageMsg-v0.10-ph.asn TrafficSignalPhaseAndTiming-v1-ph.asn -c -per -compact
 */
#include "MapData.h"
#include "REGION.h"
#include "Common.h"
#include "rtxsrc/rtxCharStr.h"

EXTERN int asn1PE_AllowedManeuvers (OSCTXT* pctxt, AllowedManeuvers* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 12);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_Barrier (OSCTXT* pctxt, LaneAttributes_Barrier* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 16);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_Bike (OSCTXT* pctxt, LaneAttributes_Bike* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 16);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_Crosswalk (OSCTXT* pctxt, LaneAttributes_Crosswalk* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 16);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_Parking (OSCTXT* pctxt, LaneAttributes_Parking* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 16);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_Sidewalk (OSCTXT* pctxt, LaneAttributes_Sidewalk* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 16);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_Striping (OSCTXT* pctxt, LaneAttributes_Striping* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 16);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_TrackedVehicle (OSCTXT* pctxt, LaneAttributes_TrackedVehicle* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 16);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_Vehicle (OSCTXT* pctxt, LaneAttributes_Vehicle* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), OSUINTCONST(0), OSUINT32_MAX);

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(8)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(8) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(8)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LaneDirection (OSCTXT* pctxt, LaneDirection* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 2);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LaneSharing (OSCTXT* pctxt, LaneSharing* pvalue)
{
   int stat = 0;

   stat = rtxEncBitsFromByteArray (pctxt, pvalue->data, 10);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LayerID (OSCTXT* pctxt, LayerID value)
{
   int stat = 0;

   stat = pe_ConsUnsigned(pctxt, value,  0,  100);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LayerType (OSCTXT* pctxt, LayerType value)
{
   int stat = 0;

   if (value >= 8) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 3);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RestrictionAppliesTo (OSCTXT* pctxt, RestrictionAppliesTo value)
{
   int stat = 0;

   if (value >= 14) {
      return RTERR_INVENUM;
   }
   /* extension bit */

   rtxEncBit (pctxt, 0);

   stat = rtxEncBits(pctxt, value, 4);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_LaneTypeAttributes (OSCTXT* pctxt, LaneTypeAttributes* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 8);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 3);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* vehicle */
         case 1:
            stat = asn1PE_LaneAttributes_Vehicle (pctxt, pvalue->u.vehicle);
            if (stat != 0) return stat;
            break;

         /* crosswalk */
         case 2:
            stat = asn1PE_LaneAttributes_Crosswalk (pctxt, pvalue->u.crosswalk);
            if (stat != 0) return stat;
            break;

         /* bikeLane */
         case 3:
            stat = asn1PE_LaneAttributes_Bike (pctxt, pvalue->u.bikeLane);
            if (stat != 0) return stat;
            break;

         /* sidewalk */
         case 4:
            stat = asn1PE_LaneAttributes_Sidewalk (pctxt, pvalue->u.sidewalk);
            if (stat != 0) return stat;
            break;

         /* median */
         case 5:
            stat = asn1PE_LaneAttributes_Barrier (pctxt, pvalue->u.median);
            if (stat != 0) return stat;
            break;

         /* striping */
         case 6:
            stat = asn1PE_LaneAttributes_Striping (pctxt, pvalue->u.striping);
            if (stat != 0) return stat;
            break;

         /* trackedVehicle */
         case 7:
            stat = asn1PE_LaneAttributes_TrackedVehicle (pctxt, pvalue->u.trackedVehicle);
            if (stat != 0) return stat;
            break;

         /* parking */
         case 8:
            stat = asn1PE_LaneAttributes_Parking (pctxt, pvalue->u.parking);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 9);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_LaneAttributes (OSCTXT* pctxt, LaneAttributes* pvalue)
{
   int stat = 0;

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode directionalUse */

   stat = asn1PE_LaneDirection (pctxt, &pvalue->directionalUse);
   if (stat != 0) return stat;

   /* encode sharedWith */

   stat = asn1PE_LaneSharing (pctxt, &pvalue->sharedWith);
   if (stat != 0) return stat;

   /* encode laneType */

   stat = asn1PE_LaneTypeAttributes (pctxt, &pvalue->laneType);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)pvalue->regional);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_ConnectingLane (OSCTXT* pctxt, ConnectingLane* pvalue)
{
   int stat = 0;

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.maneuverPresent);

   /* encode lane */

   stat = asn1PE_LaneID (pctxt, pvalue->lane);
   if (stat != 0) return stat;

   /* encode maneuver */

   if (pvalue->m.maneuverPresent) {
      stat = asn1PE_AllowedManeuvers (pctxt, &pvalue->maneuver);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_Connection (OSCTXT* pctxt, Connection* pvalue)
{
   int stat = 0;

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.remoteIntersectionPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.signalGroupPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.userClassPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.connectionIDPresent);

   /* encode connectingLane */

   stat = asn1PE_ConnectingLane (pctxt, &pvalue->connectingLane);
   if (stat != 0) return stat;

   /* encode remoteIntersection */

   if (pvalue->m.remoteIntersectionPresent) {
      stat = asn1PE_IntersectionReferenceID (pctxt, (IntersectionReferenceID*)pvalue->remoteIntersection);
      if (stat != 0) return stat;
   }

   /* encode signalGroup */

   if (pvalue->m.signalGroupPresent) {
      stat = asn1PE_SignalGroupID (pctxt, pvalue->signalGroup);
      if (stat != 0) return stat;
   }

   /* encode userClass */

   if (pvalue->m.userClassPresent) {
      stat = asn1PE_RestrictionClassID (pctxt, pvalue->userClass);
      if (stat != 0) return stat;
   }

   /* encode connectionID */

   if (pvalue->m.connectionIDPresent) {
      stat = asn1PE_LaneConnectionID (pctxt, pvalue->connectionID);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_ConnectsToList (OSCTXT* pctxt, ConnectsToList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_Connection (pctxt, ((Connection*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_OverlayLaneList (OSCTXT* pctxt, OverlayLaneList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(5), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_LaneID (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_GenericLane_regional (OSCTXT* pctxt, GenericLane_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_GenericLane (OSCTXT* pctxt, GenericLane* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.namePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.ingressApproachPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.egressApproachPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.maneuversPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.connectsToPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.overlaysPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode laneID */

   stat = asn1PE_LaneID (pctxt, pvalue->laneID);
   if (stat != 0) return stat;

   /* encode name */

   if (pvalue->m.namePresent) {
      stat = asn1PE_DescriptiveName (pctxt, pvalue->name);
      if (stat != 0) return stat;
   }

   /* encode ingressApproach */

   if (pvalue->m.ingressApproachPresent) {
      stat = asn1PE_ApproachID (pctxt, pvalue->ingressApproach);
      if (stat != 0) return stat;
   }

   /* encode egressApproach */

   if (pvalue->m.egressApproachPresent) {
      stat = asn1PE_ApproachID (pctxt, pvalue->egressApproach);
      if (stat != 0) return stat;
   }

   /* encode laneAttributes */

   stat = asn1PE_LaneAttributes (pctxt, &pvalue->laneAttributes);
   if (stat != 0) return stat;

   /* encode maneuvers */

   if (pvalue->m.maneuversPresent) {
      stat = asn1PE_AllowedManeuvers (pctxt, &pvalue->maneuvers);
      if (stat != 0) return stat;
   }

   /* encode nodeList */

   stat = asn1PE_NodeListXY (pctxt, (NodeListXY*)pvalue->nodeList);
   if (stat != 0) return stat;

   /* encode connectsTo */

   if (pvalue->m.connectsToPresent) {
      stat = asn1PE_ConnectsToList (pctxt, &pvalue->connectsTo);
      if (stat != 0) return stat;
   }

   /* encode overlays */

   if (pvalue->m.overlaysPresent) {
      stat = asn1PE_OverlayLaneList (pctxt, &pvalue->overlays);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_GenericLane_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_LaneList (OSCTXT* pctxt, LaneList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_GenericLane (pctxt, ((GenericLane*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_SignalControlZone (OSCTXT* pctxt, SignalControlZone* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   /* encode zone */

   stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)pvalue->zone);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_PreemptPriorityList (OSCTXT* pctxt, PreemptPriorityList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_SignalControlZone (pctxt, ((SignalControlZone*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_IntersectionGeometry_regional (OSCTXT* pctxt, IntersectionGeometry_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_IntersectionGeometry (OSCTXT* pctxt, IntersectionGeometry* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   extbit = (OSBOOL)(pvalue->m.roadAuthorityIDPresent ||
   pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.namePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.laneWidthPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedLimitsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.preemptPriorityDataPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode name */

   if (pvalue->m.namePresent) {
      stat = asn1PE_DescriptiveName (pctxt, pvalue->name);
      if (stat != 0) return stat;
   }

   /* encode id */

   stat = asn1PE_IntersectionReferenceID (pctxt, (IntersectionReferenceID*)pvalue->id);
   if (stat != 0) return stat;

   /* encode revision */

   stat = asn1PE_Common_MsgCount (pctxt, pvalue->revision);
   if (stat != 0) return stat;

   /* encode refPoint */

   stat = asn1PE_Position3D (pctxt, (Position3D*)pvalue->refPoint);
   if (stat != 0) return stat;

   /* encode laneWidth */

   if (pvalue->m.laneWidthPresent) {
      stat = asn1PE_LaneWidth (pctxt, pvalue->laneWidth);
      if (stat != 0) return stat;
   }

   /* encode speedLimits */

   if (pvalue->m.speedLimitsPresent) {
      stat = asn1PE_SpeedLimitList (pctxt, (SpeedLimitList*)&pvalue->speedLimits);
      if (stat != 0) return stat;
   }

   /* encode laneSet */

   stat = asn1PE_LaneList (pctxt, &pvalue->laneSet);
   if (stat != 0) return stat;

   /* encode preemptPriorityData */

   if (pvalue->m.preemptPriorityDataPresent) {
      stat = asn1PE_PreemptPriorityList (pctxt, &pvalue->preemptPriorityData);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_IntersectionGeometry_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return stat;

      /* encode optional bits */

      rtxEncBit (pctxt, (OSBOOL)pvalue->m.roadAuthorityIDPresent);

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->m.roadAuthorityIDPresent) {
         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return stat;

         stat = asn1PE_RoadAuthorityID (pctxt, (RoadAuthorityID*)pvalue->roadAuthorityID);
         if (stat != 0) return stat;

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return stat;
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_IntersectionGeometryList (OSCTXT* pctxt, IntersectionGeometryList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_IntersectionGeometry (pctxt, ((IntersectionGeometry*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_RoadLaneSetList (OSCTXT* pctxt, RoadLaneSetList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_GenericLane (pctxt, ((GenericLane*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_RoadSegment_regional (OSCTXT* pctxt, RoadSegment_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_RoadSegment (OSCTXT* pctxt, RoadSegment* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.namePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.laneWidthPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedLimitsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode name */

   if (pvalue->m.namePresent) {
      stat = asn1PE_DescriptiveName (pctxt, pvalue->name);
      if (stat != 0) return stat;
   }

   /* encode id */

   stat = asn1PE_RoadSegmentReferenceID (pctxt, (RoadSegmentReferenceID*)pvalue->id);
   if (stat != 0) return stat;

   /* encode revision */

   stat = asn1PE_Common_MsgCount (pctxt, pvalue->revision);
   if (stat != 0) return stat;

   /* encode refPoint */

   stat = asn1PE_Position3D (pctxt, (Position3D*)pvalue->refPoint);
   if (stat != 0) return stat;

   /* encode laneWidth */

   if (pvalue->m.laneWidthPresent) {
      stat = asn1PE_LaneWidth (pctxt, pvalue->laneWidth);
      if (stat != 0) return stat;
   }

   /* encode speedLimits */

   if (pvalue->m.speedLimitsPresent) {
      stat = asn1PE_SpeedLimitList (pctxt, (SpeedLimitList*)&pvalue->speedLimits);
      if (stat != 0) return stat;
   }

   /* encode roadLaneSet */

   stat = asn1PE_RoadLaneSetList (pctxt, &pvalue->roadLaneSet);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RoadSegment_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RoadSegmentList (OSCTXT* pctxt, RoadSegmentList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RoadSegment (pctxt, ((RoadSegment*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_DataParameters (OSCTXT* pctxt, DataParameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.processMethodPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.processAgencyPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.lastCheckedDatePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.geoidUsedPresent);

   /* encode processMethod */

   if (pvalue->m.processMethodPresent) {
      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

      stat = pe_ConstrainedStringEx (pctxt, pvalue->processMethod, 0, 8, 7, 7);
      if (stat != 0) return stat;
   }

   /* encode processAgency */

   if (pvalue->m.processAgencyPresent) {
      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

      stat = pe_ConstrainedStringEx (pctxt, pvalue->processAgency, 0, 8, 7, 7);
      if (stat != 0) return stat;
   }

   /* encode lastCheckedDate */

   if (pvalue->m.lastCheckedDatePresent) {
      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

      stat = pe_ConstrainedStringEx (pctxt, pvalue->lastCheckedDate, 0, 8, 7, 7);
      if (stat != 0) return stat;
   }

   /* encode geoidUsed */

   if (pvalue->m.geoidUsedPresent) {
      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

      stat = pe_ConstrainedStringEx (pctxt, pvalue->geoidUsed, 0, 8, 7, 7);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

EXTERN int asn1PE_RestrictionUserType_regional (OSCTXT* pctxt, RestrictionUserType_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_RestrictionUserType (OSCTXT* pctxt, RestrictionUserType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->t > 2);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* basicType */
         case 1:
            stat = asn1PE_RestrictionAppliesTo (pctxt, pvalue->u.basicType);
            if (stat != 0) return stat;
            break;

         /* regional */
         case 2:
            stat = asn1PE_RestrictionUserType_regional (pctxt, pvalue->u.regional);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return stat;

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   return (stat);
}

EXTERN int asn1PE_RestrictionUserTypeList (OSCTXT* pctxt, RestrictionUserTypeList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RestrictionUserType (pctxt, ((RestrictionUserType*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_RestrictionClassAssignment (OSCTXT* pctxt, RestrictionClassAssignment* pvalue)
{
   int stat = 0;

   /* encode id */

   stat = asn1PE_RestrictionClassID (pctxt, pvalue->id);
   if (stat != 0) return stat;

   /* encode users */

   stat = asn1PE_RestrictionUserTypeList (pctxt, &pvalue->users);
   if (stat != 0) return stat;

   return (stat);
}

EXTERN int asn1PE_RestrictionClassList (OSCTXT* pctxt, RestrictionClassList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(254), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RestrictionClassAssignment (pctxt, ((RestrictionClassAssignment*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_MapData_regional (OSCTXT* pctxt, MapData_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, (RegionalExtension*)((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   return (stat);
}

EXTERN int asn1PE_MapData (OSCTXT* pctxt, MapData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   /* extension bit */

   rtxEncBit (pctxt, extbit);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.layerTypePresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.layerIDPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.intersectionsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.roadSegmentsPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataParametersPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.restrictionListPresent);

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode msgIssueRevision */

   stat = asn1PE_Common_MsgCount (pctxt, pvalue->msgIssueRevision);
   if (stat != 0) return stat;

   /* encode layerType */

   if (pvalue->m.layerTypePresent) {
      stat = asn1PE_LayerType (pctxt, pvalue->layerType);
      if (stat != 0) return stat;
   }

   /* encode layerID */

   if (pvalue->m.layerIDPresent) {
      stat = asn1PE_LayerID (pctxt, pvalue->layerID);
      if (stat != 0) return stat;
   }

   /* encode intersections */

   if (pvalue->m.intersectionsPresent) {
      stat = asn1PE_IntersectionGeometryList (pctxt, &pvalue->intersections);
      if (stat != 0) return stat;
   }

   /* encode roadSegments */

   if (pvalue->m.roadSegmentsPresent) {
      stat = asn1PE_RoadSegmentList (pctxt, &pvalue->roadSegments);
      if (stat != 0) return stat;
   }

   /* encode dataParameters */

   if (pvalue->m.dataParametersPresent) {
      stat = asn1PE_DataParameters (pctxt, &pvalue->dataParameters);
      if (stat != 0) return stat;
   }

   /* encode restrictionList */

   if (pvalue->m.restrictionListPresent) {
      stat = asn1PE_RestrictionClassList (pctxt, &pvalue->restrictionList);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_MapData_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength(pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      /* encode optional bits */

      stat = pe_OpenTypeExtBits(pctxt, &pvalue->extElem1);
      if (stat != 0) return stat;

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt(pctxt, &pvalue->extElem1);
         if (stat != 0) return stat;
      }
   }

   return (stat);
}

