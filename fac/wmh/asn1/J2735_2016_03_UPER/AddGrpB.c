/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.2.4, Date: 06-Mar-2019.
 */
#include "AddGrpB.h"
#include "rtxsrc/rtxCommon.h"

/* AddGrpB_Angle */

/* Day */

/* DayOfWeek */

static const OSEnumItem DayOfWeek_ENUMTAB[] = {
   { OSUTF8("friday"), 5, 6, 6 },
   { OSUTF8("monday"), 1, 6, 1 },
   { OSUTF8("saturday"), 6, 8, 5 },
   { OSUTF8("sunday"), 7, 6, 7 },
   { OSUTF8("thursday"), 4, 8, 4 },
   { OSUTF8("tuesday"), 2, 7, 0 },
   { OSUTF8("unknown"), 0, 7, 2 },
   { OSUTF8("wednesday"), 3, 9, 3 }
} ;
#define DayOfWeek_ENUMTABSIZE 8

const OSUTF8CHAR* DayOfWeek_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < DayOfWeek_ENUMTABSIZE) {
      return DayOfWeek_ENUMTAB[DayOfWeek_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int DayOfWeek_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, DayOfWeek* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return DayOfWeek_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int DayOfWeek_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, DayOfWeek* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, DayOfWeek_ENUMTAB, 
      DayOfWeek_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (DayOfWeek)DayOfWeek_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* DegreesLat */

/* DegreesLong */

/* AddGrpB_Elevation */

/* Holiday */

static const OSEnumItem Holiday_ENUMTAB[] = {
   { OSUTF8("holiday"), 1, 7, 1 },
   { OSUTF8("weekday"), 0, 7, 0 }
} ;
#define Holiday_ENUMTABSIZE 2

const OSUTF8CHAR* Holiday_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < Holiday_ENUMTABSIZE) {
      return Holiday_ENUMTAB[Holiday_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int Holiday_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, Holiday* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return Holiday_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int Holiday_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, Holiday* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, Holiday_ENUMTAB, 
      Holiday_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (Holiday)Holiday_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* Hour */

/* LatitudeDMS */

/* LongitudeDMS */

/* MaxTimetoChange */

/* MinTimetoChange */

/* Minute */

/* MinutesAngle */

/* Month */

/* AddGrpB_MsgCount */

/* Second */

/* SecondsAngle */

/* SummerTime */

static const OSEnumItem SummerTime_ENUMTAB[] = {
   { OSUTF8("inSummerTime"), 1, 12, 1 },
   { OSUTF8("notInSummerTime"), 0, 15, 0 }
} ;
#define SummerTime_ENUMTABSIZE 2

const OSUTF8CHAR* SummerTime_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SummerTime_ENUMTABSIZE) {
      return SummerTime_ENUMTAB[SummerTime_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SummerTime_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SummerTime* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SummerTime_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SummerTime_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, SummerTime* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, SummerTime_ENUMTAB, 
      SummerTime_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SummerTime)SummerTime_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* TenthSecond */

/* TimeRemaining */

/* Year */

/* LatitudeDMS2 */

/* LongitudeDMS2 */

/* Node_LLdms_48b */

/* Node_LLdms_80b */

/* LaneDataAttribute_addGrpB */

int asn1Init_LaneDataAttribute_addGrpB (LaneDataAttribute_addGrpB* pvalue)
{
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_LaneDataAttribute_addGrpB (OSCTXT *pctxt, 
   LaneDataAttribute_addGrpB* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* MovementEvent_addGrpB */

int asn1Init_MovementEvent_addGrpB (MovementEvent_addGrpB* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_MovementEvent_addGrpB (OSCTXT *pctxt, 
   MovementEvent_addGrpB* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* NodeOffsetPointXY_addGrpB */

int asn1Init_NodeOffsetPointXY_addGrpB (NodeOffsetPointXY_addGrpB* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_NodeOffsetPointXY_addGrpB (OSCTXT *pctxt, 
   NodeOffsetPointXY_addGrpB* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.posA) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.posA);
            pvalue->u.posA = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.posB) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.posB);
            pvalue->u.posB = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

/* Position3D_addGrpB */

int asn1Init_Position3D_addGrpB (Position3D_addGrpB* pvalue)
{
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_Position3D_addGrpB (OSCTXT *pctxt, Position3D_addGrpB* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* AddGrpB_TimeMark */

