/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.2.4, Date: 06-Mar-2019.
 */
#include "DSRC.h"
#include "rtsrc/rtPrintToStream.h"
#include "rtxsrc/rtxCharStr.h"
#include "rtxsrc/rtxCommon.h"

int asn1PrtToStrm_PartII_Id (OSCTXT *pctxt, 
   const char* name, const PartII_Id* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Acceleration (OSCTXT *pctxt, 
   const char* name, const Acceleration* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_AccelerationConfidence (OSCTXT *pctxt, 
   const char* name, const AccelerationConfidence* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = accl-100-00\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = accl-010-00\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = accl-005-00\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = accl-001-00\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = accl-000-10\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = accl-000-05\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = accl-000-01\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_AdvisorySpeedType (OSCTXT *pctxt, 
   const char* name, const AdvisorySpeedType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = none\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = greenwave\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = ecoDrive\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = transit\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_AllowedManeuvers (OSCTXT *pctxt, 
   const char* name, const AllowedManeuvers* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 16), pvalue->data);
   return 0;
}

int asn1PrtToStrm_AmbientAirPressure (OSCTXT *pctxt, 
   const char* name, const AmbientAirPressure* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_AmbientAirTemperature (OSCTXT *pctxt, 
   const char* name, const AmbientAirTemperature* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Angle (OSCTXT *pctxt, const char* name, const Angle* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_AnimalPropelledType (OSCTXT *pctxt, 
   const char* name, const AnimalPropelledType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = otherTypes\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = animalMounted\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = animalDrawnCarriage\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_AnimalType (OSCTXT *pctxt, 
   const char* name, const AnimalType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = serviceUse\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = pet\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = farm\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_AntiLockBrakeStatus (OSCTXT *pctxt, 
   const char* name, const AntiLockBrakeStatus* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = off\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = on\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = engaged\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_ApproachID (OSCTXT *pctxt, 
   const char* name, const ApproachID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Attachment (OSCTXT *pctxt, 
   const char* name, const Attachment* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = stroller\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = bicycleTrailer\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = cart\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = wheelchair\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = otherWalkAssistAttachments\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = pet\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_AttachmentRadius (OSCTXT *pctxt, 
   const char* name, const AttachmentRadius* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_AuxiliaryBrakeStatus (OSCTXT *pctxt, 
   const char* name, const AuxiliaryBrakeStatus* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = off\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = on\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = reserved\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_BasicVehicleClass (OSCTXT *pctxt, 
   const char* name, const BasicVehicleClass* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_BasicVehicleRole (OSCTXT *pctxt, 
   const char* name, const BasicVehicleRole* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = basicVehicle\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = publicTransport\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = specialTransport\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = dangerousGoods\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = roadWork\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = roadRescue\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = emergency\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = safetyCar\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = none-unknown\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = truck\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = motorcycle\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = roadSideSource\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = police\n");
         break;
      case 13:
         rtxPrintToStream (pctxt, " = fire\n");
         break;
      case 14:
         rtxPrintToStream (pctxt, " = ambulance\n");
         break;
      case 15:
         rtxPrintToStream (pctxt, " = dot\n");
         break;
      case 16:
         rtxPrintToStream (pctxt, " = transit\n");
         break;
      case 17:
         rtxPrintToStream (pctxt, " = slowMoving\n");
         break;
      case 18:
         rtxPrintToStream (pctxt, " = stopNgo\n");
         break;
      case 19:
         rtxPrintToStream (pctxt, " = cyclist\n");
         break;
      case 20:
         rtxPrintToStream (pctxt, " = pedestrian\n");
         break;
      case 21:
         rtxPrintToStream (pctxt, " = nonMotorized\n");
         break;
      case 22:
         rtxPrintToStream (pctxt, " = military\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_BrakeAppliedPressure (OSCTXT *pctxt, 
   const char* name, const BrakeAppliedPressure* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = minPressure\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = bkLvl-2\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = bkLvl-3\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = bkLvl-4\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = bkLvl-5\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = bkLvl-6\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = bkLvl-7\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = bkLvl-8\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = bkLvl-9\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = bkLvl-10\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = bkLvl-11\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = bkLvl-12\n");
         break;
      case 13:
         rtxPrintToStream (pctxt, " = bkLvl-13\n");
         break;
      case 14:
         rtxPrintToStream (pctxt, " = bkLvl-14\n");
         break;
      case 15:
         rtxPrintToStream (pctxt, " = maxPressure\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_BrakeAppliedStatus (OSCTXT *pctxt, 
   const char* name, const BrakeAppliedStatus* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 8), pvalue->data);
   return 0;
}

int asn1PrtToStrm_BrakeBoostApplied (OSCTXT *pctxt, 
   const char* name, const BrakeBoostApplied* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = off\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = on\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_BumperHeight (OSCTXT *pctxt, 
   const char* name, const BumperHeight* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_CoarseHeading (OSCTXT *pctxt, 
   const char* name, const CoarseHeading* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_CodeWord (OSCTXT *pctxt, 
   const char* name, const CodeWord* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
   return 0;
}

int asn1PrtToStrm_CoefficientOfFriction (OSCTXT *pctxt, 
   const char* name, const CoefficientOfFriction* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Confidence (OSCTXT *pctxt, 
   const char* name, const Confidence* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Count (OSCTXT *pctxt, const char* name, const Count* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DDay (OSCTXT *pctxt, const char* name, const DDay* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DeltaAngle (OSCTXT *pctxt, 
   const char* name, const DeltaAngle* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DeltaTime (OSCTXT *pctxt, 
   const char* name, const DeltaTime* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DescriptiveName (OSCTXT *pctxt, 
   const char* name, const DescriptiveName pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamCharStr (pctxt, name, pvalue);
   return 0;
}

int asn1PrtToStrm_DHour (OSCTXT *pctxt, const char* name, const DHour* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DirectionOfUse (OSCTXT *pctxt, 
   const char* name, const DirectionOfUse* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = forward\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = reverse\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = both\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_DistanceUnits (OSCTXT *pctxt, 
   const char* name, const DistanceUnits* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = centimeter\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = cm2-5\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = decimeter\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = meter\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = kilometer\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = foot\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = yard\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = mile\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_DMinute (OSCTXT *pctxt, 
   const char* name, const DMinute* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DMonth (OSCTXT *pctxt, 
   const char* name, const DMonth* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DOffset (OSCTXT *pctxt, 
   const char* name, const DOffset* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DrivenLineOffsetLg (OSCTXT *pctxt, 
   const char* name, const DrivenLineOffsetLg* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DrivenLineOffsetSm (OSCTXT *pctxt, 
   const char* name, const DrivenLineOffsetSm* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DrivingWheelAngle (OSCTXT *pctxt, 
   const char* name, const DrivingWheelAngle* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DSecond (OSCTXT *pctxt, 
   const char* name, const DSecond* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DSRCmsgID (OSCTXT *pctxt, 
   const char* name, const DSRCmsgID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Duration (OSCTXT *pctxt, 
   const char* name, const Duration* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DYear (OSCTXT *pctxt, const char* name, const DYear* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_ElevationConfidence (OSCTXT *pctxt, 
   const char* name, const ElevationConfidence* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = elev-500-00\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = elev-200-00\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = elev-100-00\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = elev-050-00\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = elev-020-00\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = elev-010-00\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = elev-005-00\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = elev-002-00\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = elev-001-00\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = elev-000-50\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = elev-000-20\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = elev-000-10\n");
         break;
      case 13:
         rtxPrintToStream (pctxt, " = elev-000-05\n");
         break;
      case 14:
         rtxPrintToStream (pctxt, " = elev-000-02\n");
         break;
      case 15:
         rtxPrintToStream (pctxt, " = elev-000-01\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_Elevation (OSCTXT *pctxt, 
   const char* name, const Elevation* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Extent (OSCTXT *pctxt, 
   const char* name, const Extent* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = useInstantlyOnly\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = useFor3meters\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = useFor10meters\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = useFor50meters\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = useFor100meters\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = useFor500meters\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = useFor1000meters\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = useFor5000meters\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = useFor10000meters\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = useFor50000meters\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = useFor100000meters\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = useFor500000meters\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = useFor1000000meters\n");
         break;
      case 13:
         rtxPrintToStream (pctxt, " = useFor5000000meters\n");
         break;
      case 14:
         rtxPrintToStream (pctxt, " = useFor10000000meters\n");
         break;
      case 15:
         rtxPrintToStream (pctxt, " = forever\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_ExteriorLights (OSCTXT *pctxt, 
   const char* name, const ExteriorLights* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceTextExt (pctxt, name, pvalue->numbits, pvalue->data, sizeof(pvalue->data), pvalue->extdata);
   return 0;
}

int asn1PrtToStrm_FuelType (OSCTXT *pctxt, 
   const char* name, const FuelType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_FurtherInfoID (OSCTXT *pctxt, 
   const char* name, const FurtherInfoID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
   return 0;
}

int asn1PrtToStrm_GNSSstatus (OSCTXT *pctxt, 
   const char* name, const GNSSstatus* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 8), pvalue->data);
   return 0;
}

int asn1PrtToStrm_GrossDistance (OSCTXT *pctxt, 
   const char* name, const GrossDistance* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_GrossSpeed (OSCTXT *pctxt, 
   const char* name, const GrossSpeed* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_HeadingConfidence (OSCTXT *pctxt, 
   const char* name, const HeadingConfidence* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = prec10deg\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = prec05deg\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = prec01deg\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = prec0-1deg\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = prec0-05deg\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = prec0-01deg\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = prec0-0125deg\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_Heading (OSCTXT *pctxt, 
   const char* name, const Heading* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_HeadingSlice (OSCTXT *pctxt, 
   const char* name, const HeadingSlice* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 16), pvalue->data);
   return 0;
}

int asn1PrtToStrm_IntersectionID (OSCTXT *pctxt, 
   const char* name, const IntersectionID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_IntersectionStatusObject (OSCTXT *pctxt, 
   const char* name, const IntersectionStatusObject* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 16), pvalue->data);
   return 0;
}

int asn1PrtToStrm_IsDolly (OSCTXT *pctxt, 
   const char* name, const IsDolly* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBoolean (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Iso3833VehicleType (OSCTXT *pctxt, 
   const char* name, const Iso3833VehicleType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_ITIStextPhrase (OSCTXT *pctxt, 
   const char* name, const ITIStextPhrase pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamCharStr (pctxt, name, pvalue);
   return 0;
}

int asn1PrtToStrm_AxleLocation (OSCTXT *pctxt, 
   const char* name, const AxleLocation* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_AxleWeight (OSCTXT *pctxt, 
   const char* name, const AxleWeight* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_CargoWeight (OSCTXT *pctxt, 
   const char* name, const CargoWeight* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DriveAxleLiftAirPressure (OSCTXT *pctxt, 
   const char* name, const DriveAxleLiftAirPressure* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DriveAxleLocation (OSCTXT *pctxt, 
   const char* name, const DriveAxleLocation* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DriveAxleLubePressure (OSCTXT *pctxt, 
   const char* name, const DriveAxleLubePressure* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_DriveAxleTemperature (OSCTXT *pctxt, 
   const char* name, const DriveAxleTemperature* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_SteeringAxleLubePressure (OSCTXT *pctxt, 
   const char* name, const SteeringAxleLubePressure* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_SteeringAxleTemperature (OSCTXT *pctxt, 
   const char* name, const SteeringAxleTemperature* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_TireLeakageRate (OSCTXT *pctxt, 
   const char* name, const TireLeakageRate* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_TireLocation (OSCTXT *pctxt, 
   const char* name, const TireLocation* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_TirePressureThresholdDetection (OSCTXT *pctxt, 
   const char* name, const TirePressureThresholdDetection* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = noData\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = overPressure\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = noWarningPressure\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = underPressure\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = extremeUnderPressure\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = undefined\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = errorIndicator\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = notAvailable\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_TirePressure (OSCTXT *pctxt, 
   const char* name, const TirePressure* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_TireTemp (OSCTXT *pctxt, 
   const char* name, const TireTemp* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_TrailerWeight (OSCTXT *pctxt, 
   const char* name, const TrailerWeight* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_WheelEndElectFault (OSCTXT *pctxt, 
   const char* name, const WheelEndElectFault* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = isOk\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = isNotDefined\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = isError\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = isNotSupported\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_WheelSensorStatus (OSCTXT *pctxt, 
   const char* name, const WheelSensorStatus* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = off\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = on\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = notDefined\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = notSupported\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_LaneAttributes_Barrier (OSCTXT *pctxt, 
   const char* name, const LaneAttributes_Barrier* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 16), pvalue->data);
   return 0;
}

int asn1PrtToStrm_LaneAttributes_Bike (OSCTXT *pctxt, 
   const char* name, const LaneAttributes_Bike* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 16), pvalue->data);
   return 0;
}

int asn1PrtToStrm_LaneAttributes_Crosswalk (OSCTXT *pctxt, 
   const char* name, const LaneAttributes_Crosswalk* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 16), pvalue->data);
   return 0;
}

int asn1PrtToStrm_LaneAttributes_Parking (OSCTXT *pctxt, 
   const char* name, const LaneAttributes_Parking* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 16), pvalue->data);
   return 0;
}

int asn1PrtToStrm_LaneAttributes_Sidewalk (OSCTXT *pctxt, 
   const char* name, const LaneAttributes_Sidewalk* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 16), pvalue->data);
   return 0;
}

int asn1PrtToStrm_LaneAttributes_Striping (OSCTXT *pctxt, 
   const char* name, const LaneAttributes_Striping* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 16), pvalue->data);
   return 0;
}

int asn1PrtToStrm_LaneAttributes_TrackedVehicle (OSCTXT *pctxt, 
   const char* name, const LaneAttributes_TrackedVehicle* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 16), pvalue->data);
   return 0;
}

int asn1PrtToStrm_LaneAttributes_Vehicle (OSCTXT *pctxt, 
   const char* name, const LaneAttributes_Vehicle* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceTextExt (pctxt, name, pvalue->numbits, pvalue->data, sizeof(pvalue->data), pvalue->extdata);
   return 0;
}

int asn1PrtToStrm_LaneConnectionID (OSCTXT *pctxt, 
   const char* name, const LaneConnectionID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_LaneDirection (OSCTXT *pctxt, 
   const char* name, const LaneDirection* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 8), pvalue->data);
   return 0;
}

int asn1PrtToStrm_LaneID (OSCTXT *pctxt, 
   const char* name, const LaneID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_LaneSharing (OSCTXT *pctxt, 
   const char* name, const LaneSharing* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 16), pvalue->data);
   return 0;
}

int asn1PrtToStrm_LaneWidth (OSCTXT *pctxt, 
   const char* name, const LaneWidth* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Latitude (OSCTXT *pctxt, 
   const char* name, const Latitude* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_LayerID (OSCTXT *pctxt, 
   const char* name, const LayerID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_LayerType (OSCTXT *pctxt, 
   const char* name, const LayerType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = none\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = mixedContent\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = generalMapData\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = intersectionData\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = curveData\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = roadwaySectionData\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = parkingAreaData\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = sharedLaneData\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_LightbarInUse (OSCTXT *pctxt, 
   const char* name, const LightbarInUse* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = notInUse\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = inUse\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = yellowCautionLights\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = schooldBusLights\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = arrowSignsActive\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = slowMovingVehicle\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = freqStops\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_Longitude (OSCTXT *pctxt, 
   const char* name, const Longitude* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Location_quality (OSCTXT *pctxt, 
   const char* name, const Location_quality* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = loc-qual-bt1m\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = loc-qual-bt5m\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = loc-qual-bt12m\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = loc-qual-bt50m\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = loc-qual-bt125m\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = loc-qual-bt500m\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = loc-qual-bt1250m\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = loc-qual-unknown\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_Location_tech (OSCTXT *pctxt, 
   const char* name, const Location_tech* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = loc-tech-unknown\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = loc-tech-GNSS\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = loc-tech-DGPS\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = loc-tech-RTK\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = loc-tech-PPP\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = loc-tech-drGPS\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = loc-tech-drDGPS\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = loc-tech-dr\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = loc-tech-nav\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = loc-tech-fault\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_MergeDivergeNodeAngle (OSCTXT *pctxt, 
   const char* name, const MergeDivergeNodeAngle* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_MessageBLOB (OSCTXT *pctxt, 
   const char* name, const MessageBLOB* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
   return 0;
}

int asn1PrtToStrm_MinuteOfTheYear (OSCTXT *pctxt, 
   const char* name, const MinuteOfTheYear* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_MinutesDuration (OSCTXT *pctxt, 
   const char* name, const MinutesDuration* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_MotorizedPropelledType (OSCTXT *pctxt, 
   const char* name, const MotorizedPropelledType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = otherTypes\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = wheelChair\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = bicycle\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = scooter\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = selfBalancingDevice\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_MovementPhaseState (OSCTXT *pctxt, 
   const char* name, const MovementPhaseState* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = dark\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = stop-Then-Proceed\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = stop-And-Remain\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = pre-Movement\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = permissive-Movement-Allowed\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = protected-Movement-Allowed\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = permissive-clearance\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = protected-clearance\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = caution-Conflicting-Traffic\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_MsgCount (OSCTXT *pctxt, 
   const char* name, const MsgCount* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_MsgCRC (OSCTXT *pctxt, 
   const char* name, const MsgCRC* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
   return 0;
}

int asn1PrtToStrm_MultiVehicleResponse (OSCTXT *pctxt, 
   const char* name, const MultiVehicleResponse* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = singleVehicle\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = multiVehicle\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = reserved\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_MUTCDCode (OSCTXT *pctxt, 
   const char* name, const MUTCDCode* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = none\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = regulatory\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = warning\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = maintenance\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = motoristService\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = guide\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = rec\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_NMEA_MsgType (OSCTXT *pctxt, 
   const char* name, const NMEA_MsgType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_NMEA_Payload (OSCTXT *pctxt, 
   const char* name, const NMEA_Payload* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
   return 0;
}

int asn1PrtToStrm_NMEA_Revision (OSCTXT *pctxt, 
   const char* name, const NMEA_Revision* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unknown\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = reserved\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = rev1\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = rev2\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = rev3\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = rev4\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = rev5\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_NodeAttributeLL (OSCTXT *pctxt, 
   const char* name, const NodeAttributeLL* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = reserved\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = stopLine\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = roundedCapStyleA\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = roundedCapStyleB\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = mergePoint\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = divergePoint\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = downstreamStopLine\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = downstreamStartNode\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = closedToTraffic\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = safeIsland\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = curbPresentAtStepOff\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = hydrantPresent\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_NodeAttributeXY (OSCTXT *pctxt, 
   const char* name, const NodeAttributeXY* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = reserved\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = stopLine\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = roundedCapStyleA\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = roundedCapStyleB\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = mergePoint\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = divergePoint\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = downstreamStopLine\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = downstreamStartNode\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = closedToTraffic\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = safeIsland\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = curbPresentAtStepOff\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = hydrantPresent\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_NumberOfParticipantsInCluster (OSCTXT *pctxt, 
   const char* name, const NumberOfParticipantsInCluster* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = small\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = medium\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = large\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_ObjectCount (OSCTXT *pctxt, 
   const char* name, const ObjectCount* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_ObstacleDirection (OSCTXT *pctxt, 
   const char* name, const ObstacleDirection* pvalue)
{
   asn1PrtToStrm_Angle (pctxt, name, pvalue);
   return 0;
}

int asn1PrtToStrm_ObstacleDistance (OSCTXT *pctxt, 
   const char* name, const ObstacleDistance* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Offset_B09 (OSCTXT *pctxt, 
   const char* name, const Offset_B09* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Offset_B10 (OSCTXT *pctxt, 
   const char* name, const Offset_B10* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Offset_B11 (OSCTXT *pctxt, 
   const char* name, const Offset_B11* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Offset_B12 (OSCTXT *pctxt, 
   const char* name, const Offset_B12* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Offset_B13 (OSCTXT *pctxt, 
   const char* name, const Offset_B13* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Offset_B14 (OSCTXT *pctxt, 
   const char* name, const Offset_B14* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Offset_B16 (OSCTXT *pctxt, 
   const char* name, const Offset_B16* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_OffsetLL_B12 (OSCTXT *pctxt, 
   const char* name, const OffsetLL_B12* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_OffsetLL_B14 (OSCTXT *pctxt, 
   const char* name, const OffsetLL_B14* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_OffsetLL_B16 (OSCTXT *pctxt, 
   const char* name, const OffsetLL_B16* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_OffsetLL_B18 (OSCTXT *pctxt, 
   const char* name, const OffsetLL_B18* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_OffsetLL_B22 (OSCTXT *pctxt, 
   const char* name, const OffsetLL_B22* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_OffsetLL_B24 (OSCTXT *pctxt, 
   const char* name, const OffsetLL_B24* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_PayloadData (OSCTXT *pctxt, 
   const char* name, const PayloadData* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
   return 0;
}

int asn1PrtToStrm_PedestrianBicycleDetect (OSCTXT *pctxt, 
   const char* name, const PedestrianBicycleDetect* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBoolean (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_HumanPropelledType (OSCTXT *pctxt, 
   const char* name, const HumanPropelledType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = otherTypes\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = onFoot\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = skateboard\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = pushOrKickScooter\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = wheelchair\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_PersonalAssistive (OSCTXT *pctxt, 
   const char* name, const PersonalAssistive* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceTextExt (pctxt, name, pvalue->numbits, pvalue->data, sizeof(pvalue->data), pvalue->extdata);
   return 0;
}

int asn1PrtToStrm_PersonalClusterRadius (OSCTXT *pctxt, 
   const char* name, const PersonalClusterRadius* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_PersonalCrossingInProgress (OSCTXT *pctxt, 
   const char* name, const PersonalCrossingInProgress* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBoolean (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_PersonalCrossingRequest (OSCTXT *pctxt, 
   const char* name, const PersonalCrossingRequest* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBoolean (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_PersonalDeviceUsageState (OSCTXT *pctxt, 
   const char* name, const PersonalDeviceUsageState* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceTextExt (pctxt, name, pvalue->numbits, pvalue->data, sizeof(pvalue->data), pvalue->extdata);
   return 0;
}

int asn1PrtToStrm_PersonalDeviceUserType (OSCTXT *pctxt, 
   const char* name, const PersonalDeviceUserType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = aPEDESTRIAN\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = aPEDALCYCLIST\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = aPUBLICSAFETYWORKER\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = anANIMAL\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_PivotingAllowed (OSCTXT *pctxt, 
   const char* name, const PivotingAllowed* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBoolean (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_PositionConfidence (OSCTXT *pctxt, 
   const char* name, const PositionConfidence* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = a500m\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = a200m\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = a100m\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = a50m\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = a20m\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = a10m\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = a5m\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = a2m\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = a1m\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = a50cm\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = a20cm\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = a10cm\n");
         break;
      case 13:
         rtxPrintToStream (pctxt, " = a5cm\n");
         break;
      case 14:
         rtxPrintToStream (pctxt, " = a2cm\n");
         break;
      case 15:
         rtxPrintToStream (pctxt, " = a1cm\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_PrioritizationResponseStatus (OSCTXT *pctxt, 
   const char* name, const PrioritizationResponseStatus* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unknown\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = requested\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = processing\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = watchOtherTraffic\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = granted\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = rejected\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = maxPresence\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = reserviceLocked\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_Priority (OSCTXT *pctxt, 
   const char* name, const Priority* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
   return 0;
}

int asn1PrtToStrm_PriorityRequestType (OSCTXT *pctxt, 
   const char* name, const PriorityRequestType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = priorityRequestTypeReserved\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = priorityRequest\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = priorityRequestUpdate\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = priorityCancellation\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_PrivilegedEventFlags (OSCTXT *pctxt, 
   const char* name, const PrivilegedEventFlags* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 16), pvalue->data);
   return 0;
}

int asn1PrtToStrm_ProbeSegmentNumber (OSCTXT *pctxt, 
   const char* name, const ProbeSegmentNumber* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_PublicSafetyAndRoadWorkerActivity (OSCTXT *pctxt, 
   const char* name, const PublicSafetyAndRoadWorkerActivity* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceTextExt (pctxt, name, pvalue->numbits, pvalue->data, sizeof(pvalue->data), pvalue->extdata);
   return 0;
}

int asn1PrtToStrm_PublicSafetyDirectingTrafficSubType (OSCTXT *pctxt, 
   const char* name, const PublicSafetyDirectingTrafficSubType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceTextExt (pctxt, name, pvalue->numbits, pvalue->data, sizeof(pvalue->data), pvalue->extdata);
   return 0;
}

int asn1PrtToStrm_PublicSafetyEventResponderWorkerType (OSCTXT *pctxt, 
   const char* name, const PublicSafetyEventResponderWorkerType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = towOperater\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = fireAndEMSWorker\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = aDOTWorker\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = lawEnforcement\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = hazmatResponder\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = animalControlWorker\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = otherPersonnel\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_RadiusOfCurvature (OSCTXT *pctxt, 
   const char* name, const RadiusOfCurvature* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Radius_B12 (OSCTXT *pctxt, 
   const char* name, const Radius_B12* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_RainSensor (OSCTXT *pctxt, 
   const char* name, const RainSensor* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = none\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = lightMist\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = heavyMist\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = lightRainOrDrizzle\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = rain\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = moderateRain\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = heavyRain\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = heavyDownpour\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_RegionId (OSCTXT *pctxt, 
   const char* name, const RegionId* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_RequestedItem (OSCTXT *pctxt, 
   const char* name, const RequestedItem* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = reserved\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = itemA\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = itemB\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = itemC\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = itemD\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = itemE\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = itemF\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = itemG\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = itemI\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = itemJ\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = itemK\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = itemL\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = itemM\n");
         break;
      case 13:
         rtxPrintToStream (pctxt, " = itemN\n");
         break;
      case 14:
         rtxPrintToStream (pctxt, " = itemO\n");
         break;
      case 15:
         rtxPrintToStream (pctxt, " = itemP\n");
         break;
      case 16:
         rtxPrintToStream (pctxt, " = itemQ\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_RequestID (OSCTXT *pctxt, 
   const char* name, const RequestID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_RequestImportanceLevel (OSCTXT *pctxt, 
   const char* name, const RequestImportanceLevel* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = requestImportanceLevelUnKnown\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = requestImportanceLevel1\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = requestImportanceLevel2\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = requestImportanceLevel3\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = requestImportanceLevel4\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = requestImportanceLevel5\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = requestImportanceLevel6\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = requestImportanceLevel7\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = requestImportanceLevel8\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = requestImportanceLevel9\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = requestImportanceLevel10\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = requestImportanceLevel11\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = requestImportanceLevel12\n");
         break;
      case 13:
         rtxPrintToStream (pctxt, " = requestImportanceLevel13\n");
         break;
      case 14:
         rtxPrintToStream (pctxt, " = requestImportanceLevel14\n");
         break;
      case 15:
         rtxPrintToStream (pctxt, " = requestImportanceReserved\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_RequestSubRole (OSCTXT *pctxt, 
   const char* name, const RequestSubRole* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = requestSubRoleUnKnown\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = requestSubRole1\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = requestSubRole2\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = requestSubRole3\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = requestSubRole4\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = requestSubRole5\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = requestSubRole6\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = requestSubRole7\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = requestSubRole8\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = requestSubRole9\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = requestSubRole10\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = requestSubRole11\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = requestSubRole12\n");
         break;
      case 13:
         rtxPrintToStream (pctxt, " = requestSubRole13\n");
         break;
      case 14:
         rtxPrintToStream (pctxt, " = requestSubRole14\n");
         break;
      case 15:
         rtxPrintToStream (pctxt, " = requestSubRoleReserved\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_ResponseType (OSCTXT *pctxt, 
   const char* name, const ResponseType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = notInUseOrNotEquipped\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = emergency\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = nonEmergency\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = pursuit\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = stationary\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = slowMoving\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = stopAndGoMovement\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_RestrictionAppliesTo (OSCTXT *pctxt, 
   const char* name, const RestrictionAppliesTo* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = none\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = equippedTransit\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = equippedTaxis\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = equippedOther\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = emissionCompliant\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = equippedBicycle\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = weightCompliant\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = heightCompliant\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = pedestrians\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = slowMovingPersons\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = wheelchairUsers\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = visualDisabilities\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = audioDisabilities\n");
         break;
      case 13:
         rtxPrintToStream (pctxt, " = otherUnknownDisabilities\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_RestrictionClassID (OSCTXT *pctxt, 
   const char* name, const RestrictionClassID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_RoadRegulatorID (OSCTXT *pctxt, 
   const char* name, const RoadRegulatorID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_RoadSegmentID (OSCTXT *pctxt, 
   const char* name, const RoadSegmentID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_RoadwayCrownAngle (OSCTXT *pctxt, 
   const char* name, const RoadwayCrownAngle* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_RTCM_Revision (OSCTXT *pctxt, 
   const char* name, const RTCM_Revision* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unknown\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = rtcmRev2\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = rtcmRev3\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = reserved\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_RTCMmessage (OSCTXT *pctxt, 
   const char* name, const RTCMmessage* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
   return 0;
}

int asn1PrtToStrm_Scale_B12 (OSCTXT *pctxt, 
   const char* name, const Scale_B12* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_SecondOfTime (OSCTXT *pctxt, 
   const char* name, const SecondOfTime* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_SegmentAttributeLL (OSCTXT *pctxt, 
   const char* name, const SegmentAttributeLL* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = reserved\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = doNotBlock\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = whiteLine\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = mergingLaneLeft\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = mergingLaneRight\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = curbOnLeft\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = curbOnRight\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = loadingzoneOnLeft\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = loadingzoneOnRight\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = turnOutPointOnLeft\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = turnOutPointOnRight\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = adjacentParkingOnLeft\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = adjacentParkingOnRight\n");
         break;
      case 13:
         rtxPrintToStream (pctxt, " = adjacentBikeLaneOnLeft\n");
         break;
      case 14:
         rtxPrintToStream (pctxt, " = adjacentBikeLaneOnRight\n");
         break;
      case 15:
         rtxPrintToStream (pctxt, " = sharedBikeLane\n");
         break;
      case 16:
         rtxPrintToStream (pctxt, " = bikeBoxInFront\n");
         break;
      case 17:
         rtxPrintToStream (pctxt, " = transitStopOnLeft\n");
         break;
      case 18:
         rtxPrintToStream (pctxt, " = transitStopOnRight\n");
         break;
      case 19:
         rtxPrintToStream (pctxt, " = transitStopInLane\n");
         break;
      case 20:
         rtxPrintToStream (pctxt, " = sharedWithTrackedVehicle\n");
         break;
      case 21:
         rtxPrintToStream (pctxt, " = safeIsland\n");
         break;
      case 22:
         rtxPrintToStream (pctxt, " = lowCurbsPresent\n");
         break;
      case 23:
         rtxPrintToStream (pctxt, " = rumbleStripPresent\n");
         break;
      case 24:
         rtxPrintToStream (pctxt, " = audibleSignalingPresent\n");
         break;
      case 25:
         rtxPrintToStream (pctxt, " = adaptiveTimingPresent\n");
         break;
      case 26:
         rtxPrintToStream (pctxt, " = rfSignalRequestPresent\n");
         break;
      case 27:
         rtxPrintToStream (pctxt, " = partialCurbIntrusion\n");
         break;
      case 28:
         rtxPrintToStream (pctxt, " = taperToLeft\n");
         break;
      case 29:
         rtxPrintToStream (pctxt, " = taperToRight\n");
         break;
      case 30:
         rtxPrintToStream (pctxt, " = taperToCenterLine\n");
         break;
      case 31:
         rtxPrintToStream (pctxt, " = parallelParking\n");
         break;
      case 32:
         rtxPrintToStream (pctxt, " = headInParking\n");
         break;
      case 33:
         rtxPrintToStream (pctxt, " = freeParking\n");
         break;
      case 34:
         rtxPrintToStream (pctxt, " = timeRestrictionsOnParking\n");
         break;
      case 35:
         rtxPrintToStream (pctxt, " = costToPark\n");
         break;
      case 36:
         rtxPrintToStream (pctxt, " = midBlockCurbPresent\n");
         break;
      case 37:
         rtxPrintToStream (pctxt, " = unEvenPavementPresent\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_SegmentAttributeXY (OSCTXT *pctxt, 
   const char* name, const SegmentAttributeXY* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = reserved\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = doNotBlock\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = whiteLine\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = mergingLaneLeft\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = mergingLaneRight\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = curbOnLeft\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = curbOnRight\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = loadingzoneOnLeft\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = loadingzoneOnRight\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = turnOutPointOnLeft\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = turnOutPointOnRight\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = adjacentParkingOnLeft\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = adjacentParkingOnRight\n");
         break;
      case 13:
         rtxPrintToStream (pctxt, " = adjacentBikeLaneOnLeft\n");
         break;
      case 14:
         rtxPrintToStream (pctxt, " = adjacentBikeLaneOnRight\n");
         break;
      case 15:
         rtxPrintToStream (pctxt, " = sharedBikeLane\n");
         break;
      case 16:
         rtxPrintToStream (pctxt, " = bikeBoxInFront\n");
         break;
      case 17:
         rtxPrintToStream (pctxt, " = transitStopOnLeft\n");
         break;
      case 18:
         rtxPrintToStream (pctxt, " = transitStopOnRight\n");
         break;
      case 19:
         rtxPrintToStream (pctxt, " = transitStopInLane\n");
         break;
      case 20:
         rtxPrintToStream (pctxt, " = sharedWithTrackedVehicle\n");
         break;
      case 21:
         rtxPrintToStream (pctxt, " = safeIsland\n");
         break;
      case 22:
         rtxPrintToStream (pctxt, " = lowCurbsPresent\n");
         break;
      case 23:
         rtxPrintToStream (pctxt, " = rumbleStripPresent\n");
         break;
      case 24:
         rtxPrintToStream (pctxt, " = audibleSignalingPresent\n");
         break;
      case 25:
         rtxPrintToStream (pctxt, " = adaptiveTimingPresent\n");
         break;
      case 26:
         rtxPrintToStream (pctxt, " = rfSignalRequestPresent\n");
         break;
      case 27:
         rtxPrintToStream (pctxt, " = partialCurbIntrusion\n");
         break;
      case 28:
         rtxPrintToStream (pctxt, " = taperToLeft\n");
         break;
      case 29:
         rtxPrintToStream (pctxt, " = taperToRight\n");
         break;
      case 30:
         rtxPrintToStream (pctxt, " = taperToCenterLine\n");
         break;
      case 31:
         rtxPrintToStream (pctxt, " = parallelParking\n");
         break;
      case 32:
         rtxPrintToStream (pctxt, " = headInParking\n");
         break;
      case 33:
         rtxPrintToStream (pctxt, " = freeParking\n");
         break;
      case 34:
         rtxPrintToStream (pctxt, " = timeRestrictionsOnParking\n");
         break;
      case 35:
         rtxPrintToStream (pctxt, " = costToPark\n");
         break;
      case 36:
         rtxPrintToStream (pctxt, " = midBlockCurbPresent\n");
         break;
      case 37:
         rtxPrintToStream (pctxt, " = unEvenPavementPresent\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_SemiMajorAxisAccuracy (OSCTXT *pctxt, 
   const char* name, const SemiMajorAxisAccuracy* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_SemiMajorAxisOrientation (OSCTXT *pctxt, 
   const char* name, const SemiMajorAxisOrientation* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_SemiMinorAxisAccuracy (OSCTXT *pctxt, 
   const char* name, const SemiMinorAxisAccuracy* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_SignalGroupID (OSCTXT *pctxt, 
   const char* name, const SignalGroupID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_SignalReqScheme (OSCTXT *pctxt, 
   const char* name, const SignalReqScheme* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
   return 0;
}

int asn1PrtToStrm_SignPrority (OSCTXT *pctxt, 
   const char* name, const SignPrority* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_SirenInUse (OSCTXT *pctxt, 
   const char* name, const SirenInUse* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = notInUse\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = inUse\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = reserved\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_SpeedAdvice (OSCTXT *pctxt, 
   const char* name, const SpeedAdvice* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_SpeedConfidence (OSCTXT *pctxt, 
   const char* name, const SpeedConfidence* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = prec100ms\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = prec10ms\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = prec5ms\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = prec1ms\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = prec0-1ms\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = prec0-05ms\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = prec0-01ms\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_SpeedLimitType (OSCTXT *pctxt, 
   const char* name, const SpeedLimitType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unknown\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = maxSpeedInSchoolZone\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = maxSpeedInSchoolZoneWhenChildrenArePresent\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = maxSpeedInConstructionZone\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = vehicleMinSpeed\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = vehicleMaxSpeed\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = vehicleNightMaxSpeed\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = truckMinSpeed\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = truckMaxSpeed\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = truckNightMaxSpeed\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = vehiclesWithTrailersMinSpeed\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = vehiclesWithTrailersMaxSpeed\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = vehiclesWithTrailersNightMaxSpeed\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_SpeedProfileMeasurement (OSCTXT *pctxt, 
   const char* name, const SpeedProfileMeasurement* pvalue)
{
   asn1PrtToStrm_GrossSpeed (pctxt, name, pvalue);
   return 0;
}

int asn1PrtToStrm_Speed (OSCTXT *pctxt, const char* name, const Speed* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_SSPindex (OSCTXT *pctxt, 
   const char* name, const SSPindex* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_StabilityControlStatus (OSCTXT *pctxt, 
   const char* name, const StabilityControlStatus* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = off\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = on\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = engaged\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_StationID (OSCTXT *pctxt, 
   const char* name, const StationID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_SteeringWheelAngleConfidence (OSCTXT *pctxt, 
   const char* name, const SteeringWheelAngleConfidence* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = prec2deg\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = prec1deg\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = prec0-02deg\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_SteeringWheelAngleRateOfChange (OSCTXT *pctxt, 
   const char* name, const SteeringWheelAngleRateOfChange* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_SteeringWheelAngle (OSCTXT *pctxt, 
   const char* name, const SteeringWheelAngle* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_SunSensor (OSCTXT *pctxt, 
   const char* name, const SunSensor* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_TemporaryID (OSCTXT *pctxt, 
   const char* name, const TemporaryID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
   return 0;
}

int asn1PrtToStrm_TermDistance (OSCTXT *pctxt, 
   const char* name, const TermDistance* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_TermTime (OSCTXT *pctxt, 
   const char* name, const TermTime* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_ThrottleConfidence (OSCTXT *pctxt, 
   const char* name, const ThrottleConfidence* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = prec10percent\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = prec1percent\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = prec0-5percent\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_ThrottlePosition (OSCTXT *pctxt, 
   const char* name, const ThrottlePosition* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_TimeConfidence (OSCTXT *pctxt, 
   const char* name, const TimeConfidence* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = time-100-000\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = time-050-000\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = time-020-000\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = time-010-000\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = time-002-000\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = time-001-000\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = time-000-500\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = time-000-200\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = time-000-100\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = time-000-050\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = time-000-020\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = time-000-010\n");
         break;
      case 13:
         rtxPrintToStream (pctxt, " = time-000-005\n");
         break;
      case 14:
         rtxPrintToStream (pctxt, " = time-000-002\n");
         break;
      case 15:
         rtxPrintToStream (pctxt, " = time-000-001\n");
         break;
      case 16:
         rtxPrintToStream (pctxt, " = time-000-000-5\n");
         break;
      case 17:
         rtxPrintToStream (pctxt, " = time-000-000-2\n");
         break;
      case 18:
         rtxPrintToStream (pctxt, " = time-000-000-1\n");
         break;
      case 19:
         rtxPrintToStream (pctxt, " = time-000-000-05\n");
         break;
      case 20:
         rtxPrintToStream (pctxt, " = time-000-000-02\n");
         break;
      case 21:
         rtxPrintToStream (pctxt, " = time-000-000-01\n");
         break;
      case 22:
         rtxPrintToStream (pctxt, " = time-000-000-005\n");
         break;
      case 23:
         rtxPrintToStream (pctxt, " = time-000-000-002\n");
         break;
      case 24:
         rtxPrintToStream (pctxt, " = time-000-000-001\n");
         break;
      case 25:
         rtxPrintToStream (pctxt, " = time-000-000-000-5\n");
         break;
      case 26:
         rtxPrintToStream (pctxt, " = time-000-000-000-2\n");
         break;
      case 27:
         rtxPrintToStream (pctxt, " = time-000-000-000-1\n");
         break;
      case 28:
         rtxPrintToStream (pctxt, " = time-000-000-000-05\n");
         break;
      case 29:
         rtxPrintToStream (pctxt, " = time-000-000-000-02\n");
         break;
      case 30:
         rtxPrintToStream (pctxt, " = time-000-000-000-01\n");
         break;
      case 31:
         rtxPrintToStream (pctxt, " = time-000-000-000-005\n");
         break;
      case 32:
         rtxPrintToStream (pctxt, " = time-000-000-000-002\n");
         break;
      case 33:
         rtxPrintToStream (pctxt, " = time-000-000-000-001\n");
         break;
      case 34:
         rtxPrintToStream (pctxt, " = time-000-000-000-000-5\n");
         break;
      case 35:
         rtxPrintToStream (pctxt, " = time-000-000-000-000-2\n");
         break;
      case 36:
         rtxPrintToStream (pctxt, " = time-000-000-000-000-1\n");
         break;
      case 37:
         rtxPrintToStream (pctxt, " = time-000-000-000-000-05\n");
         break;
      case 38:
         rtxPrintToStream (pctxt, " = time-000-000-000-000-02\n");
         break;
      case 39:
         rtxPrintToStream (pctxt, " = time-000-000-000-000-01\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_TimeIntervalConfidence (OSCTXT *pctxt, 
   const char* name, const TimeIntervalConfidence* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_TimeMark (OSCTXT *pctxt, 
   const char* name, const TimeMark* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_TimeOffset (OSCTXT *pctxt, 
   const char* name, const TimeOffset* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_TractionControlStatus (OSCTXT *pctxt, 
   const char* name, const TractionControlStatus* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = off\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = on\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = engaged\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_TrailerMass (OSCTXT *pctxt, 
   const char* name, const TrailerMass* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_TransitStatus (OSCTXT *pctxt, 
   const char* name, const TransitStatus* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 8), pvalue->data);
   return 0;
}

int asn1PrtToStrm_TransitVehicleOccupancy (OSCTXT *pctxt, 
   const char* name, const TransitVehicleOccupancy* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = occupancyUnknown\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = occupancyEmpty\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = occupancyVeryLow\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = occupancyLow\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = occupancyMed\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = occupancyHigh\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = occupancyNearlyFull\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = occupancyFull\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_TransitVehicleStatus (OSCTXT *pctxt, 
   const char* name, const TransitVehicleStatus* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 8), pvalue->data);
   return 0;
}

int asn1PrtToStrm_TransmissionState (OSCTXT *pctxt, 
   const char* name, const TransmissionState* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = neutral\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = park\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = forwardGears\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = reverseGears\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = reserved1\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = reserved2\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = reserved3\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_TravelerInfoType (OSCTXT *pctxt, 
   const char* name, const TravelerInfoType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unknown\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = advisory\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = roadSignage\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = commercialSignage\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_UniqueMSGID (OSCTXT *pctxt, 
   const char* name, const UniqueMSGID* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
   return 0;
}

int asn1PrtToStrm_URL_Base (OSCTXT *pctxt, 
   const char* name, const URL_Base pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamCharStr (pctxt, name, pvalue);
   return 0;
}

int asn1PrtToStrm_URL_Link (OSCTXT *pctxt, 
   const char* name, const URL_Link pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamCharStr (pctxt, name, pvalue);
   return 0;
}

int asn1PrtToStrm_URL_Short (OSCTXT *pctxt, 
   const char* name, const URL_Short pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamCharStr (pctxt, name, pvalue);
   return 0;
}

int asn1PrtToStrm_UserSizeAndBehaviour (OSCTXT *pctxt, 
   const char* name, const UserSizeAndBehaviour* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceTextExt (pctxt, name, pvalue->numbits, pvalue->data, sizeof(pvalue->data), pvalue->extdata);
   return 0;
}

int asn1PrtToStrm_VehicleEventFlags (OSCTXT *pctxt, 
   const char* name, const VehicleEventFlags* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceTextExt (pctxt, name, pvalue->numbits, pvalue->data, sizeof(pvalue->data), pvalue->extdata);
   return 0;
}

int asn1PrtToStrm_VehicleHeight (OSCTXT *pctxt, 
   const char* name, const VehicleHeight* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_VehicleLength (OSCTXT *pctxt, 
   const char* name, const VehicleLength* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_VehicleMass (OSCTXT *pctxt, 
   const char* name, const VehicleMass* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_VehicleStatusDeviceTypeTag (OSCTXT *pctxt, 
   const char* name, const VehicleStatusDeviceTypeTag* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unknown\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = lights\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = wipers\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = brakes\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = stab\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = trac\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = abs\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = sunS\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = rainS\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = airTemp\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = steering\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = vertAccelThres\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = vertAccel\n");
         break;
      case 13:
         rtxPrintToStream (pctxt, " = hozAccelLong\n");
         break;
      case 14:
         rtxPrintToStream (pctxt, " = hozAccelLat\n");
         break;
      case 15:
         rtxPrintToStream (pctxt, " = hozAccelCon\n");
         break;
      case 16:
         rtxPrintToStream (pctxt, " = accel4way\n");
         break;
      case 17:
         rtxPrintToStream (pctxt, " = confidenceSet\n");
         break;
      case 18:
         rtxPrintToStream (pctxt, " = obDist\n");
         break;
      case 19:
         rtxPrintToStream (pctxt, " = obDirect\n");
         break;
      case 20:
         rtxPrintToStream (pctxt, " = yaw\n");
         break;
      case 21:
         rtxPrintToStream (pctxt, " = yawRateCon\n");
         break;
      case 22:
         rtxPrintToStream (pctxt, " = dateTime\n");
         break;
      case 23:
         rtxPrintToStream (pctxt, " = fullPos\n");
         break;
      case 24:
         rtxPrintToStream (pctxt, " = position2D\n");
         break;
      case 25:
         rtxPrintToStream (pctxt, " = position3D\n");
         break;
      case 26:
         rtxPrintToStream (pctxt, " = vehicle\n");
         break;
      case 27:
         rtxPrintToStream (pctxt, " = speedHeadC\n");
         break;
      case 28:
         rtxPrintToStream (pctxt, " = speedC\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_VehicleType (OSCTXT *pctxt, 
   const char* name, const VehicleType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = none\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = unknown\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = special\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = moto\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = car\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = carOther\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = bus\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = axleCnt2\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = axleCnt3\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = axleCnt4\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = axleCnt4Trailer\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = axleCnt5Trailer\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = axleCnt6Trailer\n");
         break;
      case 13:
         rtxPrintToStream (pctxt, " = axleCnt5MultiTrailer\n");
         break;
      case 14:
         rtxPrintToStream (pctxt, " = axleCnt6MultiTrailer\n");
         break;
      case 15:
         rtxPrintToStream (pctxt, " = axleCnt7MultiTrailer\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_VehicleWidth (OSCTXT *pctxt, 
   const char* name, const VehicleWidth* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Velocity (OSCTXT *pctxt, 
   const char* name, const Velocity* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_VerticalAccelerationThreshold (OSCTXT *pctxt, 
   const char* name, const VerticalAccelerationThreshold* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, name, OS_MIN(pvalue->numbits, 8), pvalue->data);
   return 0;
}

int asn1PrtToStrm_VerticalAcceleration (OSCTXT *pctxt, 
   const char* name, const VerticalAcceleration* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_VertOffset_B07 (OSCTXT *pctxt, 
   const char* name, const VertOffset_B07* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_VertOffset_B08 (OSCTXT *pctxt, 
   const char* name, const VertOffset_B08* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_VertOffset_B09 (OSCTXT *pctxt, 
   const char* name, const VertOffset_B09* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_VertOffset_B10 (OSCTXT *pctxt, 
   const char* name, const VertOffset_B10* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_VertOffset_B11 (OSCTXT *pctxt, 
   const char* name, const VertOffset_B11* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_VertOffset_B12 (OSCTXT *pctxt, 
   const char* name, const VertOffset_B12* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_VINstring (OSCTXT *pctxt, 
   const char* name, const VINstring* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
   return 0;
}

int asn1PrtToStrm_WaitOnStopline (OSCTXT *pctxt, 
   const char* name, const WaitOnStopline* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBoolean (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_WiperRate (OSCTXT *pctxt, 
   const char* name, const WiperRate* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_WiperStatus (OSCTXT *pctxt, 
   const char* name, const WiperStatus* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = off\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = intermittent\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = low\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = high\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = washerInUse\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = automaticPresent\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_YawRateConfidence (OSCTXT *pctxt, 
   const char* name, const YawRateConfidence* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = degSec-100-00\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = degSec-010-00\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = degSec-005-00\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = degSec-001-00\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = degSec-000-10\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = degSec-000-05\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = degSec-000-01\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_YawRate (OSCTXT *pctxt, 
   const char* name, const YawRate* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_ZoneLength (OSCTXT *pctxt, 
   const char* name, const ZoneLength* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_Zoom (OSCTXT *pctxt, const char* name, const Zoom* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_MessageFrame (OSCTXT *pctxt, 
   const char* name, const MessageFrame* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_DSRCmsgID (pctxt, "messageId", &pvalue->messageId);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, "value",
      pvalue->value.numocts, pvalue->value.data);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_PositionalAccuracy (OSCTXT *pctxt, 
   const char* name, const PositionalAccuracy* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_SemiMajorAxisAccuracy (pctxt, "semiMajor", &pvalue->semiMajor);

   asn1PrtToStrm_SemiMinorAxisAccuracy (pctxt, "semiMinor", &pvalue->semiMinor);

   asn1PrtToStrm_SemiMajorAxisOrientation (pctxt, "orientation", &pvalue->orientation);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_AccelerationSet4Way (OSCTXT *pctxt, 
   const char* name, const AccelerationSet4Way* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Acceleration (pctxt, "long_", &pvalue->long_);

   asn1PrtToStrm_Acceleration (pctxt, "lat", &pvalue->lat);

   asn1PrtToStrm_VerticalAcceleration (pctxt, "vert", &pvalue->vert);

   asn1PrtToStrm_YawRate (pctxt, "yaw", &pvalue->yaw);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_BrakeSystemStatus (OSCTXT *pctxt, 
   const char* name, const BrakeSystemStatus* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_BrakeAppliedStatus (pctxt, "wheelBrakes", &pvalue->wheelBrakes);

   asn1PrtToStrm_TractionControlStatus (pctxt, "traction", &pvalue->traction);

   asn1PrtToStrm_AntiLockBrakeStatus (pctxt, "abs_", &pvalue->abs_);

   asn1PrtToStrm_StabilityControlStatus (pctxt, "scs", &pvalue->scs);

   asn1PrtToStrm_BrakeBoostApplied (pctxt, "brakeBoost", &pvalue->brakeBoost);

   asn1PrtToStrm_AuxiliaryBrakeStatus (pctxt, "auxBrakes", &pvalue->auxBrakes);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleSize (OSCTXT *pctxt, 
   const char* name, const VehicleSize* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_VehicleWidth (pctxt, "width", &pvalue->width);

   asn1PrtToStrm_VehicleLength (pctxt, "length", &pvalue->length);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_BSMcoreData (OSCTXT *pctxt, 
   const char* name, const BSMcoreData* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_MsgCount (pctxt, "msgCnt", &pvalue->msgCnt);

   asn1PrtToStrm_TemporaryID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_DSecond (pctxt, "secMark", &pvalue->secMark);

   asn1PrtToStrm_Latitude (pctxt, "lat", &pvalue->lat);

   asn1PrtToStrm_Longitude (pctxt, "long_", &pvalue->long_);

   asn1PrtToStrm_Elevation (pctxt, "elev", &pvalue->elev);

   asn1PrtToStrm_PositionalAccuracy (pctxt, "accuracy", &pvalue->accuracy);

   asn1PrtToStrm_TransmissionState (pctxt, "transmission", &pvalue->transmission);

   asn1PrtToStrm_Speed (pctxt, "speed", &pvalue->speed);

   asn1PrtToStrm_Heading (pctxt, "heading", &pvalue->heading);

   asn1PrtToStrm_SteeringWheelAngle (pctxt, "angle", &pvalue->angle);

   asn1PrtToStrm_AccelerationSet4Way (pctxt, "accelSet", &pvalue->accelSet);

   asn1PrtToStrm_BrakeSystemStatus (pctxt, "brakes", &pvalue->brakes);

   asn1PrtToStrm_VehicleSize (pctxt, "size", &pvalue->size);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_PartIIcontent (OSCTXT *pctxt, 
   const char* name, const PartIIcontent* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_PartII_Id (pctxt, "partII_Id", &pvalue->partII_Id);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, "partII_Value",
      pvalue->partII_Value.numocts, pvalue->partII_Value.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_BasicSafetyMessage_partII (OSCTXT *pctxt, 
   const char* name, const BasicSafetyMessage_partII* pvalue)
{
   PartIIcontent* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((PartIIcontent*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_PartIIcontent (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_RegionalExtension (OSCTXT *pctxt, 
   const char* name, const RegionalExtension* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_RegionId (pctxt, "regionId", &pvalue->regionId);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamHexStr (pctxt, "regExtValue",
      pvalue->regExtValue.numocts, pvalue->regExtValue.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_BasicSafetyMessage_regional (OSCTXT *pctxt, 
   const char* name, const BasicSafetyMessage_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_BasicSafetyMessage (OSCTXT *pctxt, 
   const char* name, const BasicSafetyMessage* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_BSMcoreData (pctxt, "coreData", &pvalue->coreData);

   if (pvalue->m.partIIPresent) {
      asn1PrtToStrm_BasicSafetyMessage_partII (pctxt, "partII", &pvalue->partII);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_BasicSafetyMessage_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RequestedItemList (OSCTXT *pctxt, 
   const char* name, const RequestedItemList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RequestedItem (pctxt, namebuf, &pvalue->elem[xx1]);
   }
   return 0;
}

int asn1PrtToStrm_CommonSafetyRequest_regional (OSCTXT *pctxt, 
   const char* name, const CommonSafetyRequest_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_CommonSafetyRequest (OSCTXT *pctxt, 
   const char* name, const CommonSafetyRequest* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.timeStampPresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "timeStamp", &pvalue->timeStamp);
   }

   if (pvalue->m.msgCntPresent) {
      asn1PrtToStrm_MsgCount (pctxt, "msgCnt", &pvalue->msgCnt);
   }

   if (pvalue->m.idPresent) {
      asn1PrtToStrm_TemporaryID (pctxt, "id", &pvalue->id);
   }

   asn1PrtToStrm_RequestedItemList (pctxt, "requests", &pvalue->requests);

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_CommonSafetyRequest_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RoadSideAlert_description (OSCTXT *pctxt, 
   const char* name, const RoadSideAlert_description* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_ITIScodes (pctxt, namebuf, &pvalue->elem[xx1]);
   }
   return 0;
}

int asn1PrtToStrm_DDateTime (OSCTXT *pctxt, 
   const char* name, const DDateTime* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.yearPresent) {
      asn1PrtToStrm_DYear (pctxt, "year", &pvalue->year);
   }

   if (pvalue->m.monthPresent) {
      asn1PrtToStrm_DMonth (pctxt, "month", &pvalue->month);
   }

   if (pvalue->m.dayPresent) {
      asn1PrtToStrm_DDay (pctxt, "day", &pvalue->day);
   }

   if (pvalue->m.hourPresent) {
      asn1PrtToStrm_DHour (pctxt, "hour", &pvalue->hour);
   }

   if (pvalue->m.minutePresent) {
      asn1PrtToStrm_DMinute (pctxt, "minute", &pvalue->minute);
   }

   if (pvalue->m.secondPresent) {
      asn1PrtToStrm_DSecond (pctxt, "second", &pvalue->second);
   }

   if (pvalue->m.offsetPresent) {
      asn1PrtToStrm_DOffset (pctxt, "offset", &pvalue->offset);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TransmissionAndSpeed (OSCTXT *pctxt, 
   const char* name, const TransmissionAndSpeed* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_TransmissionState (pctxt, "transmisson", &pvalue->transmisson);

   asn1PrtToStrm_Velocity (pctxt, "speed", &pvalue->speed);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_PositionConfidenceSet (OSCTXT *pctxt, 
   const char* name, const PositionConfidenceSet* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_PositionConfidence (pctxt, "pos", &pvalue->pos);

   asn1PrtToStrm_ElevationConfidence (pctxt, "elevation", &pvalue->elevation);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SpeedandHeadingandThrottleConfidence (OSCTXT *pctxt, 
   const char* name, const SpeedandHeadingandThrottleConfidence* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_HeadingConfidence (pctxt, "heading", &pvalue->heading);

   asn1PrtToStrm_SpeedConfidence (pctxt, "speed", &pvalue->speed);

   asn1PrtToStrm_ThrottleConfidence (pctxt, "throttle", &pvalue->throttle);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_FullPositionVector (OSCTXT *pctxt, 
   const char* name, const FullPositionVector* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.utcTimePresent) {
      asn1PrtToStrm_DDateTime (pctxt, "utcTime", &pvalue->utcTime);
   }

   asn1PrtToStrm_Longitude (pctxt, "long_", &pvalue->long_);

   asn1PrtToStrm_Latitude (pctxt, "lat", &pvalue->lat);

   if (pvalue->m.elevationPresent) {
      asn1PrtToStrm_Elevation (pctxt, "elevation", &pvalue->elevation);
   }

   if (pvalue->m.headingPresent) {
      asn1PrtToStrm_Heading (pctxt, "heading", &pvalue->heading);
   }

   if (pvalue->m.speedPresent) {
      asn1PrtToStrm_TransmissionAndSpeed (pctxt, "speed", &pvalue->speed);
   }

   if (pvalue->m.posAccuracyPresent) {
      asn1PrtToStrm_PositionalAccuracy (pctxt, "posAccuracy", &pvalue->posAccuracy);
   }

   if (pvalue->m.timeConfidencePresent) {
      asn1PrtToStrm_TimeConfidence (pctxt, "timeConfidence", &pvalue->timeConfidence);
   }

   if (pvalue->m.posConfidencePresent) {
      asn1PrtToStrm_PositionConfidenceSet (pctxt, "posConfidence", &pvalue->posConfidence);
   }

   if (pvalue->m.speedConfidencePresent) {
      asn1PrtToStrm_SpeedandHeadingandThrottleConfidence (pctxt, "speedConfidence", &pvalue->speedConfidence);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RoadSideAlert_regional (OSCTXT *pctxt, 
   const char* name, const RoadSideAlert_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_RoadSideAlert (OSCTXT *pctxt, 
   const char* name, const RoadSideAlert* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_MsgCount (pctxt, "msgCnt", &pvalue->msgCnt);

   if (pvalue->m.timeStampPresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "timeStamp", &pvalue->timeStamp);
   }

   asn1PrtToStrm_ITIScodes (pctxt, "typeEvent", &pvalue->typeEvent);

   if (pvalue->m.descriptionPresent) {
      asn1PrtToStrm_RoadSideAlert_description (pctxt, "description", &pvalue->description);
   }

   if (pvalue->m.priorityPresent) {
      asn1PrtToStrm_Priority (pctxt, "priority", &pvalue->priority);
   }

   if (pvalue->m.headingPresent) {
      asn1PrtToStrm_HeadingSlice (pctxt, "heading", &pvalue->heading);
   }

   if (pvalue->m.extentPresent) {
      asn1PrtToStrm_Extent (pctxt, "extent", &pvalue->extent);
   }

   if (pvalue->m.positionPresent) {
      asn1PrtToStrm_FullPositionVector (pctxt, "position", &pvalue->position);
   }

   if (pvalue->m.furtherInfoIDPresent) {
      asn1PrtToStrm_FurtherInfoID (pctxt, "furtherInfoID", &pvalue->furtherInfoID);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RoadSideAlert_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_PrivilegedEvents (OSCTXT *pctxt, 
   const char* name, const PrivilegedEvents* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_SSPindex (pctxt, "sspRights", &pvalue->sspRights);

   asn1PrtToStrm_PrivilegedEventFlags (pctxt, "event", &pvalue->event);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_EmergencyDetails (OSCTXT *pctxt, 
   const char* name, const EmergencyDetails* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_SSPindex (pctxt, "sspRights", &pvalue->sspRights);

   asn1PrtToStrm_SirenInUse (pctxt, "sirenUse", &pvalue->sirenUse);

   asn1PrtToStrm_LightbarInUse (pctxt, "lightsUse", &pvalue->lightsUse);

   asn1PrtToStrm_MultiVehicleResponse (pctxt, "multi", &pvalue->multi);

   if (pvalue->m.eventsPresent) {
      asn1PrtToStrm_PrivilegedEvents (pctxt, "events", &pvalue->events);
   }

   if (pvalue->m.responseTypePresent) {
      asn1PrtToStrm_ResponseType (pctxt, "responseType", &pvalue->responseType);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_EmergencyVehicleAlert_regional (OSCTXT *pctxt, 
   const char* name, const EmergencyVehicleAlert_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_EmergencyVehicleAlert (OSCTXT *pctxt, 
   const char* name, const EmergencyVehicleAlert* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.timeStampPresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "timeStamp", &pvalue->timeStamp);
   }

   if (pvalue->m.idPresent) {
      asn1PrtToStrm_TemporaryID (pctxt, "id", &pvalue->id);
   }

   asn1PrtToStrm_RoadSideAlert (pctxt, "rsaMsg", &pvalue->rsaMsg);

   if (pvalue->m.responseTypePresent) {
      asn1PrtToStrm_ResponseType (pctxt, "responseType", &pvalue->responseType);
   }

   if (pvalue->m.detailsPresent) {
      asn1PrtToStrm_EmergencyDetails (pctxt, "details", &pvalue->details);
   }

   if (pvalue->m.massPresent) {
      asn1PrtToStrm_VehicleMass (pctxt, "mass", &pvalue->mass);
   }

   if (pvalue->m.basicTypePresent) {
      asn1PrtToStrm_VehicleType (pctxt, "basicType", &pvalue->basicType);
   }

   if (pvalue->m.vehicleTypePresent) {
      asn1PrtToStrm_VehicleGroupAffected (pctxt, "vehicleType", &pvalue->vehicleType);
   }

   if (pvalue->m.responseEquipPresent) {
      asn1PrtToStrm_IncidentResponseEquipment (pctxt, "responseEquip", &pvalue->responseEquip);
   }

   if (pvalue->m.responderTypePresent) {
      asn1PrtToStrm_ResponderGroupAffected (pctxt, "responderType", &pvalue->responderType);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_EmergencyVehicleAlert_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_PathHistoryPoint (OSCTXT *pctxt, 
   const char* name, const PathHistoryPoint* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_OffsetLL_B18 (pctxt, "latOffset", &pvalue->latOffset);

   asn1PrtToStrm_OffsetLL_B18 (pctxt, "lonOffset", &pvalue->lonOffset);

   asn1PrtToStrm_VertOffset_B12 (pctxt, "elevationOffset", &pvalue->elevationOffset);

   asn1PrtToStrm_TimeOffset (pctxt, "timeOffset", &pvalue->timeOffset);

   if (pvalue->m.speedPresent) {
      asn1PrtToStrm_Speed (pctxt, "speed", &pvalue->speed);
   }

   if (pvalue->m.posAccuracyPresent) {
      asn1PrtToStrm_PositionalAccuracy (pctxt, "posAccuracy", &pvalue->posAccuracy);
   }

   if (pvalue->m.headingPresent) {
      asn1PrtToStrm_CoarseHeading (pctxt, "heading", &pvalue->heading);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_PathHistoryPointList (OSCTXT *pctxt, 
   const char* name, const PathHistoryPointList* pvalue)
{
   PathHistoryPoint* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((PathHistoryPoint*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_PathHistoryPoint (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_PathHistory (OSCTXT *pctxt, 
   const char* name, const PathHistory* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.initialPositionPresent) {
      asn1PrtToStrm_FullPositionVector (pctxt, "initialPosition", &pvalue->initialPosition);
   }

   if (pvalue->m.currGNSSstatusPresent) {
      asn1PrtToStrm_GNSSstatus (pctxt, "currGNSSstatus", &pvalue->currGNSSstatus);
   }

   asn1PrtToStrm_PathHistoryPointList (pctxt, "crumbData", &pvalue->crumbData);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_PathPrediction (OSCTXT *pctxt, 
   const char* name, const PathPrediction* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_RadiusOfCurvature (pctxt, "radiusOfCurve", &pvalue->radiusOfCurve);

   asn1PrtToStrm_Confidence (pctxt, "confidence", &pvalue->confidence);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_IntersectionReferenceID (OSCTXT *pctxt, 
   const char* name, const IntersectionReferenceID* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.regionPresent) {
      asn1PrtToStrm_RoadRegulatorID (pctxt, "region", &pvalue->region);
   }

   asn1PrtToStrm_IntersectionID (pctxt, "id", &pvalue->id);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ApproachOrLane (OSCTXT *pctxt, 
   const char* name, const ApproachOrLane* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* approach */
      case 1:
      {
         asn1PrtToStrm_ApproachID (pctxt, "approach", &pvalue->u.approach);
         break;
      }
      /* lane */
      case 2:
      {
         asn1PrtToStrm_LaneID (pctxt, "lane", &pvalue->u.lane);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_IntersectionCollision_regional (OSCTXT *pctxt, 
   const char* name, const IntersectionCollision_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_IntersectionCollision (OSCTXT *pctxt, 
   const char* name, const IntersectionCollision* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_MsgCount (pctxt, "msgCnt", &pvalue->msgCnt);

   asn1PrtToStrm_TemporaryID (pctxt, "id", &pvalue->id);

   if (pvalue->m.timeStampPresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "timeStamp", &pvalue->timeStamp);
   }

   if (pvalue->m.partOnePresent) {
      asn1PrtToStrm_BSMcoreData (pctxt, "partOne", &pvalue->partOne);
   }

   if (pvalue->m.pathPresent) {
      asn1PrtToStrm_PathHistory (pctxt, "path", &pvalue->path);
   }

   if (pvalue->m.pathPredictionPresent) {
      asn1PrtToStrm_PathPrediction (pctxt, "pathPrediction", &pvalue->pathPrediction);
   }

   asn1PrtToStrm_IntersectionReferenceID (pctxt, "intersectionID", &pvalue->intersectionID);

   asn1PrtToStrm_ApproachOrLane (pctxt, "laneNumber", &pvalue->laneNumber);

   asn1PrtToStrm_VehicleEventFlags (pctxt, "eventFlag", &pvalue->eventFlag);

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_IntersectionCollision_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Position3D_regional (OSCTXT *pctxt, 
   const char* name, const Position3D_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_Position3D (OSCTXT *pctxt, 
   const char* name, const Position3D* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Latitude (pctxt, "lat", &pvalue->lat);

   asn1PrtToStrm_Longitude (pctxt, "long_", &pvalue->long_);

   if (pvalue->m.elevationPresent) {
      asn1PrtToStrm_Elevation (pctxt, "elevation", &pvalue->elevation);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_Position3D_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RegulatorySpeedLimit (OSCTXT *pctxt, 
   const char* name, const RegulatorySpeedLimit* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_SpeedLimitType (pctxt, "type", &pvalue->type);

   asn1PrtToStrm_Velocity (pctxt, "speed", &pvalue->speed);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SpeedLimitList (OSCTXT *pctxt, 
   const char* name, const SpeedLimitList* pvalue)
{
   RegulatorySpeedLimit* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegulatorySpeedLimit*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegulatorySpeedLimit (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_LaneTypeAttributes (OSCTXT *pctxt, 
   const char* name, const LaneTypeAttributes* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* vehicle */
      case 1:
      {
         asn1PrtToStrm_LaneAttributes_Vehicle (pctxt, "vehicle", pvalue->u.vehicle);
         break;
      }
      /* crosswalk */
      case 2:
      {
         asn1PrtToStrm_LaneAttributes_Crosswalk (pctxt, "crosswalk", pvalue->u.crosswalk);
         break;
      }
      /* bikeLane */
      case 3:
      {
         asn1PrtToStrm_LaneAttributes_Bike (pctxt, "bikeLane", pvalue->u.bikeLane);
         break;
      }
      /* sidewalk */
      case 4:
      {
         asn1PrtToStrm_LaneAttributes_Sidewalk (pctxt, "sidewalk", pvalue->u.sidewalk);
         break;
      }
      /* median */
      case 5:
      {
         asn1PrtToStrm_LaneAttributes_Barrier (pctxt, "median", pvalue->u.median);
         break;
      }
      /* striping */
      case 6:
      {
         asn1PrtToStrm_LaneAttributes_Striping (pctxt, "striping", pvalue->u.striping);
         break;
      }
      /* trackedVehicle */
      case 7:
      {
         asn1PrtToStrm_LaneAttributes_TrackedVehicle (pctxt, "trackedVehicle", pvalue->u.trackedVehicle);
         break;
      }
      /* parking */
      case 8:
      {
         asn1PrtToStrm_LaneAttributes_Parking (pctxt, "parking", pvalue->u.parking);
         break;
      }
      /* extElem1 */
      case 9:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamHexStr (pctxt, "extElem1",
            pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_LaneAttributes (OSCTXT *pctxt, 
   const char* name, const LaneAttributes* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_LaneDirection (pctxt, "directionalUse", &pvalue->directionalUse);

   asn1PrtToStrm_LaneSharing (pctxt, "sharedWith", &pvalue->sharedWith);

   asn1PrtToStrm_LaneTypeAttributes (pctxt, "laneType", &pvalue->laneType);

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Node_XY_20b (OSCTXT *pctxt, 
   const char* name, const Node_XY_20b* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Offset_B10 (pctxt, "x", &pvalue->x);

   asn1PrtToStrm_Offset_B10 (pctxt, "y", &pvalue->y);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Node_XY_22b (OSCTXT *pctxt, 
   const char* name, const Node_XY_22b* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Offset_B11 (pctxt, "x", &pvalue->x);

   asn1PrtToStrm_Offset_B11 (pctxt, "y", &pvalue->y);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Node_XY_24b (OSCTXT *pctxt, 
   const char* name, const Node_XY_24b* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Offset_B12 (pctxt, "x", &pvalue->x);

   asn1PrtToStrm_Offset_B12 (pctxt, "y", &pvalue->y);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Node_XY_26b (OSCTXT *pctxt, 
   const char* name, const Node_XY_26b* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Offset_B13 (pctxt, "x", &pvalue->x);

   asn1PrtToStrm_Offset_B13 (pctxt, "y", &pvalue->y);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Node_XY_28b (OSCTXT *pctxt, 
   const char* name, const Node_XY_28b* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Offset_B14 (pctxt, "x", &pvalue->x);

   asn1PrtToStrm_Offset_B14 (pctxt, "y", &pvalue->y);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Node_XY_32b (OSCTXT *pctxt, 
   const char* name, const Node_XY_32b* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Offset_B16 (pctxt, "x", &pvalue->x);

   asn1PrtToStrm_Offset_B16 (pctxt, "y", &pvalue->y);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Node_LLmD_64b (OSCTXT *pctxt, 
   const char* name, const Node_LLmD_64b* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Longitude (pctxt, "lon", &pvalue->lon);

   asn1PrtToStrm_Latitude (pctxt, "lat", &pvalue->lat);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_NodeOffsetPointXY (OSCTXT *pctxt, 
   const char* name, const NodeOffsetPointXY* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* node-XY1 */
      case 1:
      {
         asn1PrtToStrm_Node_XY_20b (pctxt, "node-XY1", pvalue->u.node_XY1);
         break;
      }
      /* node-XY2 */
      case 2:
      {
         asn1PrtToStrm_Node_XY_22b (pctxt, "node-XY2", pvalue->u.node_XY2);
         break;
      }
      /* node-XY3 */
      case 3:
      {
         asn1PrtToStrm_Node_XY_24b (pctxt, "node-XY3", pvalue->u.node_XY3);
         break;
      }
      /* node-XY4 */
      case 4:
      {
         asn1PrtToStrm_Node_XY_26b (pctxt, "node-XY4", pvalue->u.node_XY4);
         break;
      }
      /* node-XY5 */
      case 5:
      {
         asn1PrtToStrm_Node_XY_28b (pctxt, "node-XY5", pvalue->u.node_XY5);
         break;
      }
      /* node-XY6 */
      case 6:
      {
         asn1PrtToStrm_Node_XY_32b (pctxt, "node-XY6", pvalue->u.node_XY6);
         break;
      }
      /* node-LatLon */
      case 7:
      {
         asn1PrtToStrm_Node_LLmD_64b (pctxt, "node-LatLon", pvalue->u.node_LatLon);
         break;
      }
      /* regional */
      case 8:
      {
         asn1PrtToStrm_RegionalExtension (pctxt, "regional", pvalue->u.regional);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_NodeAttributeXYList (OSCTXT *pctxt, 
   const char* name, const NodeAttributeXYList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_NodeAttributeXY (pctxt, namebuf, &pvalue->elem[xx1]);
   }
   return 0;
}

int asn1PrtToStrm_SegmentAttributeXYList (OSCTXT *pctxt, 
   const char* name, const SegmentAttributeXYList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_SegmentAttributeXY (pctxt, namebuf, &pvalue->elem[xx1]);
   }
   return 0;
}

int asn1PrtToStrm_LaneDataAttribute_regional (OSCTXT *pctxt, 
   const char* name, const LaneDataAttribute_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_LaneDataAttribute (OSCTXT *pctxt, 
   const char* name, const LaneDataAttribute* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* pathEndPointAngle */
      case 1:
      {
         asn1PrtToStrm_DeltaAngle (pctxt, "pathEndPointAngle", &pvalue->u.pathEndPointAngle);
         break;
      }
      /* laneCrownPointCenter */
      case 2:
      {
         asn1PrtToStrm_RoadwayCrownAngle (pctxt, "laneCrownPointCenter", &pvalue->u.laneCrownPointCenter);
         break;
      }
      /* laneCrownPointLeft */
      case 3:
      {
         asn1PrtToStrm_RoadwayCrownAngle (pctxt, "laneCrownPointLeft", &pvalue->u.laneCrownPointLeft);
         break;
      }
      /* laneCrownPointRight */
      case 4:
      {
         asn1PrtToStrm_RoadwayCrownAngle (pctxt, "laneCrownPointRight", &pvalue->u.laneCrownPointRight);
         break;
      }
      /* laneAngle */
      case 5:
      {
         asn1PrtToStrm_MergeDivergeNodeAngle (pctxt, "laneAngle", &pvalue->u.laneAngle);
         break;
      }
      /* speedLimits */
      case 6:
      {
         asn1PrtToStrm_SpeedLimitList (pctxt, "speedLimits", pvalue->u.speedLimits);
         break;
      }
      /* regional */
      case 7:
      {
         asn1PrtToStrm_LaneDataAttribute_regional (pctxt, "regional", pvalue->u.regional);
         break;
      }
      /* extElem1 */
      case 8:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamHexStr (pctxt, "extElem1",
            pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_LaneDataAttributeList (OSCTXT *pctxt, 
   const char* name, const LaneDataAttributeList* pvalue)
{
   LaneDataAttribute* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((LaneDataAttribute*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_LaneDataAttribute (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_NodeAttributeSetXY_regional (OSCTXT *pctxt, 
   const char* name, const NodeAttributeSetXY_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_NodeAttributeSetXY (OSCTXT *pctxt, 
   const char* name, const NodeAttributeSetXY* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.localNodePresent) {
      asn1PrtToStrm_NodeAttributeXYList (pctxt, "localNode", &pvalue->localNode);
   }

   if (pvalue->m.disabledPresent) {
      asn1PrtToStrm_SegmentAttributeXYList (pctxt, "disabled", &pvalue->disabled);
   }

   if (pvalue->m.enabledPresent) {
      asn1PrtToStrm_SegmentAttributeXYList (pctxt, "enabled", &pvalue->enabled);
   }

   if (pvalue->m.dataPresent) {
      asn1PrtToStrm_LaneDataAttributeList (pctxt, "data", &pvalue->data);
   }

   if (pvalue->m.dWidthPresent) {
      asn1PrtToStrm_Offset_B10 (pctxt, "dWidth", &pvalue->dWidth);
   }

   if (pvalue->m.dElevationPresent) {
      asn1PrtToStrm_Offset_B10 (pctxt, "dElevation", &pvalue->dElevation);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_NodeAttributeSetXY_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_NodeXY (OSCTXT *pctxt, 
   const char* name, const NodeXY* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_NodeOffsetPointXY (pctxt, "delta", &pvalue->delta);

   if (pvalue->m.attributesPresent) {
      asn1PrtToStrm_NodeAttributeSetXY (pctxt, "attributes", &pvalue->attributes);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_NodeSetXY (OSCTXT *pctxt, 
   const char* name, const NodeSetXY* pvalue)
{
   NodeXY* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((NodeXY*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_NodeXY (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_ComputedLane_offsetXaxis (OSCTXT *pctxt, 
   const char* name, const ComputedLane_offsetXaxis* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* small */
      case 1:
      {
         asn1PrtToStrm_DrivenLineOffsetSm (pctxt, "small", &pvalue->u.small_);
         break;
      }
      /* large */
      case 2:
      {
         asn1PrtToStrm_DrivenLineOffsetLg (pctxt, "large", &pvalue->u.large_);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ComputedLane_offsetYaxis (OSCTXT *pctxt, 
   const char* name, const ComputedLane_offsetYaxis* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* small */
      case 1:
      {
         asn1PrtToStrm_DrivenLineOffsetSm (pctxt, "small", &pvalue->u.small_);
         break;
      }
      /* large */
      case 2:
      {
         asn1PrtToStrm_DrivenLineOffsetLg (pctxt, "large", &pvalue->u.large_);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ComputedLane_regional (OSCTXT *pctxt, 
   const char* name, const ComputedLane_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_ComputedLane (OSCTXT *pctxt, 
   const char* name, const ComputedLane* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_LaneID (pctxt, "referenceLaneId", &pvalue->referenceLaneId);

   asn1PrtToStrm_ComputedLane_offsetXaxis (pctxt, "offsetXaxis", &pvalue->offsetXaxis);

   asn1PrtToStrm_ComputedLane_offsetYaxis (pctxt, "offsetYaxis", &pvalue->offsetYaxis);

   if (pvalue->m.rotateXYPresent) {
      asn1PrtToStrm_Angle (pctxt, "rotateXY", &pvalue->rotateXY);
   }

   if (pvalue->m.scaleXaxisPresent) {
      asn1PrtToStrm_Scale_B12 (pctxt, "scaleXaxis", &pvalue->scaleXaxis);
   }

   if (pvalue->m.scaleYaxisPresent) {
      asn1PrtToStrm_Scale_B12 (pctxt, "scaleYaxis", &pvalue->scaleYaxis);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_ComputedLane_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_NodeListXY (OSCTXT *pctxt, 
   const char* name, const NodeListXY* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* nodes */
      case 1:
      {
         asn1PrtToStrm_NodeSetXY (pctxt, "nodes", pvalue->u.nodes);
         break;
      }
      /* computed */
      case 2:
      {
         asn1PrtToStrm_ComputedLane (pctxt, "computed", pvalue->u.computed);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamHexStr (pctxt, "extElem1",
            pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ConnectingLane (OSCTXT *pctxt, 
   const char* name, const ConnectingLane* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_LaneID (pctxt, "lane", &pvalue->lane);

   if (pvalue->m.maneuverPresent) {
      asn1PrtToStrm_AllowedManeuvers (pctxt, "maneuver", &pvalue->maneuver);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Connection (OSCTXT *pctxt, 
   const char* name, const Connection* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_ConnectingLane (pctxt, "connectingLane", &pvalue->connectingLane);

   if (pvalue->m.remoteIntersectionPresent) {
      asn1PrtToStrm_IntersectionReferenceID (pctxt, "remoteIntersection", &pvalue->remoteIntersection);
   }

   if (pvalue->m.signalGroupPresent) {
      asn1PrtToStrm_SignalGroupID (pctxt, "signalGroup", &pvalue->signalGroup);
   }

   if (pvalue->m.userClassPresent) {
      asn1PrtToStrm_RestrictionClassID (pctxt, "userClass", &pvalue->userClass);
   }

   if (pvalue->m.connectionIDPresent) {
      asn1PrtToStrm_LaneConnectionID (pctxt, "connectionID", &pvalue->connectionID);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ConnectsToList (OSCTXT *pctxt, 
   const char* name, const ConnectsToList* pvalue)
{
   Connection* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((Connection*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_Connection (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_OverlayLaneList (OSCTXT *pctxt, 
   const char* name, const OverlayLaneList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_LaneID (pctxt, namebuf, &pvalue->elem[xx1]);
   }
   return 0;
}

int asn1PrtToStrm_GenericLane_regional (OSCTXT *pctxt, 
   const char* name, const GenericLane_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_GenericLane (OSCTXT *pctxt, 
   const char* name, const GenericLane* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_LaneID (pctxt, "laneID", &pvalue->laneID);

   if (pvalue->m.namePresent) {
      asn1PrtToStrm_DescriptiveName (pctxt, "name", pvalue->name);
   }

   if (pvalue->m.ingressApproachPresent) {
      asn1PrtToStrm_ApproachID (pctxt, "ingressApproach", &pvalue->ingressApproach);
   }

   if (pvalue->m.egressApproachPresent) {
      asn1PrtToStrm_ApproachID (pctxt, "egressApproach", &pvalue->egressApproach);
   }

   asn1PrtToStrm_LaneAttributes (pctxt, "laneAttributes", &pvalue->laneAttributes);

   if (pvalue->m.maneuversPresent) {
      asn1PrtToStrm_AllowedManeuvers (pctxt, "maneuvers", &pvalue->maneuvers);
   }

   asn1PrtToStrm_NodeListXY (pctxt, "nodeList", &pvalue->nodeList);

   if (pvalue->m.connectsToPresent) {
      asn1PrtToStrm_ConnectsToList (pctxt, "connectsTo", &pvalue->connectsTo);
   }

   if (pvalue->m.overlaysPresent) {
      asn1PrtToStrm_OverlayLaneList (pctxt, "overlays", &pvalue->overlays);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_GenericLane_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_LaneList (OSCTXT *pctxt, 
   const char* name, const LaneList* pvalue)
{
   GenericLane* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((GenericLane*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_GenericLane (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_SignalControlZone (OSCTXT *pctxt, 
   const char* name, const SignalControlZone* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_RegionalExtension (pctxt, "zone", &pvalue->zone);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_PreemptPriorityList (OSCTXT *pctxt, 
   const char* name, const PreemptPriorityList* pvalue)
{
   SignalControlZone* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((SignalControlZone*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_SignalControlZone (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_IntersectionGeometry_regional (OSCTXT *pctxt, 
   const char* name, const IntersectionGeometry_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_IntersectionGeometry (OSCTXT *pctxt, 
   const char* name, const IntersectionGeometry* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.namePresent) {
      asn1PrtToStrm_DescriptiveName (pctxt, "name", pvalue->name);
   }

   asn1PrtToStrm_IntersectionReferenceID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_MsgCount (pctxt, "revision", &pvalue->revision);

   asn1PrtToStrm_Position3D (pctxt, "refPoint", &pvalue->refPoint);

   if (pvalue->m.laneWidthPresent) {
      asn1PrtToStrm_LaneWidth (pctxt, "laneWidth", &pvalue->laneWidth);
   }

   if (pvalue->m.speedLimitsPresent) {
      asn1PrtToStrm_SpeedLimitList (pctxt, "speedLimits", &pvalue->speedLimits);
   }

   asn1PrtToStrm_LaneList (pctxt, "laneSet", &pvalue->laneSet);

   if (pvalue->m.preemptPriorityDataPresent) {
      asn1PrtToStrm_PreemptPriorityList (pctxt, "preemptPriorityData", &pvalue->preemptPriorityData);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_IntersectionGeometry_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_IntersectionGeometryList (OSCTXT *pctxt, 
   const char* name, const IntersectionGeometryList* pvalue)
{
   IntersectionGeometry* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((IntersectionGeometry*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_IntersectionGeometry (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_RoadSegmentReferenceID (OSCTXT *pctxt, 
   const char* name, const RoadSegmentReferenceID* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.regionPresent) {
      asn1PrtToStrm_RoadRegulatorID (pctxt, "region", &pvalue->region);
   }

   asn1PrtToStrm_RoadSegmentID (pctxt, "id", &pvalue->id);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RoadLaneSetList (OSCTXT *pctxt, 
   const char* name, const RoadLaneSetList* pvalue)
{
   GenericLane* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((GenericLane*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_GenericLane (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_RoadSegment_regional (OSCTXT *pctxt, 
   const char* name, const RoadSegment_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_RoadSegment (OSCTXT *pctxt, 
   const char* name, const RoadSegment* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.namePresent) {
      asn1PrtToStrm_DescriptiveName (pctxt, "name", pvalue->name);
   }

   asn1PrtToStrm_RoadSegmentReferenceID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_MsgCount (pctxt, "revision", &pvalue->revision);

   asn1PrtToStrm_Position3D (pctxt, "refPoint", &pvalue->refPoint);

   if (pvalue->m.laneWidthPresent) {
      asn1PrtToStrm_LaneWidth (pctxt, "laneWidth", &pvalue->laneWidth);
   }

   if (pvalue->m.speedLimitsPresent) {
      asn1PrtToStrm_SpeedLimitList (pctxt, "speedLimits", &pvalue->speedLimits);
   }

   asn1PrtToStrm_RoadLaneSetList (pctxt, "roadLaneSet", &pvalue->roadLaneSet);

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RoadSegment_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RoadSegmentList (OSCTXT *pctxt, 
   const char* name, const RoadSegmentList* pvalue)
{
   RoadSegment* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RoadSegment*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RoadSegment (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_DataParameters (OSCTXT *pctxt, 
   const char* name, const DataParameters* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.processMethodPresent) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamCharStr (pctxt, "processMethod", pvalue->processMethod);
   }

   if (pvalue->m.processAgencyPresent) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamCharStr (pctxt, "processAgency", pvalue->processAgency);
   }

   if (pvalue->m.lastCheckedDatePresent) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamCharStr (pctxt, "lastCheckedDate", pvalue->lastCheckedDate);
   }

   if (pvalue->m.geoidUsedPresent) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamCharStr (pctxt, "geoidUsed", pvalue->geoidUsed);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RestrictionUserType_regional (OSCTXT *pctxt, 
   const char* name, const RestrictionUserType_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_RestrictionUserType (OSCTXT *pctxt, 
   const char* name, const RestrictionUserType* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* basicType */
      case 1:
      {
         asn1PrtToStrm_RestrictionAppliesTo (pctxt, "basicType", &pvalue->u.basicType);
         break;
      }
      /* regional */
      case 2:
      {
         asn1PrtToStrm_RestrictionUserType_regional (pctxt, "regional", pvalue->u.regional);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamHexStr (pctxt, "extElem1",
            pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RestrictionUserTypeList (OSCTXT *pctxt, 
   const char* name, const RestrictionUserTypeList* pvalue)
{
   RestrictionUserType* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RestrictionUserType*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RestrictionUserType (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_RestrictionClassAssignment (OSCTXT *pctxt, 
   const char* name, const RestrictionClassAssignment* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_RestrictionClassID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_RestrictionUserTypeList (pctxt, "users", &pvalue->users);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RestrictionClassList (OSCTXT *pctxt, 
   const char* name, const RestrictionClassList* pvalue)
{
   RestrictionClassAssignment* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RestrictionClassAssignment*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RestrictionClassAssignment (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_MapData_regional (OSCTXT *pctxt, 
   const char* name, const MapData_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_MapData (OSCTXT *pctxt, 
   const char* name, const MapData* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.timeStampPresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "timeStamp", &pvalue->timeStamp);
   }

   asn1PrtToStrm_MsgCount (pctxt, "msgIssueRevision", &pvalue->msgIssueRevision);

   if (pvalue->m.layerTypePresent) {
      asn1PrtToStrm_LayerType (pctxt, "layerType", &pvalue->layerType);
   }

   if (pvalue->m.layerIDPresent) {
      asn1PrtToStrm_LayerID (pctxt, "layerID", &pvalue->layerID);
   }

   if (pvalue->m.intersectionsPresent) {
      asn1PrtToStrm_IntersectionGeometryList (pctxt, "intersections", &pvalue->intersections);
   }

   if (pvalue->m.roadSegmentsPresent) {
      asn1PrtToStrm_RoadSegmentList (pctxt, "roadSegments", &pvalue->roadSegments);
   }

   if (pvalue->m.dataParametersPresent) {
      asn1PrtToStrm_DataParameters (pctxt, "dataParameters", &pvalue->dataParameters);
   }

   if (pvalue->m.restrictionListPresent) {
      asn1PrtToStrm_RestrictionClassList (pctxt, "restrictionList", &pvalue->restrictionList);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_MapData_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_NMEAcorrections_regional (OSCTXT *pctxt, 
   const char* name, const NMEAcorrections_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_NMEAcorrections (OSCTXT *pctxt, 
   const char* name, const NMEAcorrections* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.timeStampPresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "timeStamp", &pvalue->timeStamp);
   }

   if (pvalue->m.revPresent) {
      asn1PrtToStrm_NMEA_Revision (pctxt, "rev", &pvalue->rev);
   }

   if (pvalue->m.msgPresent) {
      asn1PrtToStrm_NMEA_MsgType (pctxt, "msg", &pvalue->msg);
   }

   if (pvalue->m.wdCountPresent) {
      asn1PrtToStrm_ObjectCount (pctxt, "wdCount", &pvalue->wdCount);
   }

   asn1PrtToStrm_NMEA_Payload (pctxt, "payload", &pvalue->payload);

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_NMEAcorrections_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_PropelledInformation (OSCTXT *pctxt, 
   const char* name, const PropelledInformation* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* human */
      case 1:
      {
         asn1PrtToStrm_HumanPropelledType (pctxt, "human", &pvalue->u.human);
         break;
      }
      /* animal */
      case 2:
      {
         asn1PrtToStrm_AnimalPropelledType (pctxt, "animal", &pvalue->u.animal);
         break;
      }
      /* motor */
      case 3:
      {
         asn1PrtToStrm_MotorizedPropelledType (pctxt, "motor", &pvalue->u.motor);
         break;
      }
      /* extElem1 */
      case 4:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamHexStr (pctxt, "extElem1",
            pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_PersonalSafetyMessage_regional (OSCTXT *pctxt, 
   const char* name, const PersonalSafetyMessage_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_PersonalSafetyMessage (OSCTXT *pctxt, 
   const char* name, const PersonalSafetyMessage* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_PersonalDeviceUserType (pctxt, "basicType", &pvalue->basicType);

   asn1PrtToStrm_DSecond (pctxt, "secMark", &pvalue->secMark);

   asn1PrtToStrm_MsgCount (pctxt, "msgCnt", &pvalue->msgCnt);

   asn1PrtToStrm_TemporaryID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_Position3D (pctxt, "position", &pvalue->position);

   asn1PrtToStrm_PositionalAccuracy (pctxt, "accuracy", &pvalue->accuracy);

   asn1PrtToStrm_Velocity (pctxt, "speed", &pvalue->speed);

   asn1PrtToStrm_Heading (pctxt, "heading", &pvalue->heading);

   if (pvalue->m.accelSetPresent) {
      asn1PrtToStrm_AccelerationSet4Way (pctxt, "accelSet", &pvalue->accelSet);
   }

   if (pvalue->m.pathHistoryPresent) {
      asn1PrtToStrm_PathHistory (pctxt, "pathHistory", &pvalue->pathHistory);
   }

   if (pvalue->m.pathPredictionPresent) {
      asn1PrtToStrm_PathPrediction (pctxt, "pathPrediction", &pvalue->pathPrediction);
   }

   if (pvalue->m.propulsionPresent) {
      asn1PrtToStrm_PropelledInformation (pctxt, "propulsion", &pvalue->propulsion);
   }

   if (pvalue->m.useStatePresent) {
      asn1PrtToStrm_PersonalDeviceUsageState (pctxt, "useState", &pvalue->useState);
   }

   if (pvalue->m.crossRequestPresent) {
      asn1PrtToStrm_PersonalCrossingRequest (pctxt, "crossRequest", &pvalue->crossRequest);
   }

   if (pvalue->m.crossStatePresent) {
      asn1PrtToStrm_PersonalCrossingInProgress (pctxt, "crossState", &pvalue->crossState);
   }

   if (pvalue->m.clusterSizePresent) {
      asn1PrtToStrm_NumberOfParticipantsInCluster (pctxt, "clusterSize", &pvalue->clusterSize);
   }

   if (pvalue->m.clusterRadiusPresent) {
      asn1PrtToStrm_PersonalClusterRadius (pctxt, "clusterRadius", &pvalue->clusterRadius);
   }

   if (pvalue->m.eventResponderTypePresent) {
      asn1PrtToStrm_PublicSafetyEventResponderWorkerType (pctxt, "eventResponderType", &pvalue->eventResponderType);
   }

   if (pvalue->m.activityTypePresent) {
      asn1PrtToStrm_PublicSafetyAndRoadWorkerActivity (pctxt, "activityType", &pvalue->activityType);
   }

   if (pvalue->m.activitySubTypePresent) {
      asn1PrtToStrm_PublicSafetyDirectingTrafficSubType (pctxt, "activitySubType", &pvalue->activitySubType);
   }

   if (pvalue->m.assistTypePresent) {
      asn1PrtToStrm_PersonalAssistive (pctxt, "assistType", &pvalue->assistType);
   }

   if (pvalue->m.sizingPresent) {
      asn1PrtToStrm_UserSizeAndBehaviour (pctxt, "sizing", &pvalue->sizing);
   }

   if (pvalue->m.attachmentPresent) {
      asn1PrtToStrm_Attachment (pctxt, "attachment", &pvalue->attachment);
   }

   if (pvalue->m.attachmentRadiusPresent) {
      asn1PrtToStrm_AttachmentRadius (pctxt, "attachmentRadius", &pvalue->attachmentRadius);
   }

   if (pvalue->m.animalTypePresent) {
      asn1PrtToStrm_AnimalType (pctxt, "animalType", &pvalue->animalType);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_PersonalSafetyMessage_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Sample (OSCTXT *pctxt, 
   const char* name, const Sample* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "sampleStart", pvalue->sampleStart);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "sampleEnd", pvalue->sampleEnd);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ProbeDataManagement_term (OSCTXT *pctxt, 
   const char* name, const ProbeDataManagement_term* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* termtime */
      case 1:
      {
         asn1PrtToStrm_TermTime (pctxt, "termtime", &pvalue->u.termtime);
         break;
      }
      /* termDistance */
      case 2:
      {
         asn1PrtToStrm_TermDistance (pctxt, "termDistance", &pvalue->u.termDistance);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SnapshotTime (OSCTXT *pctxt, 
   const char* name, const SnapshotTime* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_GrossSpeed (pctxt, "speed1", &pvalue->speed1);

   asn1PrtToStrm_SecondOfTime (pctxt, "time1", &pvalue->time1);

   asn1PrtToStrm_GrossSpeed (pctxt, "speed2", &pvalue->speed2);

   asn1PrtToStrm_SecondOfTime (pctxt, "time2", &pvalue->time2);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SnapshotDistance (OSCTXT *pctxt, 
   const char* name, const SnapshotDistance* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_GrossDistance (pctxt, "distance1", &pvalue->distance1);

   asn1PrtToStrm_GrossSpeed (pctxt, "speed1", &pvalue->speed1);

   asn1PrtToStrm_GrossDistance (pctxt, "distance2", &pvalue->distance2);

   asn1PrtToStrm_GrossSpeed (pctxt, "speed2", &pvalue->speed2);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ProbeDataManagement_snapshot (OSCTXT *pctxt, 
   const char* name, const ProbeDataManagement_snapshot* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* snapshotTime */
      case 1:
      {
         asn1PrtToStrm_SnapshotTime (pctxt, "snapshotTime", pvalue->u.snapshotTime);
         break;
      }
      /* snapshotDistance */
      case 2:
      {
         asn1PrtToStrm_SnapshotDistance (pctxt, "snapshotDistance", pvalue->u.snapshotDistance);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleStatusRequest (OSCTXT *pctxt, 
   const char* name, const VehicleStatusRequest* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_VehicleStatusDeviceTypeTag (pctxt, "dataType", &pvalue->dataType);

   if (pvalue->m.subTypePresent) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamUnsigned (pctxt, "subType", pvalue->subType);
   }

   if (pvalue->m.sendOnLessThenValuePresent) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamInteger (pctxt, "sendOnLessThenValue", pvalue->sendOnLessThenValue);
   }

   if (pvalue->m.sendOnMoreThenValuePresent) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamInteger (pctxt, "sendOnMoreThenValue", pvalue->sendOnMoreThenValue);
   }

   if (pvalue->m.sendAllPresent) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamBoolean (pctxt, "sendAll", pvalue->sendAll);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleStatusRequestList (OSCTXT *pctxt, 
   const char* name, const VehicleStatusRequestList* pvalue)
{
   VehicleStatusRequest* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((VehicleStatusRequest*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_VehicleStatusRequest (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_ProbeDataManagement_regional (OSCTXT *pctxt, 
   const char* name, const ProbeDataManagement_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_ProbeDataManagement (OSCTXT *pctxt, 
   const char* name, const ProbeDataManagement* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.timeStampPresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "timeStamp", &pvalue->timeStamp);
   }

   asn1PrtToStrm_Sample (pctxt, "sample", &pvalue->sample);

   asn1PrtToStrm_HeadingSlice (pctxt, "directions", &pvalue->directions);

   asn1PrtToStrm_ProbeDataManagement_term (pctxt, "term", &pvalue->term);

   asn1PrtToStrm_ProbeDataManagement_snapshot (pctxt, "snapshot", &pvalue->snapshot);

   asn1PrtToStrm_SecondOfTime (pctxt, "txInterval", &pvalue->txInterval);

   if (pvalue->m.dataElementsPresent) {
      asn1PrtToStrm_VehicleStatusRequestList (pctxt, "dataElements", &pvalue->dataElements);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_ProbeDataManagement_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleID (OSCTXT *pctxt, 
   const char* name, const VehicleID* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* entityID */
      case 1:
      {
         asn1PrtToStrm_TemporaryID (pctxt, "entityID", pvalue->u.entityID);
         break;
      }
      /* stationID */
      case 2:
      {
         asn1PrtToStrm_StationID (pctxt, "stationID", &pvalue->u.stationID);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleIdent_vehicleClass (OSCTXT *pctxt, 
   const char* name, const VehicleIdent_vehicleClass* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* vGroup */
      case 1:
      {
         asn1PrtToStrm_VehicleGroupAffected (pctxt, "vGroup", &pvalue->u.vGroup);
         break;
      }
      /* rGroup */
      case 2:
      {
         asn1PrtToStrm_ResponderGroupAffected (pctxt, "rGroup", &pvalue->u.rGroup);
         break;
      }
      /* rEquip */
      case 3:
      {
         asn1PrtToStrm_IncidentResponseEquipment (pctxt, "rEquip", &pvalue->u.rEquip);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleIdent (OSCTXT *pctxt, 
   const char* name, const VehicleIdent* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.namePresent) {
      asn1PrtToStrm_DescriptiveName (pctxt, "name", pvalue->name);
   }

   if (pvalue->m.vinPresent) {
      asn1PrtToStrm_VINstring (pctxt, "vin", &pvalue->vin);
   }

   if (pvalue->m.ownerCodePresent) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamCharStr (pctxt, "ownerCode", pvalue->ownerCode);
   }

   if (pvalue->m.idPresent) {
      asn1PrtToStrm_VehicleID (pctxt, "id", &pvalue->id);
   }

   if (pvalue->m.vehicleTypePresent) {
      asn1PrtToStrm_VehicleType (pctxt, "vehicleType", &pvalue->vehicleType);
   }

   if (pvalue->m.vehicleClassPresent) {
      asn1PrtToStrm_VehicleIdent_vehicleClass (pctxt, "vehicleClass", &pvalue->vehicleClass);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleClassification_regional (OSCTXT *pctxt, 
   const char* name, const VehicleClassification_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_VehicleClassification (OSCTXT *pctxt, 
   const char* name, const VehicleClassification* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.keyTypePresent) {
      asn1PrtToStrm_BasicVehicleClass (pctxt, "keyType", &pvalue->keyType);
   }

   if (pvalue->m.rolePresent) {
      asn1PrtToStrm_BasicVehicleRole (pctxt, "role", &pvalue->role);
   }

   if (pvalue->m.iso3883Present) {
      asn1PrtToStrm_Iso3833VehicleType (pctxt, "iso3883", &pvalue->iso3883);
   }

   if (pvalue->m.hpmsTypePresent) {
      asn1PrtToStrm_VehicleType (pctxt, "hpmsType", &pvalue->hpmsType);
   }

   if (pvalue->m.vehicleTypePresent) {
      asn1PrtToStrm_VehicleGroupAffected (pctxt, "vehicleType", &pvalue->vehicleType);
   }

   if (pvalue->m.responseEquipPresent) {
      asn1PrtToStrm_IncidentResponseEquipment (pctxt, "responseEquip", &pvalue->responseEquip);
   }

   if (pvalue->m.responderTypePresent) {
      asn1PrtToStrm_ResponderGroupAffected (pctxt, "responderType", &pvalue->responderType);
   }

   if (pvalue->m.fuelTypePresent) {
      asn1PrtToStrm_FuelType (pctxt, "fuelType", &pvalue->fuelType);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_VehicleClassification_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleSafetyExtensions (OSCTXT *pctxt, 
   const char* name, const VehicleSafetyExtensions* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.eventsPresent) {
      asn1PrtToStrm_VehicleEventFlags (pctxt, "events", &pvalue->events);
   }

   if (pvalue->m.pathHistoryPresent) {
      asn1PrtToStrm_PathHistory (pctxt, "pathHistory", &pvalue->pathHistory);
   }

   if (pvalue->m.pathPredictionPresent) {
      asn1PrtToStrm_PathPrediction (pctxt, "pathPrediction", &pvalue->pathPrediction);
   }

   if (pvalue->m.lightsPresent) {
      asn1PrtToStrm_ExteriorLights (pctxt, "lights", &pvalue->lights);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_WiperSet (OSCTXT *pctxt, 
   const char* name, const WiperSet* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_WiperStatus (pctxt, "statusFront", &pvalue->statusFront);

   asn1PrtToStrm_WiperRate (pctxt, "rateFront", &pvalue->rateFront);

   if (pvalue->m.statusRearPresent) {
      asn1PrtToStrm_WiperStatus (pctxt, "statusRear", &pvalue->statusRear);
   }

   if (pvalue->m.rateRearPresent) {
      asn1PrtToStrm_WiperRate (pctxt, "rateRear", &pvalue->rateRear);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleStatus_steering (OSCTXT *pctxt, 
   const char* name, const VehicleStatus_steering* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_SteeringWheelAngle (pctxt, "angle", &pvalue->angle);

   if (pvalue->m.confidencePresent) {
      asn1PrtToStrm_SteeringWheelAngleConfidence (pctxt, "confidence", &pvalue->confidence);
   }

   if (pvalue->m.ratePresent) {
      asn1PrtToStrm_SteeringWheelAngleRateOfChange (pctxt, "rate", &pvalue->rate);
   }

   if (pvalue->m.wheelsPresent) {
      asn1PrtToStrm_DrivingWheelAngle (pctxt, "wheels", &pvalue->wheels);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_AccelSteerYawRateConfidence (OSCTXT *pctxt, 
   const char* name, const AccelSteerYawRateConfidence* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_YawRateConfidence (pctxt, "yawRate", &pvalue->yawRate);

   asn1PrtToStrm_AccelerationConfidence (pctxt, "acceleration", &pvalue->acceleration);

   asn1PrtToStrm_SteeringWheelAngleConfidence (pctxt, "steeringWheelAngle", &pvalue->steeringWheelAngle);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ConfidenceSet (OSCTXT *pctxt, 
   const char* name, const ConfidenceSet* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.accelConfidencePresent) {
      asn1PrtToStrm_AccelSteerYawRateConfidence (pctxt, "accelConfidence", &pvalue->accelConfidence);
   }

   if (pvalue->m.speedConfidencePresent) {
      asn1PrtToStrm_SpeedandHeadingandThrottleConfidence (pctxt, "speedConfidence", &pvalue->speedConfidence);
   }

   if (pvalue->m.timeConfidencePresent) {
      asn1PrtToStrm_TimeConfidence (pctxt, "timeConfidence", &pvalue->timeConfidence);
   }

   if (pvalue->m.posConfidencePresent) {
      asn1PrtToStrm_PositionConfidenceSet (pctxt, "posConfidence", &pvalue->posConfidence);
   }

   if (pvalue->m.steerConfidencePresent) {
      asn1PrtToStrm_SteeringWheelAngleConfidence (pctxt, "steerConfidence", &pvalue->steerConfidence);
   }

   if (pvalue->m.headingConfidencePresent) {
      asn1PrtToStrm_HeadingConfidence (pctxt, "headingConfidence", &pvalue->headingConfidence);
   }

   if (pvalue->m.throttleConfidencePresent) {
      asn1PrtToStrm_ThrottleConfidence (pctxt, "throttleConfidence", &pvalue->throttleConfidence);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleStatus_accelSets (OSCTXT *pctxt, 
   const char* name, const VehicleStatus_accelSets* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.accel4wayPresent) {
      asn1PrtToStrm_AccelerationSet4Way (pctxt, "accel4way", &pvalue->accel4way);
   }

   if (pvalue->m.vertAccelThresPresent) {
      asn1PrtToStrm_VerticalAccelerationThreshold (pctxt, "vertAccelThres", &pvalue->vertAccelThres);
   }

   if (pvalue->m.yawRateConPresent) {
      asn1PrtToStrm_YawRateConfidence (pctxt, "yawRateCon", &pvalue->yawRateCon);
   }

   if (pvalue->m.hozAccelConPresent) {
      asn1PrtToStrm_AccelerationConfidence (pctxt, "hozAccelCon", &pvalue->hozAccelCon);
   }

   if (pvalue->m.confidenceSetPresent) {
      asn1PrtToStrm_ConfidenceSet (pctxt, "confidenceSet", &pvalue->confidenceSet);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleStatus_object (OSCTXT *pctxt, 
   const char* name, const VehicleStatus_object* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_ObstacleDistance (pctxt, "obDist", &pvalue->obDist);

   asn1PrtToStrm_Angle (pctxt, "obDirect", &pvalue->obDirect);

   asn1PrtToStrm_DDateTime (pctxt, "dateTime", &pvalue->dateTime);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_BumperHeights (OSCTXT *pctxt, 
   const char* name, const BumperHeights* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_BumperHeight (pctxt, "front", &pvalue->front);

   asn1PrtToStrm_BumperHeight (pctxt, "rear", &pvalue->rear);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleStatus_vehicleData (OSCTXT *pctxt, 
   const char* name, const VehicleStatus_vehicleData* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_VehicleHeight (pctxt, "height", &pvalue->height);

   asn1PrtToStrm_BumperHeights (pctxt, "bumpers", &pvalue->bumpers);

   asn1PrtToStrm_VehicleMass (pctxt, "mass", &pvalue->mass);

   asn1PrtToStrm_TrailerWeight (pctxt, "trailerWeight", &pvalue->trailerWeight);

   asn1PrtToStrm_VehicleType (pctxt, "type", &pvalue->type);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TireData (OSCTXT *pctxt, 
   const char* name, const TireData* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.locationPresent) {
      asn1PrtToStrm_TireLocation (pctxt, "location", &pvalue->location);
   }

   if (pvalue->m.pressurePresent) {
      asn1PrtToStrm_TirePressure (pctxt, "pressure", &pvalue->pressure);
   }

   if (pvalue->m.tempPresent) {
      asn1PrtToStrm_TireTemp (pctxt, "temp", &pvalue->temp);
   }

   if (pvalue->m.wheelSensorStatusPresent) {
      asn1PrtToStrm_WheelSensorStatus (pctxt, "wheelSensorStatus", &pvalue->wheelSensorStatus);
   }

   if (pvalue->m.wheelEndElectFaultPresent) {
      asn1PrtToStrm_WheelEndElectFault (pctxt, "wheelEndElectFault", &pvalue->wheelEndElectFault);
   }

   if (pvalue->m.leakageRatePresent) {
      asn1PrtToStrm_TireLeakageRate (pctxt, "leakageRate", &pvalue->leakageRate);
   }

   if (pvalue->m.detectionPresent) {
      asn1PrtToStrm_TirePressureThresholdDetection (pctxt, "detection", &pvalue->detection);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TireDataList (OSCTXT *pctxt, 
   const char* name, const TireDataList* pvalue)
{
   TireData* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((TireData*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_TireData (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_AxleWeightSet (OSCTXT *pctxt, 
   const char* name, const AxleWeightSet* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.locationPresent) {
      asn1PrtToStrm_AxleLocation (pctxt, "location", &pvalue->location);
   }

   if (pvalue->m.weightPresent) {
      asn1PrtToStrm_AxleWeight (pctxt, "weight", &pvalue->weight);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_AxleWeightList (OSCTXT *pctxt, 
   const char* name, const AxleWeightList* pvalue)
{
   AxleWeightSet* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((AxleWeightSet*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_AxleWeightSet (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_J1939data (OSCTXT *pctxt, 
   const char* name, const J1939data* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.tiresPresent) {
      asn1PrtToStrm_TireDataList (pctxt, "tires", &pvalue->tires);
   }

   if (pvalue->m.axlesPresent) {
      asn1PrtToStrm_AxleWeightList (pctxt, "axles", &pvalue->axles);
   }

   if (pvalue->m.trailerWeightPresent) {
      asn1PrtToStrm_TrailerWeight (pctxt, "trailerWeight", &pvalue->trailerWeight);
   }

   if (pvalue->m.cargoWeightPresent) {
      asn1PrtToStrm_CargoWeight (pctxt, "cargoWeight", &pvalue->cargoWeight);
   }

   if (pvalue->m.steeringAxleTemperaturePresent) {
      asn1PrtToStrm_SteeringAxleTemperature (pctxt, "steeringAxleTemperature", &pvalue->steeringAxleTemperature);
   }

   if (pvalue->m.driveAxleLocationPresent) {
      asn1PrtToStrm_DriveAxleLocation (pctxt, "driveAxleLocation", &pvalue->driveAxleLocation);
   }

   if (pvalue->m.driveAxleLiftAirPressurePresent) {
      asn1PrtToStrm_DriveAxleLiftAirPressure (pctxt, "driveAxleLiftAirPressure", &pvalue->driveAxleLiftAirPressure);
   }

   if (pvalue->m.driveAxleTemperaturePresent) {
      asn1PrtToStrm_DriveAxleTemperature (pctxt, "driveAxleTemperature", &pvalue->driveAxleTemperature);
   }

   if (pvalue->m.driveAxleLubePressurePresent) {
      asn1PrtToStrm_DriveAxleLubePressure (pctxt, "driveAxleLubePressure", &pvalue->driveAxleLubePressure);
   }

   if (pvalue->m.steeringAxleLubePressurePresent) {
      asn1PrtToStrm_SteeringAxleLubePressure (pctxt, "steeringAxleLubePressure", &pvalue->steeringAxleLubePressure);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleStatus_weatherReport (OSCTXT *pctxt, 
   const char* name, const VehicleStatus_weatherReport* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_EssPrecipYesNo (pctxt, "isRaining", &pvalue->isRaining);

   if (pvalue->m.rainRatePresent) {
      asn1PrtToStrm_EssPrecipRate (pctxt, "rainRate", &pvalue->rainRate);
   }

   if (pvalue->m.precipSituationPresent) {
      asn1PrtToStrm_EssPrecipSituation (pctxt, "precipSituation", &pvalue->precipSituation);
   }

   if (pvalue->m.solarRadiationPresent) {
      asn1PrtToStrm_EssSolarRadiation (pctxt, "solarRadiation", &pvalue->solarRadiation);
   }

   if (pvalue->m.frictionPresent) {
      asn1PrtToStrm_EssMobileFriction (pctxt, "friction", &pvalue->friction);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleStatus (OSCTXT *pctxt, 
   const char* name, const VehicleStatus* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.lightsPresent) {
      asn1PrtToStrm_ExteriorLights (pctxt, "lights", &pvalue->lights);
   }

   if (pvalue->m.lightBarPresent) {
      asn1PrtToStrm_LightbarInUse (pctxt, "lightBar", &pvalue->lightBar);
   }

   if (pvalue->m.wipersPresent) {
      asn1PrtToStrm_WiperSet (pctxt, "wipers", &pvalue->wipers);
   }

   if (pvalue->m.brakeStatusPresent) {
      asn1PrtToStrm_BrakeSystemStatus (pctxt, "brakeStatus", &pvalue->brakeStatus);
   }

   if (pvalue->m.brakePressurePresent) {
      asn1PrtToStrm_BrakeAppliedPressure (pctxt, "brakePressure", &pvalue->brakePressure);
   }

   if (pvalue->m.roadFrictionPresent) {
      asn1PrtToStrm_CoefficientOfFriction (pctxt, "roadFriction", &pvalue->roadFriction);
   }

   if (pvalue->m.sunDataPresent) {
      asn1PrtToStrm_SunSensor (pctxt, "sunData", &pvalue->sunData);
   }

   if (pvalue->m.rainDataPresent) {
      asn1PrtToStrm_RainSensor (pctxt, "rainData", &pvalue->rainData);
   }

   if (pvalue->m.airTempPresent) {
      asn1PrtToStrm_AmbientAirTemperature (pctxt, "airTemp", &pvalue->airTemp);
   }

   if (pvalue->m.airPresPresent) {
      asn1PrtToStrm_AmbientAirPressure (pctxt, "airPres", &pvalue->airPres);
   }

   if (pvalue->m.steeringPresent) {
      asn1PrtToStrm_VehicleStatus_steering (pctxt, "steering", &pvalue->steering);
   }

   if (pvalue->m.accelSetsPresent) {
      asn1PrtToStrm_VehicleStatus_accelSets (pctxt, "accelSets", &pvalue->accelSets);
   }

   if (pvalue->m.objectPresent) {
      asn1PrtToStrm_VehicleStatus_object (pctxt, "object", &pvalue->object);
   }

   if (pvalue->m.fullPosPresent) {
      asn1PrtToStrm_FullPositionVector (pctxt, "fullPos", &pvalue->fullPos);
   }

   if (pvalue->m.throttlePosPresent) {
      asn1PrtToStrm_ThrottlePosition (pctxt, "throttlePos", &pvalue->throttlePos);
   }

   if (pvalue->m.speedHeadCPresent) {
      asn1PrtToStrm_SpeedandHeadingandThrottleConfidence (pctxt, "speedHeadC", &pvalue->speedHeadC);
   }

   if (pvalue->m.speedCPresent) {
      asn1PrtToStrm_SpeedConfidence (pctxt, "speedC", &pvalue->speedC);
   }

   if (pvalue->m.vehicleDataPresent) {
      asn1PrtToStrm_VehicleStatus_vehicleData (pctxt, "vehicleData", &pvalue->vehicleData);
   }

   if (pvalue->m.vehicleIdentPresent) {
      asn1PrtToStrm_VehicleIdent (pctxt, "vehicleIdent", &pvalue->vehicleIdent);
   }

   if (pvalue->m.j1939dataPresent) {
      asn1PrtToStrm_J1939data (pctxt, "j1939data", &pvalue->j1939data);
   }

   if (pvalue->m.weatherReportPresent) {
      asn1PrtToStrm_VehicleStatus_weatherReport (pctxt, "weatherReport", &pvalue->weatherReport);
   }

   if (pvalue->m.gnssStatusPresent) {
      asn1PrtToStrm_GNSSstatus (pctxt, "gnssStatus", &pvalue->gnssStatus);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Snapshot (OSCTXT *pctxt, 
   const char* name, const Snapshot* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_FullPositionVector (pctxt, "thePosition", &pvalue->thePosition);

   if (pvalue->m.safetyExtPresent) {
      asn1PrtToStrm_VehicleSafetyExtensions (pctxt, "safetyExt", &pvalue->safetyExt);
   }

   if (pvalue->m.dataSetPresent) {
      asn1PrtToStrm_VehicleStatus (pctxt, "dataSet", &pvalue->dataSet);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ProbeVehicleData_snapshots (OSCTXT *pctxt, 
   const char* name, const ProbeVehicleData_snapshots* pvalue)
{
   Snapshot* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((Snapshot*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_Snapshot (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_ProbeVehicleData_regional (OSCTXT *pctxt, 
   const char* name, const ProbeVehicleData_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_ProbeVehicleData (OSCTXT *pctxt, 
   const char* name, const ProbeVehicleData* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.timeStampPresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "timeStamp", &pvalue->timeStamp);
   }

   if (pvalue->m.segNumPresent) {
      asn1PrtToStrm_ProbeSegmentNumber (pctxt, "segNum", &pvalue->segNum);
   }

   if (pvalue->m.probeIDPresent) {
      asn1PrtToStrm_VehicleIdent (pctxt, "probeID", &pvalue->probeID);
   }

   asn1PrtToStrm_FullPositionVector (pctxt, "startVector", &pvalue->startVector);

   asn1PrtToStrm_VehicleClassification (pctxt, "vehicleType", &pvalue->vehicleType);

   asn1PrtToStrm_ProbeVehicleData_snapshots (pctxt, "snapshots", &pvalue->snapshots);

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_ProbeVehicleData_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_AntennaOffsetSet (OSCTXT *pctxt, 
   const char* name, const AntennaOffsetSet* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Offset_B12 (pctxt, "antOffsetX", &pvalue->antOffsetX);

   asn1PrtToStrm_Offset_B09 (pctxt, "antOffsetY", &pvalue->antOffsetY);

   asn1PrtToStrm_Offset_B10 (pctxt, "antOffsetZ", &pvalue->antOffsetZ);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RTCMheader (OSCTXT *pctxt, 
   const char* name, const RTCMheader* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_GNSSstatus (pctxt, "status", &pvalue->status);

   asn1PrtToStrm_AntennaOffsetSet (pctxt, "offsetSet", &pvalue->offsetSet);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RTCMmessageList (OSCTXT *pctxt, 
   const char* name, const RTCMmessageList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RTCMmessage (pctxt, namebuf, &pvalue->elem[xx1]);
   }
   return 0;
}

int asn1PrtToStrm_RTCMcorrections_regional (OSCTXT *pctxt, 
   const char* name, const RTCMcorrections_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_RTCMcorrections (OSCTXT *pctxt, 
   const char* name, const RTCMcorrections* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_MsgCount (pctxt, "msgCnt", &pvalue->msgCnt);

   asn1PrtToStrm_RTCM_Revision (pctxt, "rev", &pvalue->rev);

   if (pvalue->m.timeStampPresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "timeStamp", &pvalue->timeStamp);
   }

   if (pvalue->m.anchorPointPresent) {
      asn1PrtToStrm_FullPositionVector (pctxt, "anchorPoint", &pvalue->anchorPoint);
   }

   if (pvalue->m.rtcmHeaderPresent) {
      asn1PrtToStrm_RTCMheader (pctxt, "rtcmHeader", &pvalue->rtcmHeader);
   }

   asn1PrtToStrm_RTCMmessageList (pctxt, "msgs", &pvalue->msgs);

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RTCMcorrections_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_EnabledLaneList (OSCTXT *pctxt, 
   const char* name, const EnabledLaneList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_LaneID (pctxt, namebuf, &pvalue->elem[xx1]);
   }
   return 0;
}

int asn1PrtToStrm_TimeChangeDetails (OSCTXT *pctxt, 
   const char* name, const TimeChangeDetails* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.startTimePresent) {
      asn1PrtToStrm_TimeMark (pctxt, "startTime", &pvalue->startTime);
   }

   asn1PrtToStrm_TimeMark (pctxt, "minEndTime", &pvalue->minEndTime);

   if (pvalue->m.maxEndTimePresent) {
      asn1PrtToStrm_TimeMark (pctxt, "maxEndTime", &pvalue->maxEndTime);
   }

   if (pvalue->m.likelyTimePresent) {
      asn1PrtToStrm_TimeMark (pctxt, "likelyTime", &pvalue->likelyTime);
   }

   if (pvalue->m.confidencePresent) {
      asn1PrtToStrm_TimeIntervalConfidence (pctxt, "confidence", &pvalue->confidence);
   }

   if (pvalue->m.nextTimePresent) {
      asn1PrtToStrm_TimeMark (pctxt, "nextTime", &pvalue->nextTime);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_AdvisorySpeed_regional (OSCTXT *pctxt, 
   const char* name, const AdvisorySpeed_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_AdvisorySpeed (OSCTXT *pctxt, 
   const char* name, const AdvisorySpeed* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_AdvisorySpeedType (pctxt, "type", &pvalue->type);

   if (pvalue->m.speedPresent) {
      asn1PrtToStrm_SpeedAdvice (pctxt, "speed", &pvalue->speed);
   }

   if (pvalue->m.confidencePresent) {
      asn1PrtToStrm_SpeedConfidence (pctxt, "confidence", &pvalue->confidence);
   }

   if (pvalue->m.distancePresent) {
      asn1PrtToStrm_ZoneLength (pctxt, "distance", &pvalue->distance);
   }

   if (pvalue->m.class_Present) {
      asn1PrtToStrm_RestrictionClassID (pctxt, "class_", &pvalue->class_);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_AdvisorySpeed_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_AdvisorySpeedList (OSCTXT *pctxt, 
   const char* name, const AdvisorySpeedList* pvalue)
{
   AdvisorySpeed* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((AdvisorySpeed*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_AdvisorySpeed (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_MovementEvent_regional (OSCTXT *pctxt, 
   const char* name, const MovementEvent_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_MovementEvent (OSCTXT *pctxt, 
   const char* name, const MovementEvent* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_MovementPhaseState (pctxt, "eventState", &pvalue->eventState);

   if (pvalue->m.timingPresent) {
      asn1PrtToStrm_TimeChangeDetails (pctxt, "timing", &pvalue->timing);
   }

   if (pvalue->m.speedsPresent) {
      asn1PrtToStrm_AdvisorySpeedList (pctxt, "speeds", &pvalue->speeds);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_MovementEvent_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_MovementEventList (OSCTXT *pctxt, 
   const char* name, const MovementEventList* pvalue)
{
   MovementEvent* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((MovementEvent*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_MovementEvent (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_ConnectionManeuverAssist_regional (OSCTXT *pctxt, 
   const char* name, const ConnectionManeuverAssist_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_ConnectionManeuverAssist (OSCTXT *pctxt, 
   const char* name, const ConnectionManeuverAssist* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_LaneConnectionID (pctxt, "connectionID", &pvalue->connectionID);

   if (pvalue->m.queueLengthPresent) {
      asn1PrtToStrm_ZoneLength (pctxt, "queueLength", &pvalue->queueLength);
   }

   if (pvalue->m.availableStorageLengthPresent) {
      asn1PrtToStrm_ZoneLength (pctxt, "availableStorageLength", &pvalue->availableStorageLength);
   }

   if (pvalue->m.waitOnStopPresent) {
      asn1PrtToStrm_WaitOnStopline (pctxt, "waitOnStop", &pvalue->waitOnStop);
   }

   if (pvalue->m.pedBicycleDetectPresent) {
      asn1PrtToStrm_PedestrianBicycleDetect (pctxt, "pedBicycleDetect", &pvalue->pedBicycleDetect);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_ConnectionManeuverAssist_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ManeuverAssistList (OSCTXT *pctxt, 
   const char* name, const ManeuverAssistList* pvalue)
{
   ConnectionManeuverAssist* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ConnectionManeuverAssist*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_ConnectionManeuverAssist (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_MovementState_regional (OSCTXT *pctxt, 
   const char* name, const MovementState_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_MovementState (OSCTXT *pctxt, 
   const char* name, const MovementState* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.movementNamePresent) {
      asn1PrtToStrm_DescriptiveName (pctxt, "movementName", pvalue->movementName);
   }

   asn1PrtToStrm_SignalGroupID (pctxt, "signalGroup", &pvalue->signalGroup);

   asn1PrtToStrm_MovementEventList (pctxt, "state_time_speed", &pvalue->state_time_speed);

   if (pvalue->m.maneuverAssistListPresent) {
      asn1PrtToStrm_ManeuverAssistList (pctxt, "maneuverAssistList", &pvalue->maneuverAssistList);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_MovementState_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_MovementList (OSCTXT *pctxt, 
   const char* name, const MovementList* pvalue)
{
   MovementState* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((MovementState*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_MovementState (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_IntersectionState_regional (OSCTXT *pctxt, 
   const char* name, const IntersectionState_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_IntersectionState (OSCTXT *pctxt, 
   const char* name, const IntersectionState* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.namePresent) {
      asn1PrtToStrm_DescriptiveName (pctxt, "name", pvalue->name);
   }

   asn1PrtToStrm_IntersectionReferenceID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_MsgCount (pctxt, "revision", &pvalue->revision);

   asn1PrtToStrm_IntersectionStatusObject (pctxt, "status", &pvalue->status);

   if (pvalue->m.moyPresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "moy", &pvalue->moy);
   }

   if (pvalue->m.timeStampPresent) {
      asn1PrtToStrm_DSecond (pctxt, "timeStamp", &pvalue->timeStamp);
   }

   if (pvalue->m.enabledLanesPresent) {
      asn1PrtToStrm_EnabledLaneList (pctxt, "enabledLanes", &pvalue->enabledLanes);
   }

   asn1PrtToStrm_MovementList (pctxt, "states", &pvalue->states);

   if (pvalue->m.maneuverAssistListPresent) {
      asn1PrtToStrm_ManeuverAssistList (pctxt, "maneuverAssistList", &pvalue->maneuverAssistList);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_IntersectionState_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_IntersectionStateList (OSCTXT *pctxt, 
   const char* name, const IntersectionStateList* pvalue)
{
   IntersectionState* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((IntersectionState*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_IntersectionState (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_SPAT_regional (OSCTXT *pctxt, 
   const char* name, const SPAT_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_SPAT (OSCTXT *pctxt, const char* name, const SPAT* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.timeStampPresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "timeStamp", &pvalue->timeStamp);
   }

   if (pvalue->m.namePresent) {
      asn1PrtToStrm_DescriptiveName (pctxt, "name", pvalue->name);
   }

   asn1PrtToStrm_IntersectionStateList (pctxt, "intersections", &pvalue->intersections);

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_SPAT_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_IntersectionAccessPoint (OSCTXT *pctxt, 
   const char* name, const IntersectionAccessPoint* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* lane */
      case 1:
      {
         asn1PrtToStrm_LaneID (pctxt, "lane", &pvalue->u.lane);
         break;
      }
      /* approach */
      case 2:
      {
         asn1PrtToStrm_ApproachID (pctxt, "approach", &pvalue->u.approach);
         break;
      }
      /* connection */
      case 3:
      {
         asn1PrtToStrm_LaneConnectionID (pctxt, "connection", &pvalue->u.connection);
         break;
      }
      /* extElem1 */
      case 4:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamHexStr (pctxt, "extElem1",
            pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SignalRequest_regional (OSCTXT *pctxt, 
   const char* name, const SignalRequest_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_SignalRequest (OSCTXT *pctxt, 
   const char* name, const SignalRequest* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_IntersectionReferenceID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_RequestID (pctxt, "requestID", &pvalue->requestID);

   asn1PrtToStrm_PriorityRequestType (pctxt, "requestType", &pvalue->requestType);

   asn1PrtToStrm_IntersectionAccessPoint (pctxt, "inBoundLane", &pvalue->inBoundLane);

   if (pvalue->m.outBoundLanePresent) {
      asn1PrtToStrm_IntersectionAccessPoint (pctxt, "outBoundLane", &pvalue->outBoundLane);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_SignalRequest_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SignalRequestPackage_regional (OSCTXT *pctxt, 
   const char* name, const SignalRequestPackage_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_SignalRequestPackage (OSCTXT *pctxt, 
   const char* name, const SignalRequestPackage* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_SignalRequest (pctxt, "request", &pvalue->request);

   if (pvalue->m.minutePresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "minute", &pvalue->minute);
   }

   if (pvalue->m.secondPresent) {
      asn1PrtToStrm_DSecond (pctxt, "second", &pvalue->second);
   }

   if (pvalue->m.durationPresent) {
      asn1PrtToStrm_DSecond (pctxt, "duration", &pvalue->duration);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_SignalRequestPackage_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SignalRequestList (OSCTXT *pctxt, 
   const char* name, const SignalRequestList* pvalue)
{
   SignalRequestPackage* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((SignalRequestPackage*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_SignalRequestPackage (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_RequestorType (OSCTXT *pctxt, 
   const char* name, const RequestorType* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_BasicVehicleRole (pctxt, "role", &pvalue->role);

   if (pvalue->m.subrolePresent) {
      asn1PrtToStrm_RequestSubRole (pctxt, "subrole", &pvalue->subrole);
   }

   if (pvalue->m.requestPresent) {
      asn1PrtToStrm_RequestImportanceLevel (pctxt, "request", &pvalue->request);
   }

   if (pvalue->m.iso3883Present) {
      asn1PrtToStrm_Iso3833VehicleType (pctxt, "iso3883", &pvalue->iso3883);
   }

   if (pvalue->m.hpmsTypePresent) {
      asn1PrtToStrm_VehicleType (pctxt, "hpmsType", &pvalue->hpmsType);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RequestorPositionVector (OSCTXT *pctxt, 
   const char* name, const RequestorPositionVector* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Position3D (pctxt, "position", &pvalue->position);

   if (pvalue->m.headingPresent) {
      asn1PrtToStrm_Angle (pctxt, "heading", &pvalue->heading);
   }

   if (pvalue->m.speedPresent) {
      asn1PrtToStrm_TransmissionAndSpeed (pctxt, "speed", &pvalue->speed);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RequestorDescription_regional (OSCTXT *pctxt, 
   const char* name, const RequestorDescription_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_RequestorDescription (OSCTXT *pctxt, 
   const char* name, const RequestorDescription* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_VehicleID (pctxt, "id", &pvalue->id);

   if (pvalue->m.typePresent) {
      asn1PrtToStrm_RequestorType (pctxt, "type", &pvalue->type);
   }

   if (pvalue->m.positionPresent) {
      asn1PrtToStrm_RequestorPositionVector (pctxt, "position", &pvalue->position);
   }

   if (pvalue->m.namePresent) {
      asn1PrtToStrm_DescriptiveName (pctxt, "name", pvalue->name);
   }

   if (pvalue->m.routeNamePresent) {
      asn1PrtToStrm_DescriptiveName (pctxt, "routeName", pvalue->routeName);
   }

   if (pvalue->m.transitStatusPresent) {
      asn1PrtToStrm_TransitVehicleStatus (pctxt, "transitStatus", &pvalue->transitStatus);
   }

   if (pvalue->m.transitOccupancyPresent) {
      asn1PrtToStrm_TransitVehicleOccupancy (pctxt, "transitOccupancy", &pvalue->transitOccupancy);
   }

   if (pvalue->m.transitSchedulePresent) {
      asn1PrtToStrm_DeltaTime (pctxt, "transitSchedule", &pvalue->transitSchedule);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RequestorDescription_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SignalRequestMessage_regional (OSCTXT *pctxt, 
   const char* name, const SignalRequestMessage_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_SignalRequestMessage (OSCTXT *pctxt, 
   const char* name, const SignalRequestMessage* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.timeStampPresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "timeStamp", &pvalue->timeStamp);
   }

   asn1PrtToStrm_DSecond (pctxt, "second", &pvalue->second);

   if (pvalue->m.sequenceNumberPresent) {
      asn1PrtToStrm_MsgCount (pctxt, "sequenceNumber", &pvalue->sequenceNumber);
   }

   if (pvalue->m.requestsPresent) {
      asn1PrtToStrm_SignalRequestList (pctxt, "requests", &pvalue->requests);
   }

   asn1PrtToStrm_RequestorDescription (pctxt, "requestor", &pvalue->requestor);

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_SignalRequestMessage_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SignalRequesterInfo (OSCTXT *pctxt, 
   const char* name, const SignalRequesterInfo* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_VehicleID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_RequestID (pctxt, "request", &pvalue->request);

   asn1PrtToStrm_MsgCount (pctxt, "sequenceNumber", &pvalue->sequenceNumber);

   if (pvalue->m.rolePresent) {
      asn1PrtToStrm_BasicVehicleRole (pctxt, "role", &pvalue->role);
   }

   if (pvalue->m.typeDataPresent) {
      asn1PrtToStrm_RequestorType (pctxt, "typeData", &pvalue->typeData);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SignalStatusPackage_regional (OSCTXT *pctxt, 
   const char* name, const SignalStatusPackage_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_SignalStatusPackage (OSCTXT *pctxt, 
   const char* name, const SignalStatusPackage* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.requesterPresent) {
      asn1PrtToStrm_SignalRequesterInfo (pctxt, "requester", &pvalue->requester);
   }

   asn1PrtToStrm_IntersectionAccessPoint (pctxt, "inboundOn", &pvalue->inboundOn);

   if (pvalue->m.outboundOnPresent) {
      asn1PrtToStrm_IntersectionAccessPoint (pctxt, "outboundOn", &pvalue->outboundOn);
   }

   if (pvalue->m.minutePresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "minute", &pvalue->minute);
   }

   if (pvalue->m.secondPresent) {
      asn1PrtToStrm_DSecond (pctxt, "second", &pvalue->second);
   }

   if (pvalue->m.durationPresent) {
      asn1PrtToStrm_DSecond (pctxt, "duration", &pvalue->duration);
   }

   asn1PrtToStrm_PrioritizationResponseStatus (pctxt, "status", &pvalue->status);

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_SignalStatusPackage_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SignalStatusPackageList (OSCTXT *pctxt, 
   const char* name, const SignalStatusPackageList* pvalue)
{
   SignalStatusPackage* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((SignalStatusPackage*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_SignalStatusPackage (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_SignalStatus_regional (OSCTXT *pctxt, 
   const char* name, const SignalStatus_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_SignalStatus (OSCTXT *pctxt, 
   const char* name, const SignalStatus* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_MsgCount (pctxt, "sequenceNumber", &pvalue->sequenceNumber);

   asn1PrtToStrm_IntersectionReferenceID (pctxt, "id", &pvalue->id);

   asn1PrtToStrm_SignalStatusPackageList (pctxt, "sigStatus", &pvalue->sigStatus);

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_SignalStatus_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SignalStatusList (OSCTXT *pctxt, 
   const char* name, const SignalStatusList* pvalue)
{
   SignalStatus* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((SignalStatus*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_SignalStatus (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_SignalStatusMessage_regional (OSCTXT *pctxt, 
   const char* name, const SignalStatusMessage_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_SignalStatusMessage (OSCTXT *pctxt, 
   const char* name, const SignalStatusMessage* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.timeStampPresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "timeStamp", &pvalue->timeStamp);
   }

   asn1PrtToStrm_DSecond (pctxt, "second", &pvalue->second);

   if (pvalue->m.sequenceNumberPresent) {
      asn1PrtToStrm_MsgCount (pctxt, "sequenceNumber", &pvalue->sequenceNumber);
   }

   asn1PrtToStrm_SignalStatusList (pctxt, "status", &pvalue->status);

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_SignalStatusMessage_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RoadSignID (OSCTXT *pctxt, 
   const char* name, const RoadSignID* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Position3D (pctxt, "position", &pvalue->position);

   asn1PrtToStrm_HeadingSlice (pctxt, "viewAngle", &pvalue->viewAngle);

   if (pvalue->m.mutcdCodePresent) {
      asn1PrtToStrm_MUTCDCode (pctxt, "mutcdCode", &pvalue->mutcdCode);
   }

   if (pvalue->m.crcPresent) {
      asn1PrtToStrm_MsgCRC (pctxt, "crc", &pvalue->crc);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TravelerDataFrame_msgId (OSCTXT *pctxt, 
   const char* name, const TravelerDataFrame_msgId* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* furtherInfoID */
      case 1:
      {
         asn1PrtToStrm_FurtherInfoID (pctxt, "furtherInfoID", pvalue->u.furtherInfoID);
         break;
      }
      /* roadSignID */
      case 2:
      {
         asn1PrtToStrm_RoadSignID (pctxt, "roadSignID", pvalue->u.roadSignID);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Node_LL_24B (OSCTXT *pctxt, 
   const char* name, const Node_LL_24B* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_OffsetLL_B12 (pctxt, "lon", &pvalue->lon);

   asn1PrtToStrm_OffsetLL_B12 (pctxt, "lat", &pvalue->lat);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Node_LL_28B (OSCTXT *pctxt, 
   const char* name, const Node_LL_28B* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_OffsetLL_B14 (pctxt, "lon", &pvalue->lon);

   asn1PrtToStrm_OffsetLL_B14 (pctxt, "lat", &pvalue->lat);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Node_LL_32B (OSCTXT *pctxt, 
   const char* name, const Node_LL_32B* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_OffsetLL_B16 (pctxt, "lon", &pvalue->lon);

   asn1PrtToStrm_OffsetLL_B16 (pctxt, "lat", &pvalue->lat);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Node_LL_36B (OSCTXT *pctxt, 
   const char* name, const Node_LL_36B* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_OffsetLL_B18 (pctxt, "lon", &pvalue->lon);

   asn1PrtToStrm_OffsetLL_B18 (pctxt, "lat", &pvalue->lat);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Node_LL_44B (OSCTXT *pctxt, 
   const char* name, const Node_LL_44B* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_OffsetLL_B22 (pctxt, "lon", &pvalue->lon);

   asn1PrtToStrm_OffsetLL_B22 (pctxt, "lat", &pvalue->lat);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Node_LL_48B (OSCTXT *pctxt, 
   const char* name, const Node_LL_48B* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_OffsetLL_B24 (pctxt, "lon", &pvalue->lon);

   asn1PrtToStrm_OffsetLL_B24 (pctxt, "lat", &pvalue->lat);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_NodeOffsetPointLL (OSCTXT *pctxt, 
   const char* name, const NodeOffsetPointLL* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* node-LL1 */
      case 1:
      {
         asn1PrtToStrm_Node_LL_24B (pctxt, "node-LL1", pvalue->u.node_LL1);
         break;
      }
      /* node-LL2 */
      case 2:
      {
         asn1PrtToStrm_Node_LL_28B (pctxt, "node-LL2", pvalue->u.node_LL2);
         break;
      }
      /* node-LL3 */
      case 3:
      {
         asn1PrtToStrm_Node_LL_32B (pctxt, "node-LL3", pvalue->u.node_LL3);
         break;
      }
      /* node-LL4 */
      case 4:
      {
         asn1PrtToStrm_Node_LL_36B (pctxt, "node-LL4", pvalue->u.node_LL4);
         break;
      }
      /* node-LL5 */
      case 5:
      {
         asn1PrtToStrm_Node_LL_44B (pctxt, "node-LL5", pvalue->u.node_LL5);
         break;
      }
      /* node-LL6 */
      case 6:
      {
         asn1PrtToStrm_Node_LL_48B (pctxt, "node-LL6", pvalue->u.node_LL6);
         break;
      }
      /* node-LatLon */
      case 7:
      {
         asn1PrtToStrm_Node_LLmD_64b (pctxt, "node-LatLon", pvalue->u.node_LatLon);
         break;
      }
      /* regional */
      case 8:
      {
         asn1PrtToStrm_RegionalExtension (pctxt, "regional", pvalue->u.regional);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_NodeAttributeLLList (OSCTXT *pctxt, 
   const char* name, const NodeAttributeLLList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_NodeAttributeLL (pctxt, namebuf, &pvalue->elem[xx1]);
   }
   return 0;
}

int asn1PrtToStrm_SegmentAttributeLLList (OSCTXT *pctxt, 
   const char* name, const SegmentAttributeLLList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_SegmentAttributeLL (pctxt, namebuf, &pvalue->elem[xx1]);
   }
   return 0;
}

int asn1PrtToStrm_NodeAttributeSetLL_regional (OSCTXT *pctxt, 
   const char* name, const NodeAttributeSetLL_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_NodeAttributeSetLL (OSCTXT *pctxt, 
   const char* name, const NodeAttributeSetLL* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.localNodePresent) {
      asn1PrtToStrm_NodeAttributeLLList (pctxt, "localNode", &pvalue->localNode);
   }

   if (pvalue->m.disabledPresent) {
      asn1PrtToStrm_SegmentAttributeLLList (pctxt, "disabled", &pvalue->disabled);
   }

   if (pvalue->m.enabledPresent) {
      asn1PrtToStrm_SegmentAttributeLLList (pctxt, "enabled", &pvalue->enabled);
   }

   if (pvalue->m.dataPresent) {
      asn1PrtToStrm_LaneDataAttributeList (pctxt, "data", &pvalue->data);
   }

   if (pvalue->m.dWidthPresent) {
      asn1PrtToStrm_Offset_B10 (pctxt, "dWidth", &pvalue->dWidth);
   }

   if (pvalue->m.dElevationPresent) {
      asn1PrtToStrm_Offset_B10 (pctxt, "dElevation", &pvalue->dElevation);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_NodeAttributeSetLL_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_NodeLL (OSCTXT *pctxt, 
   const char* name, const NodeLL* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_NodeOffsetPointLL (pctxt, "delta", &pvalue->delta);

   if (pvalue->m.attributesPresent) {
      asn1PrtToStrm_NodeAttributeSetLL (pctxt, "attributes", &pvalue->attributes);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_NodeSetLL (OSCTXT *pctxt, 
   const char* name, const NodeSetLL* pvalue)
{
   NodeLL* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((NodeLL*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_NodeLL (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_NodeListLL (OSCTXT *pctxt, 
   const char* name, const NodeListLL* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* nodes */
      case 1:
      {
         asn1PrtToStrm_NodeSetLL (pctxt, "nodes", pvalue->u.nodes);
         break;
      }
      /* extElem1 */
      case 2:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamHexStr (pctxt, "extElem1",
            pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_OffsetSystem_offset (OSCTXT *pctxt, 
   const char* name, const OffsetSystem_offset* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* xy */
      case 1:
      {
         asn1PrtToStrm_NodeListXY (pctxt, "xy", pvalue->u.xy);
         break;
      }
      /* ll */
      case 2:
      {
         asn1PrtToStrm_NodeListLL (pctxt, "ll", pvalue->u.ll);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_OffsetSystem (OSCTXT *pctxt, 
   const char* name, const OffsetSystem* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.scalePresent) {
      asn1PrtToStrm_Zoom (pctxt, "scale", &pvalue->scale);
   }

   asn1PrtToStrm_OffsetSystem_offset (pctxt, "offset", &pvalue->offset);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Circle (OSCTXT *pctxt, 
   const char* name, const Circle* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Position3D (pctxt, "center", &pvalue->center);

   asn1PrtToStrm_Radius_B12 (pctxt, "radius", &pvalue->radius);

   asn1PrtToStrm_DistanceUnits (pctxt, "units", &pvalue->units);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_GeometricProjection_regional (OSCTXT *pctxt, 
   const char* name, const GeometricProjection_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_GeometricProjection (OSCTXT *pctxt, 
   const char* name, const GeometricProjection* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_HeadingSlice (pctxt, "direction", &pvalue->direction);

   if (pvalue->m.extentPresent) {
      asn1PrtToStrm_Extent (pctxt, "extent", &pvalue->extent);
   }

   if (pvalue->m.laneWidthPresent) {
      asn1PrtToStrm_LaneWidth (pctxt, "laneWidth", &pvalue->laneWidth);
   }

   asn1PrtToStrm_Circle (pctxt, "circle", &pvalue->circle);

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_GeometricProjection_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ShapePointSet (OSCTXT *pctxt, 
   const char* name, const ShapePointSet* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.anchorPresent) {
      asn1PrtToStrm_Position3D (pctxt, "anchor", &pvalue->anchor);
   }

   if (pvalue->m.laneWidthPresent) {
      asn1PrtToStrm_LaneWidth (pctxt, "laneWidth", &pvalue->laneWidth);
   }

   if (pvalue->m.directionalityPresent) {
      asn1PrtToStrm_DirectionOfUse (pctxt, "directionality", &pvalue->directionality);
   }

   asn1PrtToStrm_NodeListXY (pctxt, "nodeList", &pvalue->nodeList);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RegionOffsets (OSCTXT *pctxt, 
   const char* name, const RegionOffsets* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_OffsetLL_B16 (pctxt, "xOffset", &pvalue->xOffset);

   asn1PrtToStrm_OffsetLL_B16 (pctxt, "yOffset", &pvalue->yOffset);

   if (pvalue->m.zOffsetPresent) {
      asn1PrtToStrm_OffsetLL_B16 (pctxt, "zOffset", &pvalue->zOffset);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RegionList (OSCTXT *pctxt, 
   const char* name, const RegionList* pvalue)
{
   RegionOffsets* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionOffsets*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionOffsets (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_RegionPointSet (OSCTXT *pctxt, 
   const char* name, const RegionPointSet* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.anchorPresent) {
      asn1PrtToStrm_Position3D (pctxt, "anchor", &pvalue->anchor);
   }

   if (pvalue->m.scalePresent) {
      asn1PrtToStrm_Zoom (pctxt, "scale", &pvalue->scale);
   }

   asn1PrtToStrm_RegionList (pctxt, "nodeList", &pvalue->nodeList);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ValidRegion_area (OSCTXT *pctxt, 
   const char* name, const ValidRegion_area* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* shapePointSet */
      case 1:
      {
         asn1PrtToStrm_ShapePointSet (pctxt, "shapePointSet", pvalue->u.shapePointSet);
         break;
      }
      /* circle */
      case 2:
      {
         asn1PrtToStrm_Circle (pctxt, "circle", pvalue->u.circle);
         break;
      }
      /* regionPointSet */
      case 3:
      {
         asn1PrtToStrm_RegionPointSet (pctxt, "regionPointSet", pvalue->u.regionPointSet);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ValidRegion (OSCTXT *pctxt, 
   const char* name, const ValidRegion* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_HeadingSlice (pctxt, "direction", &pvalue->direction);

   if (pvalue->m.extentPresent) {
      asn1PrtToStrm_Extent (pctxt, "extent", &pvalue->extent);
   }

   asn1PrtToStrm_ValidRegion_area (pctxt, "area", &pvalue->area);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_GeographicalPath_description (OSCTXT *pctxt, 
   const char* name, const GeographicalPath_description* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* path */
      case 1:
      {
         asn1PrtToStrm_OffsetSystem (pctxt, "path", pvalue->u.path);
         break;
      }
      /* geometry */
      case 2:
      {
         asn1PrtToStrm_GeometricProjection (pctxt, "geometry", pvalue->u.geometry);
         break;
      }
      /* oldRegion */
      case 3:
      {
         asn1PrtToStrm_ValidRegion (pctxt, "oldRegion", pvalue->u.oldRegion);
         break;
      }
      /* extElem1 */
      case 4:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamHexStr (pctxt, "extElem1",
            pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_GeographicalPath_regional (OSCTXT *pctxt, 
   const char* name, const GeographicalPath_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_GeographicalPath (OSCTXT *pctxt, 
   const char* name, const GeographicalPath* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.namePresent) {
      asn1PrtToStrm_DescriptiveName (pctxt, "name", pvalue->name);
   }

   if (pvalue->m.idPresent) {
      asn1PrtToStrm_RoadSegmentReferenceID (pctxt, "id", &pvalue->id);
   }

   if (pvalue->m.anchorPresent) {
      asn1PrtToStrm_Position3D (pctxt, "anchor", &pvalue->anchor);
   }

   if (pvalue->m.laneWidthPresent) {
      asn1PrtToStrm_LaneWidth (pctxt, "laneWidth", &pvalue->laneWidth);
   }

   if (pvalue->m.directionalityPresent) {
      asn1PrtToStrm_DirectionOfUse (pctxt, "directionality", &pvalue->directionality);
   }

   if (pvalue->m.closedPathPresent) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamBoolean (pctxt, "closedPath", pvalue->closedPath);
   }

   if (pvalue->m.directionPresent) {
      asn1PrtToStrm_HeadingSlice (pctxt, "direction", &pvalue->direction);
   }

   if (pvalue->m.descriptionPresent) {
      asn1PrtToStrm_GeographicalPath_description (pctxt, "description", &pvalue->description);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_GeographicalPath_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TravelerDataFrame_regions (OSCTXT *pctxt, 
   const char* name, const TravelerDataFrame_regions* pvalue)
{
   GeographicalPath* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((GeographicalPath*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_GeographicalPath (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_WorkZone_element_item (OSCTXT *pctxt, 
   const char* name, const WorkZone_element_item* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* itis */
      case 1:
      {
         asn1PrtToStrm_ITIScodes (pctxt, "itis", &pvalue->u.itis);
         break;
      }
      /* text */
      case 2:
      {
         asn1PrtToStrm_ITIStextPhrase (pctxt, "text", pvalue->u.text);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_WorkZone_element (OSCTXT *pctxt, 
   const char* name, const WorkZone_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_WorkZone_element_item (pctxt, "item", &pvalue->item);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_WorkZone (OSCTXT *pctxt, 
   const char* name, const WorkZone* pvalue)
{
   WorkZone_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((WorkZone_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_WorkZone_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_GenericSignage_element_item (OSCTXT *pctxt, 
   const char* name, const GenericSignage_element_item* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* itis */
      case 1:
      {
         asn1PrtToStrm_ITIScodes (pctxt, "itis", &pvalue->u.itis);
         break;
      }
      /* text */
      case 2:
      {
         asn1PrtToStrm_ITIStextPhrase (pctxt, "text", pvalue->u.text);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_GenericSignage_element (OSCTXT *pctxt, 
   const char* name, const GenericSignage_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_GenericSignage_element_item (pctxt, "item", &pvalue->item);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_GenericSignage (OSCTXT *pctxt, 
   const char* name, const GenericSignage* pvalue)
{
   GenericSignage_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((GenericSignage_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_GenericSignage_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_SpeedLimit_element_item (OSCTXT *pctxt, 
   const char* name, const SpeedLimit_element_item* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* itis */
      case 1:
      {
         asn1PrtToStrm_ITIScodes (pctxt, "itis", &pvalue->u.itis);
         break;
      }
      /* text */
      case 2:
      {
         asn1PrtToStrm_ITIStextPhrase (pctxt, "text", pvalue->u.text);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SpeedLimit_element (OSCTXT *pctxt, 
   const char* name, const SpeedLimit_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_SpeedLimit_element_item (pctxt, "item", &pvalue->item);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SpeedLimit (OSCTXT *pctxt, 
   const char* name, const SpeedLimit* pvalue)
{
   SpeedLimit_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((SpeedLimit_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_SpeedLimit_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_ExitService_element_item (OSCTXT *pctxt, 
   const char* name, const ExitService_element_item* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* itis */
      case 1:
      {
         asn1PrtToStrm_ITIScodes (pctxt, "itis", &pvalue->u.itis);
         break;
      }
      /* text */
      case 2:
      {
         asn1PrtToStrm_ITIStextPhrase (pctxt, "text", pvalue->u.text);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ExitService_element (OSCTXT *pctxt, 
   const char* name, const ExitService_element* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_ExitService_element_item (pctxt, "item", &pvalue->item);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ExitService (OSCTXT *pctxt, 
   const char* name, const ExitService* pvalue)
{
   ExitService_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ExitService_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_ExitService_element (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_TravelerDataFrame_content (OSCTXT *pctxt, 
   const char* name, const TravelerDataFrame_content* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* advisory */
      case 1:
      {
         asn1PrtToStrm_ITIScodesAndText (pctxt, "advisory", pvalue->u.advisory);
         break;
      }
      /* workZone */
      case 2:
      {
         asn1PrtToStrm_WorkZone (pctxt, "workZone", pvalue->u.workZone);
         break;
      }
      /* genericSign */
      case 3:
      {
         asn1PrtToStrm_GenericSignage (pctxt, "genericSign", pvalue->u.genericSign);
         break;
      }
      /* speedLimit */
      case 4:
      {
         asn1PrtToStrm_SpeedLimit (pctxt, "speedLimit", pvalue->u.speedLimit);
         break;
      }
      /* exitService */
      case 5:
      {
         asn1PrtToStrm_ExitService (pctxt, "exitService", pvalue->u.exitService);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TravelerDataFrame (OSCTXT *pctxt, 
   const char* name, const TravelerDataFrame* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_SSPindex (pctxt, "sspTimRights", &pvalue->sspTimRights);

   asn1PrtToStrm_TravelerInfoType (pctxt, "frameType", &pvalue->frameType);

   asn1PrtToStrm_TravelerDataFrame_msgId (pctxt, "msgId", &pvalue->msgId);

   if (pvalue->m.startYearPresent) {
      asn1PrtToStrm_DYear (pctxt, "startYear", &pvalue->startYear);
   }

   asn1PrtToStrm_MinuteOfTheYear (pctxt, "startTime", &pvalue->startTime);

   asn1PrtToStrm_MinutesDuration (pctxt, "duratonTime", &pvalue->duratonTime);

   asn1PrtToStrm_SignPrority (pctxt, "priority", &pvalue->priority);

   asn1PrtToStrm_SSPindex (pctxt, "sspLocationRights", &pvalue->sspLocationRights);

   asn1PrtToStrm_TravelerDataFrame_regions (pctxt, "regions", &pvalue->regions);

   asn1PrtToStrm_SSPindex (pctxt, "sspMsgRights1", &pvalue->sspMsgRights1);

   asn1PrtToStrm_SSPindex (pctxt, "sspMsgRights2", &pvalue->sspMsgRights2);

   asn1PrtToStrm_TravelerDataFrame_content (pctxt, "content", &pvalue->content);

   if (pvalue->m.urlPresent) {
      asn1PrtToStrm_URL_Short (pctxt, "url", pvalue->url);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TravelerDataFrameList (OSCTXT *pctxt, 
   const char* name, const TravelerDataFrameList* pvalue)
{
   TravelerDataFrame* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((TravelerDataFrame*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_TravelerDataFrame (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_TravelerInformation_regional (OSCTXT *pctxt, 
   const char* name, const TravelerInformation_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_TravelerInformation (OSCTXT *pctxt, 
   const char* name, const TravelerInformation* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_MsgCount (pctxt, "msgCnt", &pvalue->msgCnt);

   if (pvalue->m.timeStampPresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "timeStamp", &pvalue->timeStamp);
   }

   if (pvalue->m.packetIDPresent) {
      asn1PrtToStrm_UniqueMSGID (pctxt, "packetID", &pvalue->packetID);
   }

   if (pvalue->m.urlBPresent) {
      asn1PrtToStrm_URL_Base (pctxt, "urlB", pvalue->urlB);
   }

   asn1PrtToStrm_TravelerDataFrameList (pctxt, "dataFrames", &pvalue->dataFrames);

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_TravelerInformation_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Header (OSCTXT *pctxt, 
   const char* name, const Header* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.yearPresent) {
      asn1PrtToStrm_DYear (pctxt, "year", &pvalue->year);
   }

   if (pvalue->m.timeStampPresent) {
      asn1PrtToStrm_MinuteOfTheYear (pctxt, "timeStamp", &pvalue->timeStamp);
   }

   if (pvalue->m.secMarkPresent) {
      asn1PrtToStrm_DSecond (pctxt, "secMark", &pvalue->secMark);
   }

   if (pvalue->m.msgIssueRevisionPresent) {
      asn1PrtToStrm_MsgCount (pctxt, "msgIssueRevision", &pvalue->msgIssueRevision);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage00 (OSCTXT *pctxt, 
   const char* name, const TestMessage00* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage01 (OSCTXT *pctxt, 
   const char* name, const TestMessage01* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage02 (OSCTXT *pctxt, 
   const char* name, const TestMessage02* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage03 (OSCTXT *pctxt, 
   const char* name, const TestMessage03* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage04 (OSCTXT *pctxt, 
   const char* name, const TestMessage04* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage05 (OSCTXT *pctxt, 
   const char* name, const TestMessage05* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage06 (OSCTXT *pctxt, 
   const char* name, const TestMessage06* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage07 (OSCTXT *pctxt, 
   const char* name, const TestMessage07* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage08 (OSCTXT *pctxt, 
   const char* name, const TestMessage08* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage09 (OSCTXT *pctxt, 
   const char* name, const TestMessage09* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage10 (OSCTXT *pctxt, 
   const char* name, const TestMessage10* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage11 (OSCTXT *pctxt, 
   const char* name, const TestMessage11* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage12 (OSCTXT *pctxt, 
   const char* name, const TestMessage12* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage13 (OSCTXT *pctxt, 
   const char* name, const TestMessage13* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage14 (OSCTXT *pctxt, 
   const char* name, const TestMessage14* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TestMessage15 (OSCTXT *pctxt, 
   const char* name, const TestMessage15* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.headerPresent) {
      asn1PrtToStrm_Header (pctxt, "header", &pvalue->header);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_RegionalExtension (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_DDate (OSCTXT *pctxt, const char* name, const DDate* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_DYear (pctxt, "year", &pvalue->year);

   asn1PrtToStrm_DMonth (pctxt, "month", &pvalue->month);

   asn1PrtToStrm_DDay (pctxt, "day", &pvalue->day);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_DFullTime (OSCTXT *pctxt, 
   const char* name, const DFullTime* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_DYear (pctxt, "year", &pvalue->year);

   asn1PrtToStrm_DMonth (pctxt, "month", &pvalue->month);

   asn1PrtToStrm_DDay (pctxt, "day", &pvalue->day);

   asn1PrtToStrm_DHour (pctxt, "hour", &pvalue->hour);

   asn1PrtToStrm_DMinute (pctxt, "minute", &pvalue->minute);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_DMonthDay (OSCTXT *pctxt, 
   const char* name, const DMonthDay* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_DMonth (pctxt, "month", &pvalue->month);

   asn1PrtToStrm_DDay (pctxt, "day", &pvalue->day);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_DTime (OSCTXT *pctxt, const char* name, const DTime* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_DHour (pctxt, "hour", &pvalue->hour);

   asn1PrtToStrm_DMinute (pctxt, "minute", &pvalue->minute);

   asn1PrtToStrm_DSecond (pctxt, "second", &pvalue->second);

   if (pvalue->m.offsetPresent) {
      asn1PrtToStrm_DOffset (pctxt, "offset", &pvalue->offset);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_DYearMonth (OSCTXT *pctxt, 
   const char* name, const DYearMonth* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_DYear (pctxt, "year", &pvalue->year);

   asn1PrtToStrm_DMonth (pctxt, "month", &pvalue->month);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_DisabledVehicle (OSCTXT *pctxt, 
   const char* name, const DisabledVehicle* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamUnsigned (pctxt, "statusDetails", pvalue->statusDetails);

   if (pvalue->m.locationDetailsPresent) {
      asn1PrtToStrm_GenericLocations (pctxt, "locationDetails", &pvalue->locationDetails);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_EventDescription_description (OSCTXT *pctxt, 
   const char* name, const EventDescription_description* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_ITIScodes (pctxt, namebuf, &pvalue->elem[xx1]);
   }
   return 0;
}

int asn1PrtToStrm_EventDescription_regional (OSCTXT *pctxt, 
   const char* name, const EventDescription_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_EventDescription (OSCTXT *pctxt, 
   const char* name, const EventDescription* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_ITIScodes (pctxt, "typeEvent", &pvalue->typeEvent);

   if (pvalue->m.descriptionPresent) {
      asn1PrtToStrm_EventDescription_description (pctxt, "description", &pvalue->description);
   }

   if (pvalue->m.priorityPresent) {
      asn1PrtToStrm_Priority (pctxt, "priority", &pvalue->priority);
   }

   if (pvalue->m.headingPresent) {
      asn1PrtToStrm_HeadingSlice (pctxt, "heading", &pvalue->heading);
   }

   if (pvalue->m.extentPresent) {
      asn1PrtToStrm_Extent (pctxt, "extent", &pvalue->extent);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_EventDescription_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_ObstacleDetection (OSCTXT *pctxt, 
   const char* name, const ObstacleDetection* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_ObstacleDistance (pctxt, "obDist", &pvalue->obDist);

   asn1PrtToStrm_ObstacleDirection (pctxt, "obDirect", &pvalue->obDirect);

   if (pvalue->m.descriptionPresent) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamUnsigned (pctxt, "description", pvalue->description);
   }

   if (pvalue->m.locationDetailsPresent) {
      asn1PrtToStrm_GenericLocations (pctxt, "locationDetails", &pvalue->locationDetails);
   }

   asn1PrtToStrm_DDateTime (pctxt, "dateTime", &pvalue->dateTime);

   if (pvalue->m.vertEventPresent) {
      asn1PrtToStrm_VerticalAccelerationThreshold (pctxt, "vertEvent", &pvalue->vertEvent);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_PivotPointDescription (OSCTXT *pctxt, 
   const char* name, const PivotPointDescription* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Offset_B11 (pctxt, "pivotOffset", &pvalue->pivotOffset);

   asn1PrtToStrm_Angle (pctxt, "pivotAngle", &pvalue->pivotAngle);

   asn1PrtToStrm_PivotingAllowed (pctxt, "pivots", &pvalue->pivots);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RTCMPackage (OSCTXT *pctxt, 
   const char* name, const RTCMPackage* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.rtcmHeaderPresent) {
      asn1PrtToStrm_RTCMheader (pctxt, "rtcmHeader", &pvalue->rtcmHeader);
   }

   asn1PrtToStrm_RTCMmessageList (pctxt, "msgs", &pvalue->msgs);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TrailerHistoryPoint (OSCTXT *pctxt, 
   const char* name, const TrailerHistoryPoint* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Angle (pctxt, "pivotAngle", &pvalue->pivotAngle);

   asn1PrtToStrm_TimeOffset (pctxt, "timeOffset", &pvalue->timeOffset);

   asn1PrtToStrm_Node_XY_24b (pctxt, "positionOffset", &pvalue->positionOffset);

   if (pvalue->m.elevationOffsetPresent) {
      asn1PrtToStrm_VertOffset_B07 (pctxt, "elevationOffset", &pvalue->elevationOffset);
   }

   if (pvalue->m.headingPresent) {
      asn1PrtToStrm_CoarseHeading (pctxt, "heading", &pvalue->heading);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TrailerHistoryPointList (OSCTXT *pctxt, 
   const char* name, const TrailerHistoryPointList* pvalue)
{
   TrailerHistoryPoint* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((TrailerHistoryPoint*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_TrailerHistoryPoint (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_TrailerUnitDescription (OSCTXT *pctxt, 
   const char* name, const TrailerUnitDescription* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_IsDolly (pctxt, "isDolly", &pvalue->isDolly);

   asn1PrtToStrm_VehicleWidth (pctxt, "width", &pvalue->width);

   asn1PrtToStrm_VehicleLength (pctxt, "length", &pvalue->length);

   if (pvalue->m.heightPresent) {
      asn1PrtToStrm_VehicleHeight (pctxt, "height", &pvalue->height);
   }

   if (pvalue->m.massPresent) {
      asn1PrtToStrm_TrailerMass (pctxt, "mass", &pvalue->mass);
   }

   if (pvalue->m.bumperHeightsPresent) {
      asn1PrtToStrm_BumperHeights (pctxt, "bumperHeights", &pvalue->bumperHeights);
   }

   if (pvalue->m.centerOfGravityPresent) {
      asn1PrtToStrm_VehicleHeight (pctxt, "centerOfGravity", &pvalue->centerOfGravity);
   }

   asn1PrtToStrm_PivotPointDescription (pctxt, "frontPivot", &pvalue->frontPivot);

   if (pvalue->m.rearPivotPresent) {
      asn1PrtToStrm_PivotPointDescription (pctxt, "rearPivot", &pvalue->rearPivot);
   }

   if (pvalue->m.rearWheelOffsetPresent) {
      asn1PrtToStrm_Offset_B12 (pctxt, "rearWheelOffset", &pvalue->rearWheelOffset);
   }

   asn1PrtToStrm_Node_XY_24b (pctxt, "positionOffset", &pvalue->positionOffset);

   if (pvalue->m.elevationOffsetPresent) {
      asn1PrtToStrm_VertOffset_B07 (pctxt, "elevationOffset", &pvalue->elevationOffset);
   }

   if (pvalue->m.crumbDataPresent) {
      asn1PrtToStrm_TrailerHistoryPointList (pctxt, "crumbData", &pvalue->crumbData);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_TrailerUnitDescriptionList (OSCTXT *pctxt, 
   const char* name, const TrailerUnitDescriptionList* pvalue)
{
   TrailerUnitDescription* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((TrailerUnitDescription*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_TrailerUnitDescription (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_TrailerData (OSCTXT *pctxt, 
   const char* name, const TrailerData* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_SSPindex (pctxt, "sspRights", &pvalue->sspRights);

   asn1PrtToStrm_PivotPointDescription (pctxt, "connection", &pvalue->connection);

   asn1PrtToStrm_TrailerUnitDescriptionList (pctxt, "units", &pvalue->units);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SpecialVehicleExtensions (OSCTXT *pctxt, 
   const char* name, const SpecialVehicleExtensions* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.vehicleAlertsPresent) {
      asn1PrtToStrm_EmergencyDetails (pctxt, "vehicleAlerts", &pvalue->vehicleAlerts);
   }

   if (pvalue->m.descriptionPresent) {
      asn1PrtToStrm_EventDescription (pctxt, "description", &pvalue->description);
   }

   if (pvalue->m.trailersPresent) {
      asn1PrtToStrm_TrailerData (pctxt, "trailers", &pvalue->trailers);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SpeedProfileMeasurementList (OSCTXT *pctxt, 
   const char* name, const SpeedProfileMeasurementList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_SpeedProfileMeasurement (pctxt, namebuf, &pvalue->elem[xx1]);
   }
   return 0;
}

int asn1PrtToStrm_SpeedProfile (OSCTXT *pctxt, 
   const char* name, const SpeedProfile* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_SpeedProfileMeasurementList (pctxt, "speedReports", &pvalue->speedReports);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleData (OSCTXT *pctxt, 
   const char* name, const VehicleData* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.heightPresent) {
      asn1PrtToStrm_VehicleHeight (pctxt, "height", &pvalue->height);
   }

   if (pvalue->m.bumpersPresent) {
      asn1PrtToStrm_BumperHeights (pctxt, "bumpers", &pvalue->bumpers);
   }

   if (pvalue->m.massPresent) {
      asn1PrtToStrm_VehicleMass (pctxt, "mass", &pvalue->mass);
   }

   if (pvalue->m.trailerWeightPresent) {
      asn1PrtToStrm_TrailerWeight (pctxt, "trailerWeight", &pvalue->trailerWeight);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_WeatherReport (OSCTXT *pctxt, 
   const char* name, const WeatherReport* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_EssPrecipYesNo (pctxt, "isRaining", &pvalue->isRaining);

   if (pvalue->m.rainRatePresent) {
      asn1PrtToStrm_EssPrecipRate (pctxt, "rainRate", &pvalue->rainRate);
   }

   if (pvalue->m.precipSituationPresent) {
      asn1PrtToStrm_EssPrecipSituation (pctxt, "precipSituation", &pvalue->precipSituation);
   }

   if (pvalue->m.solarRadiationPresent) {
      asn1PrtToStrm_EssSolarRadiation (pctxt, "solarRadiation", &pvalue->solarRadiation);
   }

   if (pvalue->m.frictionPresent) {
      asn1PrtToStrm_EssMobileFriction (pctxt, "friction", &pvalue->friction);
   }

   if (pvalue->m.roadFrictionPresent) {
      asn1PrtToStrm_CoefficientOfFriction (pctxt, "roadFriction", &pvalue->roadFriction);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_WeatherProbe (OSCTXT *pctxt, 
   const char* name, const WeatherProbe* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.airTempPresent) {
      asn1PrtToStrm_AmbientAirTemperature (pctxt, "airTemp", &pvalue->airTemp);
   }

   if (pvalue->m.airPressurePresent) {
      asn1PrtToStrm_AmbientAirPressure (pctxt, "airPressure", &pvalue->airPressure);
   }

   if (pvalue->m.rainRatesPresent) {
      asn1PrtToStrm_WiperSet (pctxt, "rainRates", &pvalue->rainRates);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SupplementalVehicleExtensions_regional (OSCTXT *pctxt, 
   const char* name, const SupplementalVehicleExtensions_regional* pvalue)
{
   RegionalExtension* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((RegionalExtension*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_RegionalExtension (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_SupplementalVehicleExtensions (OSCTXT *pctxt, 
   const char* name, const SupplementalVehicleExtensions* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.classificationPresent) {
      asn1PrtToStrm_BasicVehicleClass (pctxt, "classification", &pvalue->classification);
   }

   if (pvalue->m.classDetailsPresent) {
      asn1PrtToStrm_VehicleClassification (pctxt, "classDetails", &pvalue->classDetails);
   }

   if (pvalue->m.vehicleDataPresent) {
      asn1PrtToStrm_VehicleData (pctxt, "vehicleData", &pvalue->vehicleData);
   }

   if (pvalue->m.weatherReportPresent) {
      asn1PrtToStrm_WeatherReport (pctxt, "weatherReport", &pvalue->weatherReport);
   }

   if (pvalue->m.weatherProbePresent) {
      asn1PrtToStrm_WeatherProbe (pctxt, "weatherProbe", &pvalue->weatherProbe);
   }

   if (pvalue->m.obstaclePresent) {
      asn1PrtToStrm_ObstacleDetection (pctxt, "obstacle", &pvalue->obstacle);
   }

   if (pvalue->m.statusPresent) {
      asn1PrtToStrm_DisabledVehicle (pctxt, "status", &pvalue->status);
   }

   if (pvalue->m.speedProfilePresent) {
      asn1PrtToStrm_SpeedProfile (pctxt, "speedProfile", &pvalue->speedProfile);
   }

   if (pvalue->m.theRTCMPresent) {
      asn1PrtToStrm_RTCMPackage (pctxt, "theRTCM", &pvalue->theRTCM);
   }

   if (pvalue->m.regionalPresent) {
      asn1PrtToStrm_SupplementalVehicleExtensions_regional (pctxt, "regional", &pvalue->regional);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VerticalOffset (OSCTXT *pctxt, 
   const char* name, const VerticalOffset* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* offset1 */
      case 1:
      {
         asn1PrtToStrm_VertOffset_B07 (pctxt, "offset1", &pvalue->u.offset1);
         break;
      }
      /* offset2 */
      case 2:
      {
         asn1PrtToStrm_VertOffset_B08 (pctxt, "offset2", &pvalue->u.offset2);
         break;
      }
      /* offset3 */
      case 3:
      {
         asn1PrtToStrm_VertOffset_B09 (pctxt, "offset3", &pvalue->u.offset3);
         break;
      }
      /* offset4 */
      case 4:
      {
         asn1PrtToStrm_VertOffset_B10 (pctxt, "offset4", &pvalue->u.offset4);
         break;
      }
      /* offset5 */
      case 5:
      {
         asn1PrtToStrm_VertOffset_B11 (pctxt, "offset5", &pvalue->u.offset5);
         break;
      }
      /* offset6 */
      case 6:
      {
         asn1PrtToStrm_VertOffset_B12 (pctxt, "offset6", &pvalue->u.offset6);
         break;
      }
      /* elevation */
      case 7:
      {
         asn1PrtToStrm_Elevation (pctxt, "elevation", &pvalue->u.elevation);
         break;
      }
      /* regional */
      case 8:
      {
         asn1PrtToStrm_RegionalExtension (pctxt, "regional", pvalue->u.regional);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

