/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.2.4, Date: 06-Mar-2019.
 */
#include "AddGrpC.h"
#include "rtxsrc/rtxCommon.h"

/* AltitudeConfidence */

static const OSEnumItem AltitudeConfidence_ENUMTAB[] = {
   { OSUTF8("alt-000-01"), 0, 10, 0 },
   { OSUTF8("alt-000-02"), 1, 10, 1 },
   { OSUTF8("alt-000-05"), 2, 10, 2 },
   { OSUTF8("alt-000-10"), 3, 10, 3 },
   { OSUTF8("alt-000-20"), 4, 10, 4 },
   { OSUTF8("alt-000-50"), 5, 10, 5 },
   { OSUTF8("alt-001-00"), 6, 10, 6 },
   { OSUTF8("alt-002-00"), 7, 10, 7 },
   { OSUTF8("alt-005-00"), 8, 10, 8 },
   { OSUTF8("alt-010-00"), 9, 10, 9 },
   { OSUTF8("alt-020-00"), 10, 10, 10 },
   { OSUTF8("alt-050-00"), 11, 10, 11 },
   { OSUTF8("alt-100-00"), 12, 10, 12 },
   { OSUTF8("alt-200-00"), 13, 10, 13 },
   { OSUTF8("outOfRange"), 14, 10, 14 },
   { OSUTF8("unavailable"), 15, 11, 15 }
} ;
#define AltitudeConfidence_ENUMTABSIZE 16

const OSUTF8CHAR* AltitudeConfidence_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AltitudeConfidence_ENUMTABSIZE) {
      return AltitudeConfidence_ENUMTAB
         [AltitudeConfidence_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AltitudeConfidence_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AltitudeConfidence* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return AltitudeConfidence_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int AltitudeConfidence_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, AltitudeConfidence* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, AltitudeConfidence_ENUMTAB, 
      AltitudeConfidence_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AltitudeConfidence)AltitudeConfidence_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* AltitudeValue */

/* EmissionType */

static const OSEnumItem EmissionType_ENUMTAB[] = {
   { OSUTF8("typeA"), 0, 5, 0 },
   { OSUTF8("typeB"), 1, 5, 1 },
   { OSUTF8("typeC"), 2, 5, 2 },
   { OSUTF8("typeD"), 3, 5, 3 },
   { OSUTF8("typeE"), 4, 5, 4 }
} ;
#define EmissionType_ENUMTABSIZE 5

const OSUTF8CHAR* EmissionType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < EmissionType_ENUMTABSIZE) {
      return EmissionType_ENUMTAB[EmissionType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int EmissionType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, EmissionType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return EmissionType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int EmissionType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, EmissionType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, EmissionType_ENUMTAB, 
      EmissionType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (EmissionType)EmissionType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* Altitude */

/* PrioritizationResponse */

int asn1Init_PrioritizationResponse (PrioritizationResponse* pvalue)
{
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_PrioritizationResponse (OSCTXT *pctxt, 
   PrioritizationResponse* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* PrioritizationResponseList */

int asn1Init_PrioritizationResponseList (PrioritizationResponseList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_PrioritizationResponseList (OSCTXT *pctxt, 
   PrioritizationResponseList* pvalue)
{
   if (0 == pvalue) return;
   { PrioritizationResponse* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (PrioritizationResponse*)pnode->data;
      asn1Free_PrioritizationResponse (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* VehicleToLanePosition */

int asn1Init_VehicleToLanePosition (VehicleToLanePosition* pvalue)
{
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_VehicleToLanePosition (OSCTXT *pctxt, 
   VehicleToLanePosition* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* VehicleToLanePositionList */

int asn1Init_VehicleToLanePositionList (VehicleToLanePositionList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_VehicleToLanePositionList (OSCTXT *pctxt, 
   VehicleToLanePositionList* pvalue)
{
   if (0 == pvalue) return;
   { VehicleToLanePosition* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (VehicleToLanePosition*)pnode->data;
      asn1Free_VehicleToLanePosition (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* ConnectionManeuverAssist_addGrpC */

int asn1Init_ConnectionManeuverAssist_addGrpC (
   ConnectionManeuverAssist_addGrpC* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_VehicleToLanePositionList (&pvalue->vehicleToLanePositions);
   asn1Init_NodeOffsetPointXY (&pvalue->rsuDistanceFromAnchor);
   return 0;
}

void asn1Free_ConnectionManeuverAssist_addGrpC (OSCTXT *pctxt, 
   ConnectionManeuverAssist_addGrpC* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_VehicleToLanePositionList (pctxt, &pvalue->vehicleToLanePositions);
   if (pvalue->m.rsuDistanceFromAnchorPresent) {
      asn1Free_NodeOffsetPointXY (pctxt, &pvalue->rsuDistanceFromAnchor);
   }
}

/* IntersectionState_addGrpC */

int asn1Init_IntersectionState_addGrpC (IntersectionState_addGrpC* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PrioritizationResponseList (&pvalue->activePrioritizations);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_IntersectionState_addGrpC (OSCTXT *pctxt, 
   IntersectionState_addGrpC* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.activePrioritizationsPresent) {
      asn1Free_PrioritizationResponseList (pctxt, &pvalue->activePrioritizations);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* SignalHeadLocation */

int asn1Init_SignalHeadLocation (SignalHeadLocation* pvalue)
{
   asn1Init_NodeOffsetPointXY (&pvalue->node);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_SignalHeadLocation (OSCTXT *pctxt, SignalHeadLocation* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_NodeOffsetPointXY (pctxt, &pvalue->node);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* SignalHeadLocationList */

int asn1Init_SignalHeadLocationList (SignalHeadLocationList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_SignalHeadLocationList (OSCTXT *pctxt, 
   SignalHeadLocationList* pvalue)
{
   if (0 == pvalue) return;
   { SignalHeadLocation* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (SignalHeadLocation*)pnode->data;
      asn1Free_SignalHeadLocation (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* MapData_addGrpC */

int asn1Init_MapData_addGrpC (MapData_addGrpC* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SignalHeadLocationList (&pvalue->signalHeadLocations);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_MapData_addGrpC (OSCTXT *pctxt, MapData_addGrpC* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.signalHeadLocationsPresent) {
      asn1Free_SignalHeadLocationList (pctxt, &pvalue->signalHeadLocations);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* Position3D_addGrpC */

int asn1Init_Position3D_addGrpC (Position3D_addGrpC* pvalue)
{
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_Position3D_addGrpC (OSCTXT *pctxt, Position3D_addGrpC* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* RestrictionUserType_addGrpC */

int asn1Init_RestrictionUserType_addGrpC (RestrictionUserType_addGrpC* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_RestrictionUserType_addGrpC (OSCTXT *pctxt, 
   RestrictionUserType_addGrpC* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

