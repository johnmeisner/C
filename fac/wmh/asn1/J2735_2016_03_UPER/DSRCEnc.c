/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.2.4, Date: 06-Mar-2019.
 */
#include "DSRC.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1PE_PartII_Id (OSCTXT* pctxt, PartII_Id value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PartII_Id: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 63);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PartII_Id: end\n");

   return (stat);
}

EXTERN int asn1PE_Acceleration (OSCTXT* pctxt, Acceleration value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Acceleration: start\n");

   stat = pe_ConsInteger (pctxt, value, -2000, 2001);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Acceleration: end\n");

   return (stat);
}

EXTERN int asn1PE_AccelerationConfidence (OSCTXT* pctxt, AccelerationConfidence value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AccelerationConfidence: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_AccelerationConfidence: end\n");

   return (stat);
}

EXTERN int asn1PE_AdvisorySpeedType (OSCTXT* pctxt, AdvisorySpeedType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AdvisorySpeedType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_AdvisorySpeedType: end\n");

   return (stat);
}

EXTERN int asn1PE_AllowedManeuvers (OSCTXT* pctxt, AllowedManeuvers* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AllowedManeuvers: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(12), OSUINTCONST(12), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(12) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(12)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_AllowedManeuvers: end\n");

   return (stat);
}

EXTERN int asn1PE_AmbientAirPressure (OSCTXT* pctxt, AmbientAirPressure value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AmbientAirPressure: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_AmbientAirPressure: end\n");

   return (stat);
}

EXTERN int asn1PE_AmbientAirTemperature (OSCTXT* pctxt, AmbientAirTemperature value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AmbientAirTemperature: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 191);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_AmbientAirTemperature: end\n");

   return (stat);
}

EXTERN int asn1PE_Angle (OSCTXT* pctxt, Angle value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Angle: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 28800);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Angle: end\n");

   return (stat);
}

EXTERN int asn1PE_AnimalPropelledType (OSCTXT* pctxt, AnimalPropelledType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AnimalPropelledType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_AnimalPropelledType: end\n");

   return (stat);
}

EXTERN int asn1PE_AnimalType (OSCTXT* pctxt, AnimalType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AnimalType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_AnimalType: end\n");

   return (stat);
}

EXTERN int asn1PE_AntiLockBrakeStatus (OSCTXT* pctxt, AntiLockBrakeStatus value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AntiLockBrakeStatus: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_AntiLockBrakeStatus: end\n");

   return (stat);
}

EXTERN int asn1PE_ApproachID (OSCTXT* pctxt, ApproachID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ApproachID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 15);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_ApproachID: end\n");

   return (stat);
}

EXTERN int asn1PE_Attachment (OSCTXT* pctxt, Attachment value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Attachment: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Attachment: end\n");

   return (stat);
}

EXTERN int asn1PE_AttachmentRadius (OSCTXT* pctxt, AttachmentRadius value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AttachmentRadius: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 200);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_AttachmentRadius: end\n");

   return (stat);
}

EXTERN int asn1PE_AuxiliaryBrakeStatus (OSCTXT* pctxt, AuxiliaryBrakeStatus value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AuxiliaryBrakeStatus: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_AuxiliaryBrakeStatus: end\n");

   return (stat);
}

EXTERN int asn1PE_BasicVehicleClass (OSCTXT* pctxt, BasicVehicleClass value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_BasicVehicleClass: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_BasicVehicleClass: end\n");

   return (stat);
}

EXTERN int asn1PE_BasicVehicleRole (OSCTXT* pctxt, BasicVehicleRole value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_BasicVehicleRole: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(22));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_BasicVehicleRole: end\n");

   return (stat);
}

EXTERN int asn1PE_BrakeAppliedPressure (OSCTXT* pctxt, BrakeAppliedPressure value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_BrakeAppliedPressure: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_BrakeAppliedPressure: end\n");

   return (stat);
}

EXTERN int asn1PE_BrakeAppliedStatus (OSCTXT* pctxt, BrakeAppliedStatus* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_BrakeAppliedStatus: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(5) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(5)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_BrakeAppliedStatus: end\n");

   return (stat);
}

EXTERN int asn1PE_BrakeBoostApplied (OSCTXT* pctxt, BrakeBoostApplied value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_BrakeBoostApplied: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_BrakeBoostApplied: end\n");

   return (stat);
}

EXTERN int asn1PE_BumperHeight (OSCTXT* pctxt, BumperHeight value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_BumperHeight: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 127);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_BumperHeight: end\n");

   return (stat);
}

EXTERN int asn1PE_CoarseHeading (OSCTXT* pctxt, CoarseHeading value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CoarseHeading: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 240);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_CoarseHeading: end\n");

   return (stat);
}

EXTERN int asn1PE_CodeWord (OSCTXT* pctxt, CodeWord* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CodeWord: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_CodeWord: end\n");

   return (stat);
}

EXTERN int asn1PE_CoefficientOfFriction (OSCTXT* pctxt, CoefficientOfFriction value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CoefficientOfFriction: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 50);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_CoefficientOfFriction: end\n");

   return (stat);
}

EXTERN int asn1PE_Confidence (OSCTXT* pctxt, Confidence value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Confidence: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 200);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Confidence: end\n");

   return (stat);
}

EXTERN int asn1PE_Count (OSCTXT* pctxt, Count value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Count: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 32);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Count: end\n");

   return (stat);
}

EXTERN int asn1PE_DDay (OSCTXT* pctxt, DDay value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DDay: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 31);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DDay: end\n");

   return (stat);
}

EXTERN int asn1PE_DeltaAngle (OSCTXT* pctxt, DeltaAngle value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DeltaAngle: start\n");

   stat = pe_ConsInteger (pctxt, value, -150, 150);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DeltaAngle: end\n");

   return (stat);
}

EXTERN int asn1PE_DeltaTime (OSCTXT* pctxt, DeltaTime value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DeltaTime: start\n");

   stat = pe_ConsInteger (pctxt, value, -122, 121);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DeltaTime: end\n");

   return (stat);
}

EXTERN int asn1PE_DescriptiveName (OSCTXT* pctxt, DescriptiveName value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DescriptiveName: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(63), 0, 0);

   stat = pe_ConstrainedStringEx (pctxt, value, 0, 8, 7, 7);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DescriptiveName: end\n");

   return (stat);
}

EXTERN int asn1PE_DHour (OSCTXT* pctxt, DHour value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DHour: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 31);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DHour: end\n");

   return (stat);
}

EXTERN int asn1PE_DirectionOfUse (OSCTXT* pctxt, DirectionOfUse value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DirectionOfUse: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DirectionOfUse: end\n");

   return (stat);
}

EXTERN int asn1PE_DistanceUnits (OSCTXT* pctxt, DistanceUnits value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DistanceUnits: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DistanceUnits: end\n");

   return (stat);
}

EXTERN int asn1PE_DMinute (OSCTXT* pctxt, DMinute value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DMinute: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 60);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DMinute: end\n");

   return (stat);
}

EXTERN int asn1PE_DMonth (OSCTXT* pctxt, DMonth value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DMonth: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 12);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DMonth: end\n");

   return (stat);
}

EXTERN int asn1PE_DOffset (OSCTXT* pctxt, DOffset value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DOffset: start\n");

   stat = pe_ConsInteger (pctxt, value, -840, 840);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DOffset: end\n");

   return (stat);
}

EXTERN int asn1PE_DrivenLineOffsetLg (OSCTXT* pctxt, DrivenLineOffsetLg value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DrivenLineOffsetLg: start\n");

   stat = pe_ConsInteger (pctxt, value, -32767, 32767);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DrivenLineOffsetLg: end\n");

   return (stat);
}

EXTERN int asn1PE_DrivenLineOffsetSm (OSCTXT* pctxt, DrivenLineOffsetSm value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DrivenLineOffsetSm: start\n");

   stat = pe_ConsInteger (pctxt, value, -2047, 2047);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DrivenLineOffsetSm: end\n");

   return (stat);
}

EXTERN int asn1PE_DrivingWheelAngle (OSCTXT* pctxt, DrivingWheelAngle value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DrivingWheelAngle: start\n");

   stat = pe_ConsInteger (pctxt, value, -128, 127);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DrivingWheelAngle: end\n");

   return (stat);
}

EXTERN int asn1PE_DSecond (OSCTXT* pctxt, DSecond value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DSecond: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DSecond: end\n");

   return (stat);
}

EXTERN int asn1PE_DSRCmsgID (OSCTXT* pctxt, DSRCmsgID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DSRCmsgID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 32767);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DSRCmsgID: end\n");

   return (stat);
}

EXTERN int asn1PE_Duration (OSCTXT* pctxt, Duration value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Duration: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 3600);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Duration: end\n");

   return (stat);
}

EXTERN int asn1PE_DYear (OSCTXT* pctxt, DYear value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DYear: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 4095);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DYear: end\n");

   return (stat);
}

EXTERN int asn1PE_ElevationConfidence (OSCTXT* pctxt, ElevationConfidence value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ElevationConfidence: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_ElevationConfidence: end\n");

   return (stat);
}

EXTERN int asn1PE_Elevation (OSCTXT* pctxt, Elevation value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Elevation: start\n");

   stat = pe_ConsInteger (pctxt, value, -4096, 61439);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Elevation: end\n");

   return (stat);
}

EXTERN int asn1PE_Extent (OSCTXT* pctxt, Extent value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Extent: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Extent: end\n");

   return (stat);
}

EXTERN int asn1PE_ExteriorLights (OSCTXT* pctxt, ExteriorLights* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ExteriorLights: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(9), OSUINTCONST(9), OSUINTCONST(0), OSUINT32_MAX);

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(9)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(9) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(9)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_ExteriorLights: end\n");

   return (stat);
}

EXTERN int asn1PE_FuelType (OSCTXT* pctxt, FuelType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_FuelType: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 15);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_FuelType: end\n");

   return (stat);
}

EXTERN int asn1PE_FurtherInfoID (OSCTXT* pctxt, FurtherInfoID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_FurtherInfoID: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_FurtherInfoID: end\n");

   return (stat);
}

EXTERN int asn1PE_GNSSstatus (OSCTXT* pctxt, GNSSstatus* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GNSSstatus: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(8) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(8)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_GNSSstatus: end\n");

   return (stat);
}

EXTERN int asn1PE_GrossDistance (OSCTXT* pctxt, GrossDistance value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GrossDistance: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 1023);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_GrossDistance: end\n");

   return (stat);
}

EXTERN int asn1PE_GrossSpeed (OSCTXT* pctxt, GrossSpeed value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GrossSpeed: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 31);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_GrossSpeed: end\n");

   return (stat);
}

EXTERN int asn1PE_HeadingConfidence (OSCTXT* pctxt, HeadingConfidence value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HeadingConfidence: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_HeadingConfidence: end\n");

   return (stat);
}

EXTERN int asn1PE_Heading (OSCTXT* pctxt, Heading value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Heading: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 28800);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Heading: end\n");

   return (stat);
}

EXTERN int asn1PE_HeadingSlice (OSCTXT* pctxt, HeadingSlice* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HeadingSlice: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(16) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(16)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_HeadingSlice: end\n");

   return (stat);
}

EXTERN int asn1PE_IntersectionID (OSCTXT* pctxt, IntersectionID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionID: end\n");

   return (stat);
}

EXTERN int asn1PE_IntersectionStatusObject (OSCTXT* pctxt, IntersectionStatusObject* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionStatusObject: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(16) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(16)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionStatusObject: end\n");

   return (stat);
}

EXTERN int asn1PE_IsDolly (OSCTXT* pctxt, IsDolly value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_IsDolly: start\n");

   PU_NEWFIELD (pctxt, "boolean");

   stat = rtxEncBit (pctxt, (OSBOOL)value);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_IsDolly: end\n");

   return (stat);
}

EXTERN int asn1PE_Iso3833VehicleType (OSCTXT* pctxt, Iso3833VehicleType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Iso3833VehicleType: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 100);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Iso3833VehicleType: end\n");

   return (stat);
}

EXTERN int asn1PE_ITIStextPhrase (OSCTXT* pctxt, ITIStextPhrase value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ITIStextPhrase: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_ConstrainedStringEx (pctxt, value, 0, 8, 7, 7);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_ITIStextPhrase: end\n");

   return (stat);
}

EXTERN int asn1PE_AxleLocation (OSCTXT* pctxt, AxleLocation value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AxleLocation: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_AxleLocation: end\n");

   return (stat);
}

EXTERN int asn1PE_AxleWeight (OSCTXT* pctxt, AxleWeight value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AxleWeight: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 64255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_AxleWeight: end\n");

   return (stat);
}

EXTERN int asn1PE_CargoWeight (OSCTXT* pctxt, CargoWeight value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CargoWeight: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 64255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_CargoWeight: end\n");

   return (stat);
}

EXTERN int asn1PE_DriveAxleLiftAirPressure (OSCTXT* pctxt, DriveAxleLiftAirPressure value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DriveAxleLiftAirPressure: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 1000);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DriveAxleLiftAirPressure: end\n");

   return (stat);
}

EXTERN int asn1PE_DriveAxleLocation (OSCTXT* pctxt, DriveAxleLocation value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DriveAxleLocation: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DriveAxleLocation: end\n");

   return (stat);
}

EXTERN int asn1PE_DriveAxleLubePressure (OSCTXT* pctxt, DriveAxleLubePressure value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DriveAxleLubePressure: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 250);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DriveAxleLubePressure: end\n");

   return (stat);
}

EXTERN int asn1PE_DriveAxleTemperature (OSCTXT* pctxt, DriveAxleTemperature value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DriveAxleTemperature: start\n");

   stat = pe_ConsInteger (pctxt, value, -40, 210);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DriveAxleTemperature: end\n");

   return (stat);
}

EXTERN int asn1PE_SteeringAxleLubePressure (OSCTXT* pctxt, SteeringAxleLubePressure value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SteeringAxleLubePressure: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 250);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SteeringAxleLubePressure: end\n");

   return (stat);
}

EXTERN int asn1PE_SteeringAxleTemperature (OSCTXT* pctxt, SteeringAxleTemperature value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SteeringAxleTemperature: start\n");

   stat = pe_ConsInteger (pctxt, value, -40, 210);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SteeringAxleTemperature: end\n");

   return (stat);
}

EXTERN int asn1PE_TireLeakageRate (OSCTXT* pctxt, TireLeakageRate value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TireLeakageRate: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 64255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TireLeakageRate: end\n");

   return (stat);
}

EXTERN int asn1PE_TireLocation (OSCTXT* pctxt, TireLocation value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TireLocation: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TireLocation: end\n");

   return (stat);
}

EXTERN int asn1PE_TirePressureThresholdDetection (OSCTXT* pctxt, TirePressureThresholdDetection value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TirePressureThresholdDetection: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TirePressureThresholdDetection: end\n");

   return (stat);
}

EXTERN int asn1PE_TirePressure (OSCTXT* pctxt, TirePressure value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TirePressure: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 250);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TirePressure: end\n");

   return (stat);
}

EXTERN int asn1PE_TireTemp (OSCTXT* pctxt, TireTemp value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TireTemp: start\n");

   stat = pe_ConsInteger (pctxt, value, -8736, 55519);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TireTemp: end\n");

   return (stat);
}

EXTERN int asn1PE_TrailerWeight (OSCTXT* pctxt, TrailerWeight value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TrailerWeight: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 64255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TrailerWeight: end\n");

   return (stat);
}

EXTERN int asn1PE_WheelEndElectFault (OSCTXT* pctxt, WheelEndElectFault value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_WheelEndElectFault: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_WheelEndElectFault: end\n");

   return (stat);
}

EXTERN int asn1PE_WheelSensorStatus (OSCTXT* pctxt, WheelSensorStatus value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_WheelSensorStatus: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_WheelSensorStatus: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_Barrier (OSCTXT* pctxt, LaneAttributes_Barrier* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_Barrier: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(16) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(16)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_Barrier: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_Bike (OSCTXT* pctxt, LaneAttributes_Bike* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_Bike: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(16) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(16)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_Bike: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_Crosswalk (OSCTXT* pctxt, LaneAttributes_Crosswalk* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_Crosswalk: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(16) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(16)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_Crosswalk: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_Parking (OSCTXT* pctxt, LaneAttributes_Parking* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_Parking: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(16) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(16)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_Parking: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_Sidewalk (OSCTXT* pctxt, LaneAttributes_Sidewalk* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_Sidewalk: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(16) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(16)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_Sidewalk: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_Striping (OSCTXT* pctxt, LaneAttributes_Striping* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_Striping: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(16) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(16)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_Striping: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_TrackedVehicle (OSCTXT* pctxt, LaneAttributes_TrackedVehicle* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_TrackedVehicle: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(16) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(16)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_TrackedVehicle: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneAttributes_Vehicle (OSCTXT* pctxt, LaneAttributes_Vehicle* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_Vehicle: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), OSUINTCONST(0), OSUINT32_MAX);

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(8)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(8) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(8)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes_Vehicle: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneConnectionID (OSCTXT* pctxt, LaneConnectionID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneConnectionID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneConnectionID: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneDirection (OSCTXT* pctxt, LaneDirection* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneDirection: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(2) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(2)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneDirection: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneID (OSCTXT* pctxt, LaneID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneID: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneSharing (OSCTXT* pctxt, LaneSharing* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneSharing: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(10), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(10) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(10)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneSharing: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneWidth (OSCTXT* pctxt, LaneWidth value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneWidth: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 32767);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneWidth: end\n");

   return (stat);
}

EXTERN int asn1PE_Latitude (OSCTXT* pctxt, Latitude value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Latitude: start\n");

   stat = pe_ConsInteger (pctxt, value, -900000000, 900000001);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Latitude: end\n");

   return (stat);
}

EXTERN int asn1PE_LayerID (OSCTXT* pctxt, LayerID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LayerID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 100);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LayerID: end\n");

   return (stat);
}

EXTERN int asn1PE_LayerType (OSCTXT* pctxt, LayerType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LayerType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LayerType: end\n");

   return (stat);
}

EXTERN int asn1PE_LightbarInUse (OSCTXT* pctxt, LightbarInUse value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LightbarInUse: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_LightbarInUse: end\n");

   return (stat);
}

EXTERN int asn1PE_Longitude (OSCTXT* pctxt, Longitude value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Longitude: start\n");

   stat = pe_ConsInteger (pctxt, value, -1799999999, 1800000001);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Longitude: end\n");

   return (stat);
}

EXTERN int asn1PE_Location_quality (OSCTXT* pctxt, Location_quality value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Location_quality: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Location_quality: end\n");

   return (stat);
}

EXTERN int asn1PE_Location_tech (OSCTXT* pctxt, Location_tech value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Location_tech: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(9));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Location_tech: end\n");

   return (stat);
}

EXTERN int asn1PE_MergeDivergeNodeAngle (OSCTXT* pctxt, MergeDivergeNodeAngle value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MergeDivergeNodeAngle: start\n");

   stat = pe_ConsInteger (pctxt, value, -180, 180);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_MergeDivergeNodeAngle: end\n");

   return (stat);
}

EXTERN int asn1PE_MessageBLOB (OSCTXT* pctxt, MessageBLOB* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MessageBLOB: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(2000), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_MessageBLOB: end\n");

   return (stat);
}

EXTERN int asn1PE_MinuteOfTheYear (OSCTXT* pctxt, MinuteOfTheYear value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MinuteOfTheYear: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 527040);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_MinuteOfTheYear: end\n");

   return (stat);
}

EXTERN int asn1PE_MinutesDuration (OSCTXT* pctxt, MinutesDuration value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MinutesDuration: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 32000);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_MinutesDuration: end\n");

   return (stat);
}

EXTERN int asn1PE_MotorizedPropelledType (OSCTXT* pctxt, MotorizedPropelledType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MotorizedPropelledType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(5));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_MotorizedPropelledType: end\n");

   return (stat);
}

EXTERN int asn1PE_MovementPhaseState (OSCTXT* pctxt, MovementPhaseState value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MovementPhaseState: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(9));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_MovementPhaseState: end\n");

   return (stat);
}

EXTERN int asn1PE_MsgCount (OSCTXT* pctxt, MsgCount value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MsgCount: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 127);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_MsgCount: end\n");

   return (stat);
}

EXTERN int asn1PE_MsgCRC (OSCTXT* pctxt, MsgCRC* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MsgCRC: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_MsgCRC: end\n");

   return (stat);
}

EXTERN int asn1PE_MultiVehicleResponse (OSCTXT* pctxt, MultiVehicleResponse value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MultiVehicleResponse: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_MultiVehicleResponse: end\n");

   return (stat);
}

EXTERN int asn1PE_MUTCDCode (OSCTXT* pctxt, MUTCDCode value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_MUTCDCode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_MUTCDCode: end\n");

   return (stat);
}

EXTERN int asn1PE_NMEA_MsgType (OSCTXT* pctxt, NMEA_MsgType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NMEA_MsgType: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 32767);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_NMEA_MsgType: end\n");

   return (stat);
}

EXTERN int asn1PE_NMEA_Payload (OSCTXT* pctxt, NMEA_Payload* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NMEA_Payload: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1023), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_NMEA_Payload: end\n");

   return (stat);
}

EXTERN int asn1PE_NMEA_Revision (OSCTXT* pctxt, NMEA_Revision value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NMEA_Revision: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_NMEA_Revision: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeAttributeLL (OSCTXT* pctxt, NodeAttributeLL value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeLL: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(11));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeLL: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeAttributeXY (OSCTXT* pctxt, NodeAttributeXY value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeXY: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(11));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeXY: end\n");

   return (stat);
}

EXTERN int asn1PE_NumberOfParticipantsInCluster (OSCTXT* pctxt, NumberOfParticipantsInCluster value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NumberOfParticipantsInCluster: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_NumberOfParticipantsInCluster: end\n");

   return (stat);
}

EXTERN int asn1PE_ObjectCount (OSCTXT* pctxt, ObjectCount value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ObjectCount: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 1023);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_ObjectCount: end\n");

   return (stat);
}

EXTERN int asn1PE_ObstacleDirection (OSCTXT* pctxt, ObstacleDirection value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ObstacleDirection: start\n");

   stat = asn1PE_Angle (pctxt, value);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_ObstacleDirection: end\n");

   return (stat);
}

EXTERN int asn1PE_ObstacleDistance (OSCTXT* pctxt, ObstacleDistance value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ObstacleDistance: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 32767);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_ObstacleDistance: end\n");

   return (stat);
}

EXTERN int asn1PE_Offset_B09 (OSCTXT* pctxt, Offset_B09 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Offset_B09: start\n");

   stat = pe_ConsInteger (pctxt, value, -256, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Offset_B09: end\n");

   return (stat);
}

EXTERN int asn1PE_Offset_B10 (OSCTXT* pctxt, Offset_B10 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Offset_B10: start\n");

   stat = pe_ConsInteger (pctxt, value, -512, 511);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Offset_B10: end\n");

   return (stat);
}

EXTERN int asn1PE_Offset_B11 (OSCTXT* pctxt, Offset_B11 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Offset_B11: start\n");

   stat = pe_ConsInteger (pctxt, value, -1024, 1023);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Offset_B11: end\n");

   return (stat);
}

EXTERN int asn1PE_Offset_B12 (OSCTXT* pctxt, Offset_B12 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Offset_B12: start\n");

   stat = pe_ConsInteger (pctxt, value, -2048, 2047);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Offset_B12: end\n");

   return (stat);
}

EXTERN int asn1PE_Offset_B13 (OSCTXT* pctxt, Offset_B13 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Offset_B13: start\n");

   stat = pe_ConsInteger (pctxt, value, -4096, 4095);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Offset_B13: end\n");

   return (stat);
}

EXTERN int asn1PE_Offset_B14 (OSCTXT* pctxt, Offset_B14 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Offset_B14: start\n");

   stat = pe_ConsInteger (pctxt, value, -8192, 8191);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Offset_B14: end\n");

   return (stat);
}

EXTERN int asn1PE_Offset_B16 (OSCTXT* pctxt, Offset_B16 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Offset_B16: start\n");

   stat = pe_ConsInteger (pctxt, value, -32768, 32767);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Offset_B16: end\n");

   return (stat);
}

EXTERN int asn1PE_OffsetLL_B12 (OSCTXT* pctxt, OffsetLL_B12 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetLL_B12: start\n");

   stat = pe_ConsInteger (pctxt, value, -2048, 2047);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetLL_B12: end\n");

   return (stat);
}

EXTERN int asn1PE_OffsetLL_B14 (OSCTXT* pctxt, OffsetLL_B14 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetLL_B14: start\n");

   stat = pe_ConsInteger (pctxt, value, -8192, 8191);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetLL_B14: end\n");

   return (stat);
}

EXTERN int asn1PE_OffsetLL_B16 (OSCTXT* pctxt, OffsetLL_B16 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetLL_B16: start\n");

   stat = pe_ConsInteger (pctxt, value, -32768, 32767);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetLL_B16: end\n");

   return (stat);
}

EXTERN int asn1PE_OffsetLL_B18 (OSCTXT* pctxt, OffsetLL_B18 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetLL_B18: start\n");

   stat = pe_ConsInteger (pctxt, value, -131072, 131071);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetLL_B18: end\n");

   return (stat);
}

EXTERN int asn1PE_OffsetLL_B22 (OSCTXT* pctxt, OffsetLL_B22 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetLL_B22: start\n");

   stat = pe_ConsInteger (pctxt, value, -2097152, 2097151);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetLL_B22: end\n");

   return (stat);
}

EXTERN int asn1PE_OffsetLL_B24 (OSCTXT* pctxt, OffsetLL_B24 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetLL_B24: start\n");

   stat = pe_ConsInteger (pctxt, value, -8388608, 8388607);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetLL_B24: end\n");

   return (stat);
}

EXTERN int asn1PE_PayloadData (OSCTXT* pctxt, PayloadData* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PayloadData: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2048), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PayloadData: end\n");

   return (stat);
}

EXTERN int asn1PE_PedestrianBicycleDetect (OSCTXT* pctxt, PedestrianBicycleDetect value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PedestrianBicycleDetect: start\n");

   PU_NEWFIELD (pctxt, "boolean");

   stat = rtxEncBit (pctxt, (OSBOOL)value);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PedestrianBicycleDetect: end\n");

   return (stat);
}

EXTERN int asn1PE_HumanPropelledType (OSCTXT* pctxt, HumanPropelledType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HumanPropelledType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(5));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_HumanPropelledType: end\n");

   return (stat);
}

EXTERN int asn1PE_PersonalAssistive (OSCTXT* pctxt, PersonalAssistive* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalAssistive: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), OSUINTCONST(0), OSUINT32_MAX);

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(6)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(6) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(6)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalAssistive: end\n");

   return (stat);
}

EXTERN int asn1PE_PersonalClusterRadius (OSCTXT* pctxt, PersonalClusterRadius value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalClusterRadius: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 100);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalClusterRadius: end\n");

   return (stat);
}

EXTERN int asn1PE_PersonalCrossingInProgress (OSCTXT* pctxt, PersonalCrossingInProgress value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalCrossingInProgress: start\n");

   PU_NEWFIELD (pctxt, "boolean");

   stat = rtxEncBit (pctxt, (OSBOOL)value);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalCrossingInProgress: end\n");

   return (stat);
}

EXTERN int asn1PE_PersonalCrossingRequest (OSCTXT* pctxt, PersonalCrossingRequest value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalCrossingRequest: start\n");

   PU_NEWFIELD (pctxt, "boolean");

   stat = rtxEncBit (pctxt, (OSBOOL)value);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalCrossingRequest: end\n");

   return (stat);
}

EXTERN int asn1PE_PersonalDeviceUsageState (OSCTXT* pctxt, PersonalDeviceUsageState* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalDeviceUsageState: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(9), OSUINTCONST(9), OSUINTCONST(0), OSUINT32_MAX);

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(9)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(9) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(9)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalDeviceUsageState: end\n");

   return (stat);
}

EXTERN int asn1PE_PersonalDeviceUserType (OSCTXT* pctxt, PersonalDeviceUserType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalDeviceUserType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(4));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalDeviceUserType: end\n");

   return (stat);
}

EXTERN int asn1PE_PivotingAllowed (OSCTXT* pctxt, PivotingAllowed value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PivotingAllowed: start\n");

   PU_NEWFIELD (pctxt, "boolean");

   stat = rtxEncBit (pctxt, (OSBOOL)value);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PivotingAllowed: end\n");

   return (stat);
}

EXTERN int asn1PE_PositionConfidence (OSCTXT* pctxt, PositionConfidence value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PositionConfidence: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PositionConfidence: end\n");

   return (stat);
}

EXTERN int asn1PE_PrioritizationResponseStatus (OSCTXT* pctxt, PrioritizationResponseStatus value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PrioritizationResponseStatus: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PrioritizationResponseStatus: end\n");

   return (stat);
}

EXTERN int asn1PE_Priority (OSCTXT* pctxt, Priority* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Priority: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Priority: end\n");

   return (stat);
}

EXTERN int asn1PE_PriorityRequestType (OSCTXT* pctxt, PriorityRequestType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityRequestType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PriorityRequestType: end\n");

   return (stat);
}

EXTERN int asn1PE_PrivilegedEventFlags (OSCTXT* pctxt, PrivilegedEventFlags* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PrivilegedEventFlags: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(16) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(16)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PrivilegedEventFlags: end\n");

   return (stat);
}

EXTERN int asn1PE_ProbeSegmentNumber (OSCTXT* pctxt, ProbeSegmentNumber value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeSegmentNumber: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 32767);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeSegmentNumber: end\n");

   return (stat);
}

EXTERN int asn1PE_PublicSafetyAndRoadWorkerActivity (OSCTXT* pctxt, PublicSafetyAndRoadWorkerActivity* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PublicSafetyAndRoadWorkerActivity: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), OSUINTCONST(0), OSUINT32_MAX);

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(6)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(6) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(6)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PublicSafetyAndRoadWorkerActivity: end\n");

   return (stat);
}

EXTERN int asn1PE_PublicSafetyDirectingTrafficSubType (OSCTXT* pctxt, PublicSafetyDirectingTrafficSubType* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PublicSafetyDirectingTrafficSubType: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(7), OSUINTCONST(7), OSUINTCONST(0), OSUINT32_MAX);

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(7)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(7) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(7)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PublicSafetyDirectingTrafficSubType: end\n");

   return (stat);
}

EXTERN int asn1PE_PublicSafetyEventResponderWorkerType (OSCTXT* pctxt, PublicSafetyEventResponderWorkerType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PublicSafetyEventResponderWorkerType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PublicSafetyEventResponderWorkerType: end\n");

   return (stat);
}

EXTERN int asn1PE_RadiusOfCurvature (OSCTXT* pctxt, RadiusOfCurvature value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RadiusOfCurvature: start\n");

   stat = pe_ConsInteger (pctxt, value, -32767, 32767);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RadiusOfCurvature: end\n");

   return (stat);
}

EXTERN int asn1PE_Radius_B12 (OSCTXT* pctxt, Radius_B12 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Radius_B12: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 4095);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Radius_B12: end\n");

   return (stat);
}

EXTERN int asn1PE_RainSensor (OSCTXT* pctxt, RainSensor value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RainSensor: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RainSensor: end\n");

   return (stat);
}

EXTERN int asn1PE_RegionId (OSCTXT* pctxt, RegionId value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RegionId: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RegionId: end\n");

   return (stat);
}

EXTERN int asn1PE_RequestedItem (OSCTXT* pctxt, RequestedItem value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestedItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(16));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestedItem: end\n");

   return (stat);
}

EXTERN int asn1PE_RequestID (OSCTXT* pctxt, RequestID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestID: end\n");

   return (stat);
}

EXTERN int asn1PE_RequestImportanceLevel (OSCTXT* pctxt, RequestImportanceLevel value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestImportanceLevel: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestImportanceLevel: end\n");

   return (stat);
}

EXTERN int asn1PE_RequestSubRole (OSCTXT* pctxt, RequestSubRole value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestSubRole: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestSubRole: end\n");

   return (stat);
}

EXTERN int asn1PE_ResponseType (OSCTXT* pctxt, ResponseType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ResponseType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_ResponseType: end\n");

   return (stat);
}

EXTERN int asn1PE_RestrictionAppliesTo (OSCTXT* pctxt, RestrictionAppliesTo value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RestrictionAppliesTo: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(13));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RestrictionAppliesTo: end\n");

   return (stat);
}

EXTERN int asn1PE_RestrictionClassID (OSCTXT* pctxt, RestrictionClassID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RestrictionClassID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RestrictionClassID: end\n");

   return (stat);
}

EXTERN int asn1PE_RoadRegulatorID (OSCTXT* pctxt, RoadRegulatorID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadRegulatorID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadRegulatorID: end\n");

   return (stat);
}

EXTERN int asn1PE_RoadSegmentID (OSCTXT* pctxt, RoadSegmentID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSegmentID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSegmentID: end\n");

   return (stat);
}

EXTERN int asn1PE_RoadwayCrownAngle (OSCTXT* pctxt, RoadwayCrownAngle value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadwayCrownAngle: start\n");

   stat = pe_ConsInteger (pctxt, value, -128, 127);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadwayCrownAngle: end\n");

   return (stat);
}

EXTERN int asn1PE_RTCM_Revision (OSCTXT* pctxt, RTCM_Revision value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RTCM_Revision: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RTCM_Revision: end\n");

   return (stat);
}

EXTERN int asn1PE_RTCMmessage (OSCTXT* pctxt, RTCMmessage* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RTCMmessage: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1023), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RTCMmessage: end\n");

   return (stat);
}

EXTERN int asn1PE_Scale_B12 (OSCTXT* pctxt, Scale_B12 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Scale_B12: start\n");

   stat = pe_ConsInteger (pctxt, value, -2048, 2047);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Scale_B12: end\n");

   return (stat);
}

EXTERN int asn1PE_SecondOfTime (OSCTXT* pctxt, SecondOfTime value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SecondOfTime: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 61);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SecondOfTime: end\n");

   return (stat);
}

EXTERN int asn1PE_SegmentAttributeLL (OSCTXT* pctxt, SegmentAttributeLL value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SegmentAttributeLL: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(37));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SegmentAttributeLL: end\n");

   return (stat);
}

EXTERN int asn1PE_SegmentAttributeXY (OSCTXT* pctxt, SegmentAttributeXY value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SegmentAttributeXY: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(37));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SegmentAttributeXY: end\n");

   return (stat);
}

EXTERN int asn1PE_SemiMajorAxisAccuracy (OSCTXT* pctxt, SemiMajorAxisAccuracy value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SemiMajorAxisAccuracy: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SemiMajorAxisAccuracy: end\n");

   return (stat);
}

EXTERN int asn1PE_SemiMajorAxisOrientation (OSCTXT* pctxt, SemiMajorAxisOrientation value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SemiMajorAxisOrientation: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SemiMajorAxisOrientation: end\n");

   return (stat);
}

EXTERN int asn1PE_SemiMinorAxisAccuracy (OSCTXT* pctxt, SemiMinorAxisAccuracy value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SemiMinorAxisAccuracy: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SemiMinorAxisAccuracy: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalGroupID (OSCTXT* pctxt, SignalGroupID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalGroupID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalGroupID: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalReqScheme (OSCTXT* pctxt, SignalReqScheme* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalReqScheme: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalReqScheme: end\n");

   return (stat);
}

EXTERN int asn1PE_SignPrority (OSCTXT* pctxt, SignPrority value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignPrority: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 7);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignPrority: end\n");

   return (stat);
}

EXTERN int asn1PE_SirenInUse (OSCTXT* pctxt, SirenInUse value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SirenInUse: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SirenInUse: end\n");

   return (stat);
}

EXTERN int asn1PE_SpeedAdvice (OSCTXT* pctxt, SpeedAdvice value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedAdvice: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 500);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedAdvice: end\n");

   return (stat);
}

EXTERN int asn1PE_SpeedConfidence (OSCTXT* pctxt, SpeedConfidence value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedConfidence: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedConfidence: end\n");

   return (stat);
}

EXTERN int asn1PE_SpeedLimitType (OSCTXT* pctxt, SpeedLimitType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedLimitType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(12));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedLimitType: end\n");

   return (stat);
}

EXTERN int asn1PE_SpeedProfileMeasurement (OSCTXT* pctxt, SpeedProfileMeasurement value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedProfileMeasurement: start\n");

   stat = asn1PE_GrossSpeed (pctxt, value);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedProfileMeasurement: end\n");

   return (stat);
}

EXTERN int asn1PE_Speed (OSCTXT* pctxt, Speed value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Speed: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 8191);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Speed: end\n");

   return (stat);
}

EXTERN int asn1PE_SSPindex (OSCTXT* pctxt, SSPindex value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SSPindex: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 31);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SSPindex: end\n");

   return (stat);
}

EXTERN int asn1PE_StabilityControlStatus (OSCTXT* pctxt, StabilityControlStatus value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_StabilityControlStatus: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_StabilityControlStatus: end\n");

   return (stat);
}

EXTERN int asn1PE_StationID (OSCTXT* pctxt, StationID value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_StationID: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINT32_MAX);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_StationID: end\n");

   return (stat);
}

EXTERN int asn1PE_SteeringWheelAngleConfidence (OSCTXT* pctxt, SteeringWheelAngleConfidence value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SteeringWheelAngleConfidence: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SteeringWheelAngleConfidence: end\n");

   return (stat);
}

EXTERN int asn1PE_SteeringWheelAngleRateOfChange (OSCTXT* pctxt, SteeringWheelAngleRateOfChange value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SteeringWheelAngleRateOfChange: start\n");

   stat = pe_ConsInteger (pctxt, value, -127, 127);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SteeringWheelAngleRateOfChange: end\n");

   return (stat);
}

EXTERN int asn1PE_SteeringWheelAngle (OSCTXT* pctxt, SteeringWheelAngle value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SteeringWheelAngle: start\n");

   stat = pe_ConsInteger (pctxt, value, -126, 127);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SteeringWheelAngle: end\n");

   return (stat);
}

EXTERN int asn1PE_SunSensor (OSCTXT* pctxt, SunSensor value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SunSensor: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 1000);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SunSensor: end\n");

   return (stat);
}

EXTERN int asn1PE_TemporaryID (OSCTXT* pctxt, TemporaryID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TemporaryID: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TemporaryID: end\n");

   return (stat);
}

EXTERN int asn1PE_TermDistance (OSCTXT* pctxt, TermDistance value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TermDistance: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 1, 30000);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TermDistance: end\n");

   return (stat);
}

EXTERN int asn1PE_TermTime (OSCTXT* pctxt, TermTime value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TermTime: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 1, 1800);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TermTime: end\n");

   return (stat);
}

EXTERN int asn1PE_ThrottleConfidence (OSCTXT* pctxt, ThrottleConfidence value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ThrottleConfidence: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_ThrottleConfidence: end\n");

   return (stat);
}

EXTERN int asn1PE_ThrottlePosition (OSCTXT* pctxt, ThrottlePosition value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ThrottlePosition: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 200);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_ThrottlePosition: end\n");

   return (stat);
}

EXTERN int asn1PE_TimeConfidence (OSCTXT* pctxt, TimeConfidence value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeConfidence: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(39));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeConfidence: end\n");

   return (stat);
}

EXTERN int asn1PE_TimeIntervalConfidence (OSCTXT* pctxt, TimeIntervalConfidence value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeIntervalConfidence: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 15);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeIntervalConfidence: end\n");

   return (stat);
}

EXTERN int asn1PE_TimeMark (OSCTXT* pctxt, TimeMark value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeMark: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 36001);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeMark: end\n");

   return (stat);
}

EXTERN int asn1PE_TimeOffset (OSCTXT* pctxt, TimeOffset value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeOffset: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 1, 65535);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeOffset: end\n");

   return (stat);
}

EXTERN int asn1PE_TractionControlStatus (OSCTXT* pctxt, TractionControlStatus value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TractionControlStatus: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TractionControlStatus: end\n");

   return (stat);
}

EXTERN int asn1PE_TrailerMass (OSCTXT* pctxt, TrailerMass value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TrailerMass: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TrailerMass: end\n");

   return (stat);
}

EXTERN int asn1PE_TransitStatus (OSCTXT* pctxt, TransitStatus* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransitStatus: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(6) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(6)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransitStatus: end\n");

   return (stat);
}

EXTERN int asn1PE_TransitVehicleOccupancy (OSCTXT* pctxt, TransitVehicleOccupancy value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransitVehicleOccupancy: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransitVehicleOccupancy: end\n");

   return (stat);
}

EXTERN int asn1PE_TransitVehicleStatus (OSCTXT* pctxt, TransitVehicleStatus* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransitVehicleStatus: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(8) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(8)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransitVehicleStatus: end\n");

   return (stat);
}

EXTERN int asn1PE_TransmissionState (OSCTXT* pctxt, TransmissionState value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmissionState: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmissionState: end\n");

   return (stat);
}

EXTERN int asn1PE_TravelerInfoType (OSCTXT* pctxt, TravelerInfoType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerInfoType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerInfoType: end\n");

   return (stat);
}

EXTERN int asn1PE_UniqueMSGID (OSCTXT* pctxt, UniqueMSGID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UniqueMSGID: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(9), OSUINTCONST(9), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_UniqueMSGID: end\n");

   return (stat);
}

EXTERN int asn1PE_URL_Base (OSCTXT* pctxt, URL_Base value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_URL_Base: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(45), 0, 0);

   stat = pe_ConstrainedStringEx (pctxt, value, 0, 8, 7, 7);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_URL_Base: end\n");

   return (stat);
}

EXTERN int asn1PE_URL_Link (OSCTXT* pctxt, URL_Link value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_URL_Link: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pe_ConstrainedStringEx (pctxt, value, 0, 8, 7, 7);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_URL_Link: end\n");

   return (stat);
}

EXTERN int asn1PE_URL_Short (OSCTXT* pctxt, URL_Short value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_URL_Short: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(15), 0, 0);

   stat = pe_ConstrainedStringEx (pctxt, value, 0, 8, 7, 7);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_URL_Short: end\n");

   return (stat);
}

EXTERN int asn1PE_UserSizeAndBehaviour (OSCTXT* pctxt, UserSizeAndBehaviour* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UserSizeAndBehaviour: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), OSUINTCONST(0), OSUINT32_MAX);

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(5)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(5) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(5)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_UserSizeAndBehaviour: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleEventFlags (OSCTXT* pctxt, VehicleEventFlags* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleEventFlags: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(13), OSUINTCONST(13), OSUINTCONST(0), OSUINT32_MAX);

   if (0 != pvalue->extdata && pvalue->numbits > OSUINTCONST(13)) {
      /* Encode root + extension data */
      stat = pe_BitStringExt (pctxt, pvalue->numbits, pvalue->data, sizeof(
         pvalue->data), pvalue->extdata);
   }
   else {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(13) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(13)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 16), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleEventFlags: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleHeight (OSCTXT* pctxt, VehicleHeight value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleHeight: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 127);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleHeight: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleLength (OSCTXT* pctxt, VehicleLength value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleLength: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 4095);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleLength: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleMass (OSCTXT* pctxt, VehicleMass value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleMass: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleMass: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleStatusDeviceTypeTag (OSCTXT* pctxt, VehicleStatusDeviceTypeTag value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatusDeviceTypeTag: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(28));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatusDeviceTypeTag: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleType (OSCTXT* pctxt, VehicleType value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(15));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleType: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleWidth (OSCTXT* pctxt, VehicleWidth value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleWidth: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 1023);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleWidth: end\n");

   return (stat);
}

EXTERN int asn1PE_Velocity (OSCTXT* pctxt, Velocity value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Velocity: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 8191);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Velocity: end\n");

   return (stat);
}

EXTERN int asn1PE_VerticalAccelerationThreshold (OSCTXT* pctxt, VerticalAccelerationThreshold* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VerticalAccelerationThreshold: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), 0, 0);

   {
      OSSIZE bitidx = rtxLastBitSet (pvalue->data, pvalue->numbits);
      pvalue->numbits = (bitidx == OSNULLINDEX) ? OSUINTCONST(5) :
         (OSUINT32)(OS_MAX (bitidx+1, OSUINTCONST(5)));

      stat = pe_BitString (pctxt, OS_MIN(pvalue->numbits, 8), pvalue->data);
   }
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VerticalAccelerationThreshold: end\n");

   return (stat);
}

EXTERN int asn1PE_VerticalAcceleration (OSCTXT* pctxt, VerticalAcceleration value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VerticalAcceleration: start\n");

   stat = pe_ConsInteger (pctxt, value, -127, 127);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VerticalAcceleration: end\n");

   return (stat);
}

EXTERN int asn1PE_VertOffset_B07 (OSCTXT* pctxt, VertOffset_B07 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VertOffset_B07: start\n");

   stat = pe_ConsInteger (pctxt, value, -64, 63);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VertOffset_B07: end\n");

   return (stat);
}

EXTERN int asn1PE_VertOffset_B08 (OSCTXT* pctxt, VertOffset_B08 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VertOffset_B08: start\n");

   stat = pe_ConsInteger (pctxt, value, -128, 127);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VertOffset_B08: end\n");

   return (stat);
}

EXTERN int asn1PE_VertOffset_B09 (OSCTXT* pctxt, VertOffset_B09 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VertOffset_B09: start\n");

   stat = pe_ConsInteger (pctxt, value, -256, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VertOffset_B09: end\n");

   return (stat);
}

EXTERN int asn1PE_VertOffset_B10 (OSCTXT* pctxt, VertOffset_B10 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VertOffset_B10: start\n");

   stat = pe_ConsInteger (pctxt, value, -512, 511);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VertOffset_B10: end\n");

   return (stat);
}

EXTERN int asn1PE_VertOffset_B11 (OSCTXT* pctxt, VertOffset_B11 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VertOffset_B11: start\n");

   stat = pe_ConsInteger (pctxt, value, -1024, 1023);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VertOffset_B11: end\n");

   return (stat);
}

EXTERN int asn1PE_VertOffset_B12 (OSCTXT* pctxt, VertOffset_B12 value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VertOffset_B12: start\n");

   stat = pe_ConsInteger (pctxt, value, -2048, 2047);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VertOffset_B12: end\n");

   return (stat);
}

EXTERN int asn1PE_VINstring (OSCTXT* pctxt, VINstring* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VINstring: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(17), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VINstring: end\n");

   return (stat);
}

EXTERN int asn1PE_WaitOnStopline (OSCTXT* pctxt, WaitOnStopline value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_WaitOnStopline: start\n");

   PU_NEWFIELD (pctxt, "boolean");

   stat = rtxEncBit (pctxt, (OSBOOL)value);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_WaitOnStopline: end\n");

   return (stat);
}

EXTERN int asn1PE_WiperRate (OSCTXT* pctxt, WiperRate value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_WiperRate: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 127);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_WiperRate: end\n");

   return (stat);
}

EXTERN int asn1PE_WiperStatus (OSCTXT* pctxt, WiperStatus value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_WiperStatus: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   rtxEncBit (pctxt, 0);

   PU_SETBITCOUNT (pctxt);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(6));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_WiperStatus: end\n");

   return (stat);
}

EXTERN int asn1PE_YawRateConfidence (OSCTXT* pctxt, YawRateConfidence value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_YawRateConfidence: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_YawRateConfidence: end\n");

   return (stat);
}

EXTERN int asn1PE_YawRate (OSCTXT* pctxt, YawRate value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_YawRate: start\n");

   stat = pe_ConsInteger (pctxt, value, -32767, 32767);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_YawRate: end\n");

   return (stat);
}

EXTERN int asn1PE_ZoneLength (OSCTXT* pctxt, ZoneLength value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ZoneLength: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 10000);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_ZoneLength: end\n");

   return (stat);
}

EXTERN int asn1PE_Zoom (OSCTXT* pctxt, Zoom value)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Zoom: start\n");

   stat = pe_ConsUnsigned (pctxt, value, 0, 15);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Zoom: end\n");

   return (stat);
}

EXTERN int asn1PE_MessageFrame (OSCTXT* pctxt, MessageFrame* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_MessageFrame: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   /* encode messageId */

   stat = asn1PE_DSRCmsgID (pctxt, pvalue->messageId);
   if (stat != 0) return stat;

   /* encode value */

   stat = pe_OpenType (pctxt, pvalue->value.numocts, pvalue->value.data);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MessageFrame: end\n");

   return (stat);
}

EXTERN int asn1PE_PositionalAccuracy (OSCTXT* pctxt, PositionalAccuracy* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PositionalAccuracy: start\n");

   /* encode semiMajor */

   stat = asn1PE_SemiMajorAxisAccuracy (pctxt, pvalue->semiMajor);
   if (stat != 0) return stat;

   /* encode semiMinor */

   stat = asn1PE_SemiMinorAxisAccuracy (pctxt, pvalue->semiMinor);
   if (stat != 0) return stat;

   /* encode orientation */

   stat = asn1PE_SemiMajorAxisOrientation (pctxt, pvalue->orientation);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PositionalAccuracy: end\n");

   return (stat);
}

EXTERN int asn1PE_AccelerationSet4Way (OSCTXT* pctxt, AccelerationSet4Way* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AccelerationSet4Way: start\n");

   /* encode long_ */

   stat = asn1PE_Acceleration (pctxt, pvalue->long_);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_Acceleration (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   /* encode vert */

   stat = asn1PE_VerticalAcceleration (pctxt, pvalue->vert);
   if (stat != 0) return stat;

   /* encode yaw */

   stat = asn1PE_YawRate (pctxt, pvalue->yaw);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_AccelerationSet4Way: end\n");

   return (stat);
}

EXTERN int asn1PE_BrakeSystemStatus (OSCTXT* pctxt, BrakeSystemStatus* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_BrakeSystemStatus: start\n");

   /* encode wheelBrakes */

   stat = asn1PE_BrakeAppliedStatus (pctxt, &pvalue->wheelBrakes);
   if (stat != 0) return stat;

   /* encode traction */

   stat = asn1PE_TractionControlStatus (pctxt, pvalue->traction);
   if (stat != 0) return stat;

   /* encode abs_ */

   stat = asn1PE_AntiLockBrakeStatus (pctxt, pvalue->abs_);
   if (stat != 0) return stat;

   /* encode scs */

   stat = asn1PE_StabilityControlStatus (pctxt, pvalue->scs);
   if (stat != 0) return stat;

   /* encode brakeBoost */

   stat = asn1PE_BrakeBoostApplied (pctxt, pvalue->brakeBoost);
   if (stat != 0) return stat;

   /* encode auxBrakes */

   stat = asn1PE_AuxiliaryBrakeStatus (pctxt, pvalue->auxBrakes);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_BrakeSystemStatus: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleSize (OSCTXT* pctxt, VehicleSize* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleSize: start\n");

   /* encode width */

   stat = asn1PE_VehicleWidth (pctxt, pvalue->width);
   if (stat != 0) return stat;

   /* encode length */

   stat = asn1PE_VehicleLength (pctxt, pvalue->length);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleSize: end\n");

   return (stat);
}

EXTERN int asn1PE_BSMcoreData (OSCTXT* pctxt, BSMcoreData* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_BSMcoreData: start\n");

   /* encode msgCnt */

   stat = asn1PE_MsgCount (pctxt, pvalue->msgCnt);
   if (stat != 0) return stat;

   /* encode id */

   stat = asn1PE_TemporaryID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* encode secMark */

   stat = asn1PE_DSecond (pctxt, pvalue->secMark);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_Latitude (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   /* encode long_ */

   stat = asn1PE_Longitude (pctxt, pvalue->long_);
   if (stat != 0) return stat;

   /* encode elev */

   stat = asn1PE_Elevation (pctxt, pvalue->elev);
   if (stat != 0) return stat;

   /* encode accuracy */

   stat = asn1PE_PositionalAccuracy (pctxt, &pvalue->accuracy);
   if (stat != 0) return stat;

   /* encode transmission */

   stat = asn1PE_TransmissionState (pctxt, pvalue->transmission);
   if (stat != 0) return stat;

   /* encode speed */

   stat = asn1PE_Speed (pctxt, pvalue->speed);
   if (stat != 0) return stat;

   /* encode heading */

   stat = asn1PE_Heading (pctxt, pvalue->heading);
   if (stat != 0) return stat;

   /* encode angle */

   stat = asn1PE_SteeringWheelAngle (pctxt, pvalue->angle);
   if (stat != 0) return stat;

   /* encode accelSet */

   stat = asn1PE_AccelerationSet4Way (pctxt, &pvalue->accelSet);
   if (stat != 0) return stat;

   /* encode brakes */

   stat = asn1PE_BrakeSystemStatus (pctxt, &pvalue->brakes);
   if (stat != 0) return stat;

   /* encode size */

   stat = asn1PE_VehicleSize (pctxt, &pvalue->size);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_BSMcoreData: end\n");

   return (stat);
}

EXTERN int asn1PE_PartIIcontent (OSCTXT* pctxt, PartIIcontent* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PartIIcontent: start\n");

   /* encode partII_Id */

   stat = asn1PE_PartII_Id (pctxt, pvalue->partII_Id);
   if (stat != 0) return stat;

   /* encode partII_Value */

   stat = pe_OpenType (pctxt, pvalue->partII_Value.numocts, pvalue->partII_Value.data);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PartIIcontent: end\n");

   return (stat);
}

EXTERN int asn1PE_BasicSafetyMessage_partII (OSCTXT* pctxt, BasicSafetyMessage_partII* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_BasicSafetyMessage_partII: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_PartIIcontent (pctxt, ((PartIIcontent*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_BasicSafetyMessage_partII: end\n");

   return (stat);
}

EXTERN int asn1PE_RegionalExtension (OSCTXT* pctxt, RegionalExtension* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RegionalExtension: start\n");

   /* encode regionId */

   stat = asn1PE_RegionId (pctxt, pvalue->regionId);
   if (stat != 0) return stat;

   /* encode regExtValue */

   stat = pe_OpenType (pctxt, pvalue->regExtValue.numocts, pvalue->regExtValue.data);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RegionalExtension: end\n");

   return (stat);
}

EXTERN int asn1PE_BasicSafetyMessage_regional (OSCTXT* pctxt, BasicSafetyMessage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_BasicSafetyMessage_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_BasicSafetyMessage_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_BasicSafetyMessage (OSCTXT* pctxt, BasicSafetyMessage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_BasicSafetyMessage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "partIIPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.partIIPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode coreData */

   stat = asn1PE_BSMcoreData (pctxt, &pvalue->coreData);
   if (stat != 0) return stat;

   /* encode partII */

   if (pvalue->m.partIIPresent) {
      stat = asn1PE_BasicSafetyMessage_partII (pctxt, &pvalue->partII);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_BasicSafetyMessage_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_BasicSafetyMessage: end\n");

   return (stat);
}

EXTERN int asn1PE_RequestedItemList (OSCTXT* pctxt, RequestedItemList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestedItemList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_RequestedItem (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestedItemList: end\n");

   return (stat);
}

EXTERN int asn1PE_CommonSafetyRequest_regional (OSCTXT* pctxt, CommonSafetyRequest_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonSafetyRequest_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonSafetyRequest_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_CommonSafetyRequest (OSCTXT* pctxt, CommonSafetyRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonSafetyRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeStampPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "msgCntPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.msgCntPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "idPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.idPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode msgCnt */

   if (pvalue->m.msgCntPresent) {
      stat = asn1PE_MsgCount (pctxt, pvalue->msgCnt);
      if (stat != 0) return stat;
   }

   /* encode id */

   if (pvalue->m.idPresent) {
      stat = asn1PE_TemporaryID (pctxt, &pvalue->id);
      if (stat != 0) return stat;
   }

   /* encode requests */

   stat = asn1PE_RequestedItemList (pctxt, &pvalue->requests);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_CommonSafetyRequest_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CommonSafetyRequest: end\n");

   return (stat);
}

EXTERN int asn1PE_RoadSideAlert_description (OSCTXT* pctxt, RoadSideAlert_description* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSideAlert_description: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_ITIScodes (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSideAlert_description: end\n");

   return (stat);
}

EXTERN int asn1PE_DDateTime (OSCTXT* pctxt, DDateTime* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DDateTime: start\n");

   PU_NEWFIELD (pctxt, "yearPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.yearPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "monthPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.monthPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dayPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dayPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hourPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.hourPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minutePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.minutePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "secondPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.secondPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "offsetPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.offsetPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode year */

   if (pvalue->m.yearPresent) {
      stat = asn1PE_DYear (pctxt, pvalue->year);
      if (stat != 0) return stat;
   }

   /* encode month */

   if (pvalue->m.monthPresent) {
      stat = asn1PE_DMonth (pctxt, pvalue->month);
      if (stat != 0) return stat;
   }

   /* encode day */

   if (pvalue->m.dayPresent) {
      stat = asn1PE_DDay (pctxt, pvalue->day);
      if (stat != 0) return stat;
   }

   /* encode hour */

   if (pvalue->m.hourPresent) {
      stat = asn1PE_DHour (pctxt, pvalue->hour);
      if (stat != 0) return stat;
   }

   /* encode minute */

   if (pvalue->m.minutePresent) {
      stat = asn1PE_DMinute (pctxt, pvalue->minute);
      if (stat != 0) return stat;
   }

   /* encode second */

   if (pvalue->m.secondPresent) {
      stat = asn1PE_DSecond (pctxt, pvalue->second);
      if (stat != 0) return stat;
   }

   /* encode offset */

   if (pvalue->m.offsetPresent) {
      stat = asn1PE_DOffset (pctxt, pvalue->offset);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DDateTime: end\n");

   return (stat);
}

EXTERN int asn1PE_TransmissionAndSpeed (OSCTXT* pctxt, TransmissionAndSpeed* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmissionAndSpeed: start\n");

   /* encode transmisson */

   stat = asn1PE_TransmissionState (pctxt, pvalue->transmisson);
   if (stat != 0) return stat;

   /* encode speed */

   stat = asn1PE_Velocity (pctxt, pvalue->speed);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_TransmissionAndSpeed: end\n");

   return (stat);
}

EXTERN int asn1PE_PositionConfidenceSet (OSCTXT* pctxt, PositionConfidenceSet* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PositionConfidenceSet: start\n");

   /* encode pos */

   stat = asn1PE_PositionConfidence (pctxt, pvalue->pos);
   if (stat != 0) return stat;

   /* encode elevation */

   stat = asn1PE_ElevationConfidence (pctxt, pvalue->elevation);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_PositionConfidenceSet: end\n");

   return (stat);
}

EXTERN int asn1PE_SpeedandHeadingandThrottleConfidence (OSCTXT* pctxt, SpeedandHeadingandThrottleConfidence* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedandHeadingandThrottleConfidence: start\n");

   /* encode heading */

   stat = asn1PE_HeadingConfidence (pctxt, pvalue->heading);
   if (stat != 0) return stat;

   /* encode speed */

   stat = asn1PE_SpeedConfidence (pctxt, pvalue->speed);
   if (stat != 0) return stat;

   /* encode throttle */

   stat = asn1PE_ThrottleConfidence (pctxt, pvalue->throttle);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedandHeadingandThrottleConfidence: end\n");

   return (stat);
}

EXTERN int asn1PE_FullPositionVector (OSCTXT* pctxt, FullPositionVector* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_FullPositionVector: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "utcTimePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.utcTimePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "elevationPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.elevationPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headingPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headingPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "speedPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "posAccuracyPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.posAccuracyPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeConfidencePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeConfidencePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "posConfidencePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.posConfidencePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "speedConfidencePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedConfidencePresent);

   PU_SETBITCOUNT (pctxt);

   /* encode utcTime */

   if (pvalue->m.utcTimePresent) {
      stat = asn1PE_DDateTime (pctxt, &pvalue->utcTime);
      if (stat != 0) return stat;
   }

   /* encode long_ */

   stat = asn1PE_Longitude (pctxt, pvalue->long_);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_Latitude (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   /* encode elevation */

   if (pvalue->m.elevationPresent) {
      stat = asn1PE_Elevation (pctxt, pvalue->elevation);
      if (stat != 0) return stat;
   }

   /* encode heading */

   if (pvalue->m.headingPresent) {
      stat = asn1PE_Heading (pctxt, pvalue->heading);
      if (stat != 0) return stat;
   }

   /* encode speed */

   if (pvalue->m.speedPresent) {
      stat = asn1PE_TransmissionAndSpeed (pctxt, &pvalue->speed);
      if (stat != 0) return stat;
   }

   /* encode posAccuracy */

   if (pvalue->m.posAccuracyPresent) {
      stat = asn1PE_PositionalAccuracy (pctxt, &pvalue->posAccuracy);
      if (stat != 0) return stat;
   }

   /* encode timeConfidence */

   if (pvalue->m.timeConfidencePresent) {
      stat = asn1PE_TimeConfidence (pctxt, pvalue->timeConfidence);
      if (stat != 0) return stat;
   }

   /* encode posConfidence */

   if (pvalue->m.posConfidencePresent) {
      stat = asn1PE_PositionConfidenceSet (pctxt, &pvalue->posConfidence);
      if (stat != 0) return stat;
   }

   /* encode speedConfidence */

   if (pvalue->m.speedConfidencePresent) {
      stat = asn1PE_SpeedandHeadingandThrottleConfidence (pctxt, &pvalue->speedConfidence);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_FullPositionVector: end\n");

   return (stat);
}

EXTERN int asn1PE_RoadSideAlert_regional (OSCTXT* pctxt, RoadSideAlert_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSideAlert_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSideAlert_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_RoadSideAlert (OSCTXT* pctxt, RoadSideAlert* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSideAlert: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeStampPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "descriptionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.descriptionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "priorityPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.priorityPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headingPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headingPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "extentPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.extentPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "positionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.positionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "furtherInfoIDPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.furtherInfoIDPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode msgCnt */

   stat = asn1PE_MsgCount (pctxt, pvalue->msgCnt);
   if (stat != 0) return stat;

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode typeEvent */

   stat = asn1PE_ITIScodes (pctxt, pvalue->typeEvent);
   if (stat != 0) return stat;

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = asn1PE_RoadSideAlert_description (pctxt, &pvalue->description);
      if (stat != 0) return stat;
   }

   /* encode priority */

   if (pvalue->m.priorityPresent) {
      stat = asn1PE_Priority (pctxt, &pvalue->priority);
      if (stat != 0) return stat;
   }

   /* encode heading */

   if (pvalue->m.headingPresent) {
      stat = asn1PE_HeadingSlice (pctxt, &pvalue->heading);
      if (stat != 0) return stat;
   }

   /* encode extent */

   if (pvalue->m.extentPresent) {
      stat = asn1PE_Extent (pctxt, pvalue->extent);
      if (stat != 0) return stat;
   }

   /* encode position */

   if (pvalue->m.positionPresent) {
      stat = asn1PE_FullPositionVector (pctxt, &pvalue->position);
      if (stat != 0) return stat;
   }

   /* encode furtherInfoID */

   if (pvalue->m.furtherInfoIDPresent) {
      stat = asn1PE_FurtherInfoID (pctxt, &pvalue->furtherInfoID);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RoadSideAlert_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSideAlert: end\n");

   return (stat);
}

EXTERN int asn1PE_PrivilegedEvents (OSCTXT* pctxt, PrivilegedEvents* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_PrivilegedEvents: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   /* encode sspRights */

   stat = asn1PE_SSPindex (pctxt, pvalue->sspRights);
   if (stat != 0) return stat;

   /* encode event */

   stat = asn1PE_PrivilegedEventFlags (pctxt, &pvalue->event);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PrivilegedEvents: end\n");

   return (stat);
}

EXTERN int asn1PE_EmergencyDetails (OSCTXT* pctxt, EmergencyDetails* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_EmergencyDetails: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "eventsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.eventsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "responseTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.responseTypePresent);

   PU_SETBITCOUNT (pctxt);

   /* encode sspRights */

   stat = asn1PE_SSPindex (pctxt, pvalue->sspRights);
   if (stat != 0) return stat;

   /* encode sirenUse */

   stat = asn1PE_SirenInUse (pctxt, pvalue->sirenUse);
   if (stat != 0) return stat;

   /* encode lightsUse */

   stat = asn1PE_LightbarInUse (pctxt, pvalue->lightsUse);
   if (stat != 0) return stat;

   /* encode multi */

   stat = asn1PE_MultiVehicleResponse (pctxt, pvalue->multi);
   if (stat != 0) return stat;

   /* encode events */

   if (pvalue->m.eventsPresent) {
      stat = asn1PE_PrivilegedEvents (pctxt, &pvalue->events);
      if (stat != 0) return stat;
   }

   /* encode responseType */

   if (pvalue->m.responseTypePresent) {
      stat = asn1PE_ResponseType (pctxt, pvalue->responseType);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_EmergencyDetails: end\n");

   return (stat);
}

EXTERN int asn1PE_EmergencyVehicleAlert_regional (OSCTXT* pctxt, EmergencyVehicleAlert_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_EmergencyVehicleAlert_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_EmergencyVehicleAlert_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_EmergencyVehicleAlert (OSCTXT* pctxt, EmergencyVehicleAlert* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_EmergencyVehicleAlert: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeStampPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "idPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.idPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "responseTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.responseTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "detailsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.detailsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "massPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.massPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "basicTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.basicTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "vehicleTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehicleTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "responseEquipPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.responseEquipPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "responderTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.responderTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode id */

   if (pvalue->m.idPresent) {
      stat = asn1PE_TemporaryID (pctxt, &pvalue->id);
      if (stat != 0) return stat;
   }

   /* encode rsaMsg */

   stat = asn1PE_RoadSideAlert (pctxt, &pvalue->rsaMsg);
   if (stat != 0) return stat;

   /* encode responseType */

   if (pvalue->m.responseTypePresent) {
      stat = asn1PE_ResponseType (pctxt, pvalue->responseType);
      if (stat != 0) return stat;
   }

   /* encode details */

   if (pvalue->m.detailsPresent) {
      stat = asn1PE_EmergencyDetails (pctxt, &pvalue->details);
      if (stat != 0) return stat;
   }

   /* encode mass */

   if (pvalue->m.massPresent) {
      stat = asn1PE_VehicleMass (pctxt, pvalue->mass);
      if (stat != 0) return stat;
   }

   /* encode basicType */

   if (pvalue->m.basicTypePresent) {
      stat = asn1PE_VehicleType (pctxt, pvalue->basicType);
      if (stat != 0) return stat;
   }

   /* encode vehicleType */

   if (pvalue->m.vehicleTypePresent) {
      stat = asn1PE_VehicleGroupAffected (pctxt, pvalue->vehicleType);
      if (stat != 0) return stat;
   }

   /* encode responseEquip */

   if (pvalue->m.responseEquipPresent) {
      stat = asn1PE_IncidentResponseEquipment (pctxt, pvalue->responseEquip);
      if (stat != 0) return stat;
   }

   /* encode responderType */

   if (pvalue->m.responderTypePresent) {
      stat = asn1PE_ResponderGroupAffected (pctxt, pvalue->responderType);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_EmergencyVehicleAlert_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_EmergencyVehicleAlert: end\n");

   return (stat);
}

EXTERN int asn1PE_PathHistoryPoint (OSCTXT* pctxt, PathHistoryPoint* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_PathHistoryPoint: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "speedPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "posAccuracyPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.posAccuracyPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headingPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headingPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode latOffset */

   stat = asn1PE_OffsetLL_B18 (pctxt, pvalue->latOffset);
   if (stat != 0) return stat;

   /* encode lonOffset */

   stat = asn1PE_OffsetLL_B18 (pctxt, pvalue->lonOffset);
   if (stat != 0) return stat;

   /* encode elevationOffset */

   stat = asn1PE_VertOffset_B12 (pctxt, pvalue->elevationOffset);
   if (stat != 0) return stat;

   /* encode timeOffset */

   stat = asn1PE_TimeOffset (pctxt, pvalue->timeOffset);
   if (stat != 0) return stat;

   /* encode speed */

   if (pvalue->m.speedPresent) {
      stat = asn1PE_Speed (pctxt, pvalue->speed);
      if (stat != 0) return stat;
   }

   /* encode posAccuracy */

   if (pvalue->m.posAccuracyPresent) {
      stat = asn1PE_PositionalAccuracy (pctxt, &pvalue->posAccuracy);
      if (stat != 0) return stat;
   }

   /* encode heading */

   if (pvalue->m.headingPresent) {
      stat = asn1PE_CoarseHeading (pctxt, pvalue->heading);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PathHistoryPoint: end\n");

   return (stat);
}

EXTERN int asn1PE_PathHistoryPointList (OSCTXT* pctxt, PathHistoryPointList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PathHistoryPointList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(23), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_PathHistoryPoint (pctxt, ((PathHistoryPoint*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PathHistoryPointList: end\n");

   return (stat);
}

EXTERN int asn1PE_PathHistory (OSCTXT* pctxt, PathHistory* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_PathHistory: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "initialPositionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.initialPositionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "currGNSSstatusPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.currGNSSstatusPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode initialPosition */

   if (pvalue->m.initialPositionPresent) {
      stat = asn1PE_FullPositionVector (pctxt, &pvalue->initialPosition);
      if (stat != 0) return stat;
   }

   /* encode currGNSSstatus */

   if (pvalue->m.currGNSSstatusPresent) {
      stat = asn1PE_GNSSstatus (pctxt, &pvalue->currGNSSstatus);
      if (stat != 0) return stat;
   }

   /* encode crumbData */

   stat = asn1PE_PathHistoryPointList (pctxt, &pvalue->crumbData);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PathHistory: end\n");

   return (stat);
}

EXTERN int asn1PE_PathPrediction (OSCTXT* pctxt, PathPrediction* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_PathPrediction: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   /* encode radiusOfCurve */

   stat = asn1PE_RadiusOfCurvature (pctxt, pvalue->radiusOfCurve);
   if (stat != 0) return stat;

   /* encode confidence */

   stat = asn1PE_Confidence (pctxt, pvalue->confidence);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PathPrediction: end\n");

   return (stat);
}

EXTERN int asn1PE_IntersectionReferenceID (OSCTXT* pctxt, IntersectionReferenceID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionReferenceID: start\n");

   PU_NEWFIELD (pctxt, "regionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode region */

   if (pvalue->m.regionPresent) {
      stat = asn1PE_RoadRegulatorID (pctxt, pvalue->region);
      if (stat != 0) return stat;
   }

   /* encode id */

   stat = asn1PE_IntersectionID (pctxt, pvalue->id);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionReferenceID: end\n");

   return (stat);
}

EXTERN int asn1PE_ApproachOrLane (OSCTXT* pctxt, ApproachOrLane* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ApproachOrLane: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* approach */
      case 1:
         stat = asn1PE_ApproachID (pctxt, pvalue->u.approach);
         if (stat != 0) return stat;
         break;

      /* lane */
      case 2:
         stat = asn1PE_LaneID (pctxt, pvalue->u.lane);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ApproachOrLane: end\n");

   return (stat);
}

EXTERN int asn1PE_IntersectionCollision_regional (OSCTXT* pctxt, IntersectionCollision_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionCollision_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionCollision_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_IntersectionCollision (OSCTXT* pctxt, IntersectionCollision* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionCollision: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeStampPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "partOnePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.partOnePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pathPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pathPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pathPredictionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pathPredictionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode msgCnt */

   stat = asn1PE_MsgCount (pctxt, pvalue->msgCnt);
   if (stat != 0) return stat;

   /* encode id */

   stat = asn1PE_TemporaryID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode partOne */

   if (pvalue->m.partOnePresent) {
      stat = asn1PE_BSMcoreData (pctxt, &pvalue->partOne);
      if (stat != 0) return stat;
   }

   /* encode path */

   if (pvalue->m.pathPresent) {
      stat = asn1PE_PathHistory (pctxt, &pvalue->path);
      if (stat != 0) return stat;
   }

   /* encode pathPrediction */

   if (pvalue->m.pathPredictionPresent) {
      stat = asn1PE_PathPrediction (pctxt, &pvalue->pathPrediction);
      if (stat != 0) return stat;
   }

   /* encode intersectionID */

   stat = asn1PE_IntersectionReferenceID (pctxt, &pvalue->intersectionID);
   if (stat != 0) return stat;

   /* encode laneNumber */

   stat = asn1PE_ApproachOrLane (pctxt, &pvalue->laneNumber);
   if (stat != 0) return stat;

   /* encode eventFlag */

   stat = asn1PE_VehicleEventFlags (pctxt, &pvalue->eventFlag);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_IntersectionCollision_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionCollision: end\n");

   return (stat);
}

EXTERN int asn1PE_Position3D_regional (OSCTXT* pctxt, Position3D_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_Position3D_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Position3D_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_Position3D (OSCTXT* pctxt, Position3D* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_Position3D: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "elevationPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.elevationPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode lat */

   stat = asn1PE_Latitude (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   /* encode long_ */

   stat = asn1PE_Longitude (pctxt, pvalue->long_);
   if (stat != 0) return stat;

   /* encode elevation */

   if (pvalue->m.elevationPresent) {
      stat = asn1PE_Elevation (pctxt, pvalue->elevation);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_Position3D_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Position3D: end\n");

   return (stat);
}

EXTERN int asn1PE_RegulatorySpeedLimit (OSCTXT* pctxt, RegulatorySpeedLimit* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RegulatorySpeedLimit: start\n");

   /* encode type */

   stat = asn1PE_SpeedLimitType (pctxt, pvalue->type);
   if (stat != 0) return stat;

   /* encode speed */

   stat = asn1PE_Velocity (pctxt, pvalue->speed);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RegulatorySpeedLimit: end\n");

   return (stat);
}

EXTERN int asn1PE_SpeedLimitList (OSCTXT* pctxt, SpeedLimitList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedLimitList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(9), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegulatorySpeedLimit (pctxt, ((RegulatorySpeedLimit*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedLimitList: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneTypeAttributes (OSCTXT* pctxt, LaneTypeAttributes* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneTypeAttributes: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 8);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 3);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* vehicle */
         case 1:
            stat = asn1PE_LaneAttributes_Vehicle (pctxt, pvalue->u.vehicle);
            if (stat != 0) return stat;
            break;

         /* crosswalk */
         case 2:
            stat = asn1PE_LaneAttributes_Crosswalk (pctxt, pvalue->u.crosswalk);
            if (stat != 0) return stat;
            break;

         /* bikeLane */
         case 3:
            stat = asn1PE_LaneAttributes_Bike (pctxt, pvalue->u.bikeLane);
            if (stat != 0) return stat;
            break;

         /* sidewalk */
         case 4:
            stat = asn1PE_LaneAttributes_Sidewalk (pctxt, pvalue->u.sidewalk);
            if (stat != 0) return stat;
            break;

         /* median */
         case 5:
            stat = asn1PE_LaneAttributes_Barrier (pctxt, pvalue->u.median);
            if (stat != 0) return stat;
            break;

         /* striping */
         case 6:
            stat = asn1PE_LaneAttributes_Striping (pctxt, pvalue->u.striping);
            if (stat != 0) return stat;
            break;

         /* trackedVehicle */
         case 7:
            stat = asn1PE_LaneAttributes_TrackedVehicle (pctxt, pvalue->u.trackedVehicle);
            if (stat != 0) return stat;
            break;

         /* parking */
         case 8:
            stat = asn1PE_LaneAttributes_Parking (pctxt, pvalue->u.parking);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 9);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneTypeAttributes: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneAttributes (OSCTXT* pctxt, LaneAttributes* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes: start\n");

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode directionalUse */

   stat = asn1PE_LaneDirection (pctxt, &pvalue->directionalUse);
   if (stat != 0) return stat;

   /* encode sharedWith */

   stat = asn1PE_LaneSharing (pctxt, &pvalue->sharedWith);
   if (stat != 0) return stat;

   /* encode laneType */

   stat = asn1PE_LaneTypeAttributes (pctxt, &pvalue->laneType);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneAttributes: end\n");

   return (stat);
}

EXTERN int asn1PE_Node_XY_20b (OSCTXT* pctxt, Node_XY_20b* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_XY_20b: start\n");

   /* encode x */

   stat = asn1PE_Offset_B10 (pctxt, pvalue->x);
   if (stat != 0) return stat;

   /* encode y */

   stat = asn1PE_Offset_B10 (pctxt, pvalue->y);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_XY_20b: end\n");

   return (stat);
}

EXTERN int asn1PE_Node_XY_22b (OSCTXT* pctxt, Node_XY_22b* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_XY_22b: start\n");

   /* encode x */

   stat = asn1PE_Offset_B11 (pctxt, pvalue->x);
   if (stat != 0) return stat;

   /* encode y */

   stat = asn1PE_Offset_B11 (pctxt, pvalue->y);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_XY_22b: end\n");

   return (stat);
}

EXTERN int asn1PE_Node_XY_24b (OSCTXT* pctxt, Node_XY_24b* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_XY_24b: start\n");

   /* encode x */

   stat = asn1PE_Offset_B12 (pctxt, pvalue->x);
   if (stat != 0) return stat;

   /* encode y */

   stat = asn1PE_Offset_B12 (pctxt, pvalue->y);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_XY_24b: end\n");

   return (stat);
}

EXTERN int asn1PE_Node_XY_26b (OSCTXT* pctxt, Node_XY_26b* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_XY_26b: start\n");

   /* encode x */

   stat = asn1PE_Offset_B13 (pctxt, pvalue->x);
   if (stat != 0) return stat;

   /* encode y */

   stat = asn1PE_Offset_B13 (pctxt, pvalue->y);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_XY_26b: end\n");

   return (stat);
}

EXTERN int asn1PE_Node_XY_28b (OSCTXT* pctxt, Node_XY_28b* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_XY_28b: start\n");

   /* encode x */

   stat = asn1PE_Offset_B14 (pctxt, pvalue->x);
   if (stat != 0) return stat;

   /* encode y */

   stat = asn1PE_Offset_B14 (pctxt, pvalue->y);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_XY_28b: end\n");

   return (stat);
}

EXTERN int asn1PE_Node_XY_32b (OSCTXT* pctxt, Node_XY_32b* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_XY_32b: start\n");

   /* encode x */

   stat = asn1PE_Offset_B16 (pctxt, pvalue->x);
   if (stat != 0) return stat;

   /* encode y */

   stat = asn1PE_Offset_B16 (pctxt, pvalue->y);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_XY_32b: end\n");

   return (stat);
}

EXTERN int asn1PE_Node_LLmD_64b (OSCTXT* pctxt, Node_LLmD_64b* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_LLmD_64b: start\n");

   /* encode lon */

   stat = asn1PE_Longitude (pctxt, pvalue->lon);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_Latitude (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_LLmD_64b: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeOffsetPointXY (OSCTXT* pctxt, NodeOffsetPointXY* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeOffsetPointXY: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 3);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* node_XY1 */
      case 1:
         stat = asn1PE_Node_XY_20b (pctxt, pvalue->u.node_XY1);
         if (stat != 0) return stat;
         break;

      /* node_XY2 */
      case 2:
         stat = asn1PE_Node_XY_22b (pctxt, pvalue->u.node_XY2);
         if (stat != 0) return stat;
         break;

      /* node_XY3 */
      case 3:
         stat = asn1PE_Node_XY_24b (pctxt, pvalue->u.node_XY3);
         if (stat != 0) return stat;
         break;

      /* node_XY4 */
      case 4:
         stat = asn1PE_Node_XY_26b (pctxt, pvalue->u.node_XY4);
         if (stat != 0) return stat;
         break;

      /* node_XY5 */
      case 5:
         stat = asn1PE_Node_XY_28b (pctxt, pvalue->u.node_XY5);
         if (stat != 0) return stat;
         break;

      /* node_XY6 */
      case 6:
         stat = asn1PE_Node_XY_32b (pctxt, pvalue->u.node_XY6);
         if (stat != 0) return stat;
         break;

      /* node_LatLon */
      case 7:
         stat = asn1PE_Node_LLmD_64b (pctxt, pvalue->u.node_LatLon);
         if (stat != 0) return stat;
         break;

      /* regional */
      case 8:
         stat = asn1PE_RegionalExtension (pctxt, pvalue->u.regional);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeOffsetPointXY: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeAttributeXYList (OSCTXT* pctxt, NodeAttributeXYList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeXYList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_NodeAttributeXY (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeXYList: end\n");

   return (stat);
}

EXTERN int asn1PE_SegmentAttributeXYList (OSCTXT* pctxt, SegmentAttributeXYList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SegmentAttributeXYList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_SegmentAttributeXY (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SegmentAttributeXYList: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneDataAttribute_regional (OSCTXT* pctxt, LaneDataAttribute_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneDataAttribute_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneDataAttribute_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneDataAttribute (OSCTXT* pctxt, LaneDataAttribute* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneDataAttribute: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 7);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 3);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* pathEndPointAngle */
         case 1:
            stat = asn1PE_DeltaAngle (pctxt, pvalue->u.pathEndPointAngle);
            if (stat != 0) return stat;
            break;

         /* laneCrownPointCenter */
         case 2:
            stat = asn1PE_RoadwayCrownAngle (pctxt, pvalue->u.laneCrownPointCenter);
            if (stat != 0) return stat;
            break;

         /* laneCrownPointLeft */
         case 3:
            stat = asn1PE_RoadwayCrownAngle (pctxt, pvalue->u.laneCrownPointLeft);
            if (stat != 0) return stat;
            break;

         /* laneCrownPointRight */
         case 4:
            stat = asn1PE_RoadwayCrownAngle (pctxt, pvalue->u.laneCrownPointRight);
            if (stat != 0) return stat;
            break;

         /* laneAngle */
         case 5:
            stat = asn1PE_MergeDivergeNodeAngle (pctxt, pvalue->u.laneAngle);
            if (stat != 0) return stat;
            break;

         /* speedLimits */
         case 6:
            stat = asn1PE_SpeedLimitList (pctxt, pvalue->u.speedLimits);
            if (stat != 0) return stat;
            break;

         /* regional */
         case 7:
            stat = asn1PE_LaneDataAttribute_regional (pctxt, pvalue->u.regional);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 8);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneDataAttribute: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneDataAttributeList (OSCTXT* pctxt, LaneDataAttributeList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneDataAttributeList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_LaneDataAttribute (pctxt, ((LaneDataAttribute*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneDataAttributeList: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeAttributeSetXY_regional (OSCTXT* pctxt, NodeAttributeSetXY_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeSetXY_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeSetXY_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeAttributeSetXY (OSCTXT* pctxt, NodeAttributeSetXY* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeSetXY: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "localNodePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.localNodePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "disabledPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.disabledPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "enabledPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.enabledPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dataPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dWidthPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dWidthPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dElevationPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dElevationPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode localNode */

   if (pvalue->m.localNodePresent) {
      stat = asn1PE_NodeAttributeXYList (pctxt, &pvalue->localNode);
      if (stat != 0) return stat;
   }

   /* encode disabled */

   if (pvalue->m.disabledPresent) {
      stat = asn1PE_SegmentAttributeXYList (pctxt, &pvalue->disabled);
      if (stat != 0) return stat;
   }

   /* encode enabled */

   if (pvalue->m.enabledPresent) {
      stat = asn1PE_SegmentAttributeXYList (pctxt, &pvalue->enabled);
      if (stat != 0) return stat;
   }

   /* encode data */

   if (pvalue->m.dataPresent) {
      stat = asn1PE_LaneDataAttributeList (pctxt, &pvalue->data);
      if (stat != 0) return stat;
   }

   /* encode dWidth */

   if (pvalue->m.dWidthPresent) {
      stat = asn1PE_Offset_B10 (pctxt, pvalue->dWidth);
      if (stat != 0) return stat;
   }

   /* encode dElevation */

   if (pvalue->m.dElevationPresent) {
      stat = asn1PE_Offset_B10 (pctxt, pvalue->dElevation);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_NodeAttributeSetXY_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeSetXY: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeXY (OSCTXT* pctxt, NodeXY* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeXY: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "attributesPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.attributesPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode delta */

   stat = asn1PE_NodeOffsetPointXY (pctxt, &pvalue->delta);
   if (stat != 0) return stat;

   /* encode attributes */

   if (pvalue->m.attributesPresent) {
      stat = asn1PE_NodeAttributeSetXY (pctxt, &pvalue->attributes);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeXY: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeSetXY (OSCTXT* pctxt, NodeSetXY* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeSetXY: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(63), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_NodeXY (pctxt, ((NodeXY*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeSetXY: end\n");

   return (stat);
}

EXTERN int asn1PE_ComputedLane_offsetXaxis (OSCTXT* pctxt, ComputedLane_offsetXaxis* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ComputedLane_offsetXaxis: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* small_ */
      case 1:
         stat = asn1PE_DrivenLineOffsetSm (pctxt, pvalue->u.small_);
         if (stat != 0) return stat;
         break;

      /* large_ */
      case 2:
         stat = asn1PE_DrivenLineOffsetLg (pctxt, pvalue->u.large_);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ComputedLane_offsetXaxis: end\n");

   return (stat);
}

EXTERN int asn1PE_ComputedLane_offsetYaxis (OSCTXT* pctxt, ComputedLane_offsetYaxis* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ComputedLane_offsetYaxis: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* small_ */
      case 1:
         stat = asn1PE_DrivenLineOffsetSm (pctxt, pvalue->u.small_);
         if (stat != 0) return stat;
         break;

      /* large_ */
      case 2:
         stat = asn1PE_DrivenLineOffsetLg (pctxt, pvalue->u.large_);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ComputedLane_offsetYaxis: end\n");

   return (stat);
}

EXTERN int asn1PE_ComputedLane_regional (OSCTXT* pctxt, ComputedLane_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_ComputedLane_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ComputedLane_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_ComputedLane (OSCTXT* pctxt, ComputedLane* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_ComputedLane: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rotateXYPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rotateXYPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "scaleXaxisPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.scaleXaxisPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "scaleYaxisPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.scaleYaxisPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode referenceLaneId */

   stat = asn1PE_LaneID (pctxt, pvalue->referenceLaneId);
   if (stat != 0) return stat;

   /* encode offsetXaxis */

   stat = asn1PE_ComputedLane_offsetXaxis (pctxt, &pvalue->offsetXaxis);
   if (stat != 0) return stat;

   /* encode offsetYaxis */

   stat = asn1PE_ComputedLane_offsetYaxis (pctxt, &pvalue->offsetYaxis);
   if (stat != 0) return stat;

   /* encode rotateXY */

   if (pvalue->m.rotateXYPresent) {
      stat = asn1PE_Angle (pctxt, pvalue->rotateXY);
      if (stat != 0) return stat;
   }

   /* encode scaleXaxis */

   if (pvalue->m.scaleXaxisPresent) {
      stat = asn1PE_Scale_B12 (pctxt, pvalue->scaleXaxis);
      if (stat != 0) return stat;
   }

   /* encode scaleYaxis */

   if (pvalue->m.scaleYaxisPresent) {
      stat = asn1PE_Scale_B12 (pctxt, pvalue->scaleYaxis);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_ComputedLane_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ComputedLane: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeListXY (OSCTXT* pctxt, NodeListXY* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeListXY: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* nodes */
         case 1:
            stat = asn1PE_NodeSetXY (pctxt, pvalue->u.nodes);
            if (stat != 0) return stat;
            break;

         /* computed */
         case 2:
            stat = asn1PE_ComputedLane (pctxt, pvalue->u.computed);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeListXY: end\n");

   return (stat);
}

EXTERN int asn1PE_ConnectingLane (OSCTXT* pctxt, ConnectingLane* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ConnectingLane: start\n");

   PU_NEWFIELD (pctxt, "maneuverPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.maneuverPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode lane */

   stat = asn1PE_LaneID (pctxt, pvalue->lane);
   if (stat != 0) return stat;

   /* encode maneuver */

   if (pvalue->m.maneuverPresent) {
      stat = asn1PE_AllowedManeuvers (pctxt, &pvalue->maneuver);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ConnectingLane: end\n");

   return (stat);
}

EXTERN int asn1PE_Connection (OSCTXT* pctxt, Connection* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Connection: start\n");

   PU_NEWFIELD (pctxt, "remoteIntersectionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.remoteIntersectionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "signalGroupPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.signalGroupPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "userClassPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.userClassPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "connectionIDPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.connectionIDPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode connectingLane */

   stat = asn1PE_ConnectingLane (pctxt, &pvalue->connectingLane);
   if (stat != 0) return stat;

   /* encode remoteIntersection */

   if (pvalue->m.remoteIntersectionPresent) {
      stat = asn1PE_IntersectionReferenceID (pctxt, &pvalue->remoteIntersection);
      if (stat != 0) return stat;
   }

   /* encode signalGroup */

   if (pvalue->m.signalGroupPresent) {
      stat = asn1PE_SignalGroupID (pctxt, pvalue->signalGroup);
      if (stat != 0) return stat;
   }

   /* encode userClass */

   if (pvalue->m.userClassPresent) {
      stat = asn1PE_RestrictionClassID (pctxt, pvalue->userClass);
      if (stat != 0) return stat;
   }

   /* encode connectionID */

   if (pvalue->m.connectionIDPresent) {
      stat = asn1PE_LaneConnectionID (pctxt, pvalue->connectionID);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Connection: end\n");

   return (stat);
}

EXTERN int asn1PE_ConnectsToList (OSCTXT* pctxt, ConnectsToList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_ConnectsToList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_Connection (pctxt, ((Connection*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ConnectsToList: end\n");

   return (stat);
}

EXTERN int asn1PE_OverlayLaneList (OSCTXT* pctxt, OverlayLaneList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_OverlayLaneList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(5), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_LaneID (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_OverlayLaneList: end\n");

   return (stat);
}

EXTERN int asn1PE_GenericLane_regional (OSCTXT* pctxt, GenericLane_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_GenericLane_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GenericLane_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_GenericLane (OSCTXT* pctxt, GenericLane* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_GenericLane: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "namePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.namePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ingressApproachPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.ingressApproachPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "egressApproachPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.egressApproachPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "maneuversPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.maneuversPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "connectsToPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.connectsToPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "overlaysPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.overlaysPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode laneID */

   stat = asn1PE_LaneID (pctxt, pvalue->laneID);
   if (stat != 0) return stat;

   /* encode name */

   if (pvalue->m.namePresent) {
      stat = asn1PE_DescriptiveName (pctxt, pvalue->name);
      if (stat != 0) return stat;
   }

   /* encode ingressApproach */

   if (pvalue->m.ingressApproachPresent) {
      stat = asn1PE_ApproachID (pctxt, pvalue->ingressApproach);
      if (stat != 0) return stat;
   }

   /* encode egressApproach */

   if (pvalue->m.egressApproachPresent) {
      stat = asn1PE_ApproachID (pctxt, pvalue->egressApproach);
      if (stat != 0) return stat;
   }

   /* encode laneAttributes */

   stat = asn1PE_LaneAttributes (pctxt, &pvalue->laneAttributes);
   if (stat != 0) return stat;

   /* encode maneuvers */

   if (pvalue->m.maneuversPresent) {
      stat = asn1PE_AllowedManeuvers (pctxt, &pvalue->maneuvers);
      if (stat != 0) return stat;
   }

   /* encode nodeList */

   stat = asn1PE_NodeListXY (pctxt, &pvalue->nodeList);
   if (stat != 0) return stat;

   /* encode connectsTo */

   if (pvalue->m.connectsToPresent) {
      stat = asn1PE_ConnectsToList (pctxt, &pvalue->connectsTo);
      if (stat != 0) return stat;
   }

   /* encode overlays */

   if (pvalue->m.overlaysPresent) {
      stat = asn1PE_OverlayLaneList (pctxt, &pvalue->overlays);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_GenericLane_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GenericLane: end\n");

   return (stat);
}

EXTERN int asn1PE_LaneList (OSCTXT* pctxt, LaneList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_GenericLane (pctxt, ((GenericLane*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_LaneList: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalControlZone (OSCTXT* pctxt, SignalControlZone* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalControlZone: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   /* encode zone */

   stat = asn1PE_RegionalExtension (pctxt, &pvalue->zone);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalControlZone: end\n");

   return (stat);
}

EXTERN int asn1PE_PreemptPriorityList (OSCTXT* pctxt, PreemptPriorityList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PreemptPriorityList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_SignalControlZone (pctxt, ((SignalControlZone*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PreemptPriorityList: end\n");

   return (stat);
}

EXTERN int asn1PE_IntersectionGeometry_regional (OSCTXT* pctxt, IntersectionGeometry_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionGeometry_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionGeometry_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_IntersectionGeometry (OSCTXT* pctxt, IntersectionGeometry* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionGeometry: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "namePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.namePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "laneWidthPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.laneWidthPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "speedLimitsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedLimitsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "preemptPriorityDataPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.preemptPriorityDataPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode name */

   if (pvalue->m.namePresent) {
      stat = asn1PE_DescriptiveName (pctxt, pvalue->name);
      if (stat != 0) return stat;
   }

   /* encode id */

   stat = asn1PE_IntersectionReferenceID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* encode revision */

   stat = asn1PE_MsgCount (pctxt, pvalue->revision);
   if (stat != 0) return stat;

   /* encode refPoint */

   stat = asn1PE_Position3D (pctxt, &pvalue->refPoint);
   if (stat != 0) return stat;

   /* encode laneWidth */

   if (pvalue->m.laneWidthPresent) {
      stat = asn1PE_LaneWidth (pctxt, pvalue->laneWidth);
      if (stat != 0) return stat;
   }

   /* encode speedLimits */

   if (pvalue->m.speedLimitsPresent) {
      stat = asn1PE_SpeedLimitList (pctxt, &pvalue->speedLimits);
      if (stat != 0) return stat;
   }

   /* encode laneSet */

   stat = asn1PE_LaneList (pctxt, &pvalue->laneSet);
   if (stat != 0) return stat;

   /* encode preemptPriorityData */

   if (pvalue->m.preemptPriorityDataPresent) {
      stat = asn1PE_PreemptPriorityList (pctxt, &pvalue->preemptPriorityData);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_IntersectionGeometry_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionGeometry: end\n");

   return (stat);
}

EXTERN int asn1PE_IntersectionGeometryList (OSCTXT* pctxt, IntersectionGeometryList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionGeometryList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_IntersectionGeometry (pctxt, ((IntersectionGeometry*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionGeometryList: end\n");

   return (stat);
}

EXTERN int asn1PE_RoadSegmentReferenceID (OSCTXT* pctxt, RoadSegmentReferenceID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSegmentReferenceID: start\n");

   PU_NEWFIELD (pctxt, "regionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode region */

   if (pvalue->m.regionPresent) {
      stat = asn1PE_RoadRegulatorID (pctxt, pvalue->region);
      if (stat != 0) return stat;
   }

   /* encode id */

   stat = asn1PE_RoadSegmentID (pctxt, pvalue->id);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSegmentReferenceID: end\n");

   return (stat);
}

EXTERN int asn1PE_RoadLaneSetList (OSCTXT* pctxt, RoadLaneSetList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadLaneSetList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_GenericLane (pctxt, ((GenericLane*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadLaneSetList: end\n");

   return (stat);
}

EXTERN int asn1PE_RoadSegment_regional (OSCTXT* pctxt, RoadSegment_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSegment_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSegment_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_RoadSegment (OSCTXT* pctxt, RoadSegment* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSegment: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "namePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.namePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "laneWidthPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.laneWidthPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "speedLimitsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedLimitsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode name */

   if (pvalue->m.namePresent) {
      stat = asn1PE_DescriptiveName (pctxt, pvalue->name);
      if (stat != 0) return stat;
   }

   /* encode id */

   stat = asn1PE_RoadSegmentReferenceID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* encode revision */

   stat = asn1PE_MsgCount (pctxt, pvalue->revision);
   if (stat != 0) return stat;

   /* encode refPoint */

   stat = asn1PE_Position3D (pctxt, &pvalue->refPoint);
   if (stat != 0) return stat;

   /* encode laneWidth */

   if (pvalue->m.laneWidthPresent) {
      stat = asn1PE_LaneWidth (pctxt, pvalue->laneWidth);
      if (stat != 0) return stat;
   }

   /* encode speedLimits */

   if (pvalue->m.speedLimitsPresent) {
      stat = asn1PE_SpeedLimitList (pctxt, &pvalue->speedLimits);
      if (stat != 0) return stat;
   }

   /* encode roadLaneSet */

   stat = asn1PE_RoadLaneSetList (pctxt, &pvalue->roadLaneSet);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RoadSegment_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSegment: end\n");

   return (stat);
}

EXTERN int asn1PE_RoadSegmentList (OSCTXT* pctxt, RoadSegmentList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSegmentList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RoadSegment (pctxt, ((RoadSegment*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSegmentList: end\n");

   return (stat);
}

EXTERN int asn1PE_DataParameters (OSCTXT* pctxt, DataParameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_DataParameters: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "processMethodPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.processMethodPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "processAgencyPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.processAgencyPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "lastCheckedDatePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.lastCheckedDatePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "geoidUsedPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.geoidUsedPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode processMethod */

   if (pvalue->m.processMethodPresent) {
      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

      stat = pe_ConstrainedStringEx (pctxt, pvalue->processMethod, 0, 8, 7, 7);
      if (stat != 0) return stat;
   }

   /* encode processAgency */

   if (pvalue->m.processAgencyPresent) {
      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

      stat = pe_ConstrainedStringEx (pctxt, pvalue->processAgency, 0, 8, 7, 7);
      if (stat != 0) return stat;
   }

   /* encode lastCheckedDate */

   if (pvalue->m.lastCheckedDatePresent) {
      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

      stat = pe_ConstrainedStringEx (pctxt, pvalue->lastCheckedDate, 0, 8, 7, 7);
      if (stat != 0) return stat;
   }

   /* encode geoidUsed */

   if (pvalue->m.geoidUsedPresent) {
      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

      stat = pe_ConstrainedStringEx (pctxt, pvalue->geoidUsed, 0, 8, 7, 7);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DataParameters: end\n");

   return (stat);
}

EXTERN int asn1PE_RestrictionUserType_regional (OSCTXT* pctxt, RestrictionUserType_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RestrictionUserType_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RestrictionUserType_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_RestrictionUserType (OSCTXT* pctxt, RestrictionUserType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_RestrictionUserType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 2);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* basicType */
         case 1:
            stat = asn1PE_RestrictionAppliesTo (pctxt, pvalue->u.basicType);
            if (stat != 0) return stat;
            break;

         /* regional */
         case 2:
            stat = asn1PE_RestrictionUserType_regional (pctxt, pvalue->u.regional);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RestrictionUserType: end\n");

   return (stat);
}

EXTERN int asn1PE_RestrictionUserTypeList (OSCTXT* pctxt, RestrictionUserTypeList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RestrictionUserTypeList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RestrictionUserType (pctxt, ((RestrictionUserType*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RestrictionUserTypeList: end\n");

   return (stat);
}

EXTERN int asn1PE_RestrictionClassAssignment (OSCTXT* pctxt, RestrictionClassAssignment* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RestrictionClassAssignment: start\n");

   /* encode id */

   stat = asn1PE_RestrictionClassID (pctxt, pvalue->id);
   if (stat != 0) return stat;

   /* encode users */

   stat = asn1PE_RestrictionUserTypeList (pctxt, &pvalue->users);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RestrictionClassAssignment: end\n");

   return (stat);
}

EXTERN int asn1PE_RestrictionClassList (OSCTXT* pctxt, RestrictionClassList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RestrictionClassList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(254), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RestrictionClassAssignment (pctxt, ((RestrictionClassAssignment*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RestrictionClassList: end\n");

   return (stat);
}

EXTERN int asn1PE_MapData_regional (OSCTXT* pctxt, MapData_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_MapData_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MapData_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_MapData (OSCTXT* pctxt, MapData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_MapData: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeStampPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "layerTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.layerTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "layerIDPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.layerIDPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "intersectionsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.intersectionsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "roadSegmentsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.roadSegmentsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dataParametersPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataParametersPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "restrictionListPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.restrictionListPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode msgIssueRevision */

   stat = asn1PE_MsgCount (pctxt, pvalue->msgIssueRevision);
   if (stat != 0) return stat;

   /* encode layerType */

   if (pvalue->m.layerTypePresent) {
      stat = asn1PE_LayerType (pctxt, pvalue->layerType);
      if (stat != 0) return stat;
   }

   /* encode layerID */

   if (pvalue->m.layerIDPresent) {
      stat = asn1PE_LayerID (pctxt, pvalue->layerID);
      if (stat != 0) return stat;
   }

   /* encode intersections */

   if (pvalue->m.intersectionsPresent) {
      stat = asn1PE_IntersectionGeometryList (pctxt, &pvalue->intersections);
      if (stat != 0) return stat;
   }

   /* encode roadSegments */

   if (pvalue->m.roadSegmentsPresent) {
      stat = asn1PE_RoadSegmentList (pctxt, &pvalue->roadSegments);
      if (stat != 0) return stat;
   }

   /* encode dataParameters */

   if (pvalue->m.dataParametersPresent) {
      stat = asn1PE_DataParameters (pctxt, &pvalue->dataParameters);
      if (stat != 0) return stat;
   }

   /* encode restrictionList */

   if (pvalue->m.restrictionListPresent) {
      stat = asn1PE_RestrictionClassList (pctxt, &pvalue->restrictionList);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_MapData_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MapData: end\n");

   return (stat);
}

EXTERN int asn1PE_NMEAcorrections_regional (OSCTXT* pctxt, NMEAcorrections_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_NMEAcorrections_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NMEAcorrections_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_NMEAcorrections (OSCTXT* pctxt, NMEAcorrections* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_NMEAcorrections: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeStampPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "revPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.revPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "msgPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.msgPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "wdCountPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.wdCountPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode rev */

   if (pvalue->m.revPresent) {
      stat = asn1PE_NMEA_Revision (pctxt, pvalue->rev);
      if (stat != 0) return stat;
   }

   /* encode msg */

   if (pvalue->m.msgPresent) {
      stat = asn1PE_NMEA_MsgType (pctxt, pvalue->msg);
      if (stat != 0) return stat;
   }

   /* encode wdCount */

   if (pvalue->m.wdCountPresent) {
      stat = asn1PE_ObjectCount (pctxt, pvalue->wdCount);
      if (stat != 0) return stat;
   }

   /* encode payload */

   stat = asn1PE_NMEA_Payload (pctxt, &pvalue->payload);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_NMEAcorrections_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NMEAcorrections: end\n");

   return (stat);
}

EXTERN int asn1PE_PropelledInformation (OSCTXT* pctxt, PropelledInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_PropelledInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 3);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 2);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* human */
         case 1:
            stat = asn1PE_HumanPropelledType (pctxt, pvalue->u.human);
            if (stat != 0) return stat;
            break;

         /* animal */
         case 2:
            stat = asn1PE_AnimalPropelledType (pctxt, pvalue->u.animal);
            if (stat != 0) return stat;
            break;

         /* motor */
         case 3:
            stat = asn1PE_MotorizedPropelledType (pctxt, pvalue->u.motor);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PropelledInformation: end\n");

   return (stat);
}

EXTERN int asn1PE_PersonalSafetyMessage_regional (OSCTXT* pctxt, PersonalSafetyMessage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalSafetyMessage_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalSafetyMessage_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_PersonalSafetyMessage (OSCTXT* pctxt, PersonalSafetyMessage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalSafetyMessage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "accelSetPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.accelSetPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pathHistoryPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pathHistoryPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pathPredictionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pathPredictionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "propulsionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.propulsionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "useStatePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.useStatePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "crossRequestPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.crossRequestPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "crossStatePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.crossStatePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "clusterSizePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.clusterSizePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "clusterRadiusPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.clusterRadiusPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "eventResponderTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.eventResponderTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "activityTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.activityTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "activitySubTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.activitySubTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "assistTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.assistTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "sizingPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.sizingPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "attachmentPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.attachmentPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "attachmentRadiusPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.attachmentRadiusPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "animalTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.animalTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode basicType */

   stat = asn1PE_PersonalDeviceUserType (pctxt, pvalue->basicType);
   if (stat != 0) return stat;

   /* encode secMark */

   stat = asn1PE_DSecond (pctxt, pvalue->secMark);
   if (stat != 0) return stat;

   /* encode msgCnt */

   stat = asn1PE_MsgCount (pctxt, pvalue->msgCnt);
   if (stat != 0) return stat;

   /* encode id */

   stat = asn1PE_TemporaryID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* encode position */

   stat = asn1PE_Position3D (pctxt, &pvalue->position);
   if (stat != 0) return stat;

   /* encode accuracy */

   stat = asn1PE_PositionalAccuracy (pctxt, &pvalue->accuracy);
   if (stat != 0) return stat;

   /* encode speed */

   stat = asn1PE_Velocity (pctxt, pvalue->speed);
   if (stat != 0) return stat;

   /* encode heading */

   stat = asn1PE_Heading (pctxt, pvalue->heading);
   if (stat != 0) return stat;

   /* encode accelSet */

   if (pvalue->m.accelSetPresent) {
      stat = asn1PE_AccelerationSet4Way (pctxt, &pvalue->accelSet);
      if (stat != 0) return stat;
   }

   /* encode pathHistory */

   if (pvalue->m.pathHistoryPresent) {
      stat = asn1PE_PathHistory (pctxt, &pvalue->pathHistory);
      if (stat != 0) return stat;
   }

   /* encode pathPrediction */

   if (pvalue->m.pathPredictionPresent) {
      stat = asn1PE_PathPrediction (pctxt, &pvalue->pathPrediction);
      if (stat != 0) return stat;
   }

   /* encode propulsion */

   if (pvalue->m.propulsionPresent) {
      stat = asn1PE_PropelledInformation (pctxt, &pvalue->propulsion);
      if (stat != 0) return stat;
   }

   /* encode useState */

   if (pvalue->m.useStatePresent) {
      stat = asn1PE_PersonalDeviceUsageState (pctxt, &pvalue->useState);
      if (stat != 0) return stat;
   }

   /* encode crossRequest */

   if (pvalue->m.crossRequestPresent) {
      stat = asn1PE_PersonalCrossingRequest (pctxt, pvalue->crossRequest);
      if (stat != 0) return stat;
   }

   /* encode crossState */

   if (pvalue->m.crossStatePresent) {
      stat = asn1PE_PersonalCrossingInProgress (pctxt, pvalue->crossState);
      if (stat != 0) return stat;
   }

   /* encode clusterSize */

   if (pvalue->m.clusterSizePresent) {
      stat = asn1PE_NumberOfParticipantsInCluster (pctxt, pvalue->clusterSize);
      if (stat != 0) return stat;
   }

   /* encode clusterRadius */

   if (pvalue->m.clusterRadiusPresent) {
      stat = asn1PE_PersonalClusterRadius (pctxt, pvalue->clusterRadius);
      if (stat != 0) return stat;
   }

   /* encode eventResponderType */

   if (pvalue->m.eventResponderTypePresent) {
      stat = asn1PE_PublicSafetyEventResponderWorkerType (pctxt, pvalue->eventResponderType);
      if (stat != 0) return stat;
   }

   /* encode activityType */

   if (pvalue->m.activityTypePresent) {
      stat = asn1PE_PublicSafetyAndRoadWorkerActivity (pctxt, &pvalue->activityType);
      if (stat != 0) return stat;
   }

   /* encode activitySubType */

   if (pvalue->m.activitySubTypePresent) {
      stat = asn1PE_PublicSafetyDirectingTrafficSubType (pctxt, &pvalue->activitySubType);
      if (stat != 0) return stat;
   }

   /* encode assistType */

   if (pvalue->m.assistTypePresent) {
      stat = asn1PE_PersonalAssistive (pctxt, &pvalue->assistType);
      if (stat != 0) return stat;
   }

   /* encode sizing */

   if (pvalue->m.sizingPresent) {
      stat = asn1PE_UserSizeAndBehaviour (pctxt, &pvalue->sizing);
      if (stat != 0) return stat;
   }

   /* encode attachment */

   if (pvalue->m.attachmentPresent) {
      stat = asn1PE_Attachment (pctxt, pvalue->attachment);
      if (stat != 0) return stat;
   }

   /* encode attachmentRadius */

   if (pvalue->m.attachmentRadiusPresent) {
      stat = asn1PE_AttachmentRadius (pctxt, pvalue->attachmentRadius);
      if (stat != 0) return stat;
   }

   /* encode animalType */

   if (pvalue->m.animalTypePresent) {
      stat = asn1PE_AnimalType (pctxt, pvalue->animalType);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_PersonalSafetyMessage_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PersonalSafetyMessage: end\n");

   return (stat);
}

EXTERN int asn1PE_Sample (OSCTXT* pctxt, Sample* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Sample: start\n");

   /* encode sampleStart */

   stat = pe_ConsUnsigned (pctxt, pvalue->sampleStart, 0, 255);
   if (stat != 0) return stat;

   /* encode sampleEnd */

   stat = pe_ConsUnsigned (pctxt, pvalue->sampleEnd, 0, 255);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Sample: end\n");

   return (stat);
}

EXTERN int asn1PE_ProbeDataManagement_term (OSCTXT* pctxt, ProbeDataManagement_term* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeDataManagement_term: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* termtime */
      case 1:
         stat = asn1PE_TermTime (pctxt, pvalue->u.termtime);
         if (stat != 0) return stat;
         break;

      /* termDistance */
      case 2:
         stat = asn1PE_TermDistance (pctxt, pvalue->u.termDistance);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeDataManagement_term: end\n");

   return (stat);
}

EXTERN int asn1PE_SnapshotTime (OSCTXT* pctxt, SnapshotTime* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SnapshotTime: start\n");

   /* encode speed1 */

   stat = asn1PE_GrossSpeed (pctxt, pvalue->speed1);
   if (stat != 0) return stat;

   /* encode time1 */

   stat = asn1PE_SecondOfTime (pctxt, pvalue->time1);
   if (stat != 0) return stat;

   /* encode speed2 */

   stat = asn1PE_GrossSpeed (pctxt, pvalue->speed2);
   if (stat != 0) return stat;

   /* encode time2 */

   stat = asn1PE_SecondOfTime (pctxt, pvalue->time2);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SnapshotTime: end\n");

   return (stat);
}

EXTERN int asn1PE_SnapshotDistance (OSCTXT* pctxt, SnapshotDistance* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SnapshotDistance: start\n");

   /* encode distance1 */

   stat = asn1PE_GrossDistance (pctxt, pvalue->distance1);
   if (stat != 0) return stat;

   /* encode speed1 */

   stat = asn1PE_GrossSpeed (pctxt, pvalue->speed1);
   if (stat != 0) return stat;

   /* encode distance2 */

   stat = asn1PE_GrossDistance (pctxt, pvalue->distance2);
   if (stat != 0) return stat;

   /* encode speed2 */

   stat = asn1PE_GrossSpeed (pctxt, pvalue->speed2);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SnapshotDistance: end\n");

   return (stat);
}

EXTERN int asn1PE_ProbeDataManagement_snapshot (OSCTXT* pctxt, ProbeDataManagement_snapshot* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeDataManagement_snapshot: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* snapshotTime */
      case 1:
         stat = asn1PE_SnapshotTime (pctxt, pvalue->u.snapshotTime);
         if (stat != 0) return stat;
         break;

      /* snapshotDistance */
      case 2:
         stat = asn1PE_SnapshotDistance (pctxt, pvalue->u.snapshotDistance);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeDataManagement_snapshot: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleStatusRequest (OSCTXT* pctxt, VehicleStatusRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatusRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "subTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.subTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "sendOnLessThenValuePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.sendOnLessThenValuePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "sendOnMoreThenValuePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.sendOnMoreThenValuePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "sendAllPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.sendAllPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode dataType */

   stat = asn1PE_VehicleStatusDeviceTypeTag (pctxt, pvalue->dataType);
   if (stat != 0) return stat;

   /* encode subType */

   if (pvalue->m.subTypePresent) {
      stat = pe_ConsUnsigned (pctxt, pvalue->subType, 1, 15);
      if (stat != 0) return stat;

   }

   /* encode sendOnLessThenValue */

   if (pvalue->m.sendOnLessThenValuePresent) {
      stat = pe_ConsInteger (pctxt, pvalue->sendOnLessThenValue, -32767, 32767);
      if (stat != 0) return stat;

   }

   /* encode sendOnMoreThenValue */

   if (pvalue->m.sendOnMoreThenValuePresent) {
      stat = pe_ConsInteger (pctxt, pvalue->sendOnMoreThenValue, -32767, 32767);
      if (stat != 0) return stat;

   }

   /* encode sendAll */

   if (pvalue->m.sendAllPresent) {
      PU_NEWFIELD (pctxt, "boolean");

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->sendAll);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatusRequest: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleStatusRequestList (OSCTXT* pctxt, VehicleStatusRequestList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatusRequestList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_VehicleStatusRequest (pctxt, ((VehicleStatusRequest*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatusRequestList: end\n");

   return (stat);
}

EXTERN int asn1PE_ProbeDataManagement_regional (OSCTXT* pctxt, ProbeDataManagement_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeDataManagement_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeDataManagement_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_ProbeDataManagement (OSCTXT* pctxt, ProbeDataManagement* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeDataManagement: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeStampPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dataElementsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataElementsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode sample */

   stat = asn1PE_Sample (pctxt, &pvalue->sample);
   if (stat != 0) return stat;

   /* encode directions */

   stat = asn1PE_HeadingSlice (pctxt, &pvalue->directions);
   if (stat != 0) return stat;

   /* encode term */

   stat = asn1PE_ProbeDataManagement_term (pctxt, &pvalue->term);
   if (stat != 0) return stat;

   /* encode snapshot */

   stat = asn1PE_ProbeDataManagement_snapshot (pctxt, &pvalue->snapshot);
   if (stat != 0) return stat;

   /* encode txInterval */

   stat = asn1PE_SecondOfTime (pctxt, pvalue->txInterval);
   if (stat != 0) return stat;

   /* encode dataElements */

   if (pvalue->m.dataElementsPresent) {
      stat = asn1PE_VehicleStatusRequestList (pctxt, &pvalue->dataElements);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_ProbeDataManagement_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeDataManagement: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleID (OSCTXT* pctxt, VehicleID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleID: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* entityID */
      case 1:
         stat = asn1PE_TemporaryID (pctxt, pvalue->u.entityID);
         if (stat != 0) return stat;
         break;

      /* stationID */
      case 2:
         stat = asn1PE_StationID (pctxt, pvalue->u.stationID);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleID: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleIdent_vehicleClass (OSCTXT* pctxt, VehicleIdent_vehicleClass* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleIdent_vehicleClass: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 2);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* vGroup */
      case 1:
         stat = asn1PE_VehicleGroupAffected (pctxt, pvalue->u.vGroup);
         if (stat != 0) return stat;
         break;

      /* rGroup */
      case 2:
         stat = asn1PE_ResponderGroupAffected (pctxt, pvalue->u.rGroup);
         if (stat != 0) return stat;
         break;

      /* rEquip */
      case 3:
         stat = asn1PE_IncidentResponseEquipment (pctxt, pvalue->u.rEquip);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleIdent_vehicleClass: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleIdent (OSCTXT* pctxt, VehicleIdent* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleIdent: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "namePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.namePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "vinPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vinPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ownerCodePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.ownerCodePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "idPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.idPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "vehicleTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehicleTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "vehicleClassPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehicleClassPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode name */

   if (pvalue->m.namePresent) {
      stat = asn1PE_DescriptiveName (pctxt, pvalue->name);
      if (stat != 0) return stat;
   }

   /* encode vin */

   if (pvalue->m.vinPresent) {
      stat = asn1PE_VINstring (pctxt, &pvalue->vin);
      if (stat != 0) return stat;
   }

   /* encode ownerCode */

   if (pvalue->m.ownerCodePresent) {
      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

      stat = pe_ConstrainedStringEx (pctxt, pvalue->ownerCode, 0, 8, 7, 7);
      if (stat != 0) return stat;
   }

   /* encode id */

   if (pvalue->m.idPresent) {
      stat = asn1PE_VehicleID (pctxt, &pvalue->id);
      if (stat != 0) return stat;
   }

   /* encode vehicleType */

   if (pvalue->m.vehicleTypePresent) {
      stat = asn1PE_VehicleType (pctxt, pvalue->vehicleType);
      if (stat != 0) return stat;
   }

   /* encode vehicleClass */

   if (pvalue->m.vehicleClassPresent) {
      stat = asn1PE_VehicleIdent_vehicleClass (pctxt, &pvalue->vehicleClass);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleIdent: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleClassification_regional (OSCTXT* pctxt, VehicleClassification_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleClassification_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleClassification_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleClassification (OSCTXT* pctxt, VehicleClassification* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleClassification: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "keyTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.keyTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rolePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rolePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iso3883Present");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.iso3883Present);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hpmsTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.hpmsTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "vehicleTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehicleTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "responseEquipPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.responseEquipPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "responderTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.responderTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "fuelTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.fuelTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode keyType */

   if (pvalue->m.keyTypePresent) {
      stat = asn1PE_BasicVehicleClass (pctxt, pvalue->keyType);
      if (stat != 0) return stat;
   }

   /* encode role */

   if (pvalue->m.rolePresent) {
      stat = asn1PE_BasicVehicleRole (pctxt, pvalue->role);
      if (stat != 0) return stat;
   }

   /* encode iso3883 */

   if (pvalue->m.iso3883Present) {
      stat = asn1PE_Iso3833VehicleType (pctxt, pvalue->iso3883);
      if (stat != 0) return stat;
   }

   /* encode hpmsType */

   if (pvalue->m.hpmsTypePresent) {
      stat = asn1PE_VehicleType (pctxt, pvalue->hpmsType);
      if (stat != 0) return stat;
   }

   /* encode vehicleType */

   if (pvalue->m.vehicleTypePresent) {
      stat = asn1PE_VehicleGroupAffected (pctxt, pvalue->vehicleType);
      if (stat != 0) return stat;
   }

   /* encode responseEquip */

   if (pvalue->m.responseEquipPresent) {
      stat = asn1PE_IncidentResponseEquipment (pctxt, pvalue->responseEquip);
      if (stat != 0) return stat;
   }

   /* encode responderType */

   if (pvalue->m.responderTypePresent) {
      stat = asn1PE_ResponderGroupAffected (pctxt, pvalue->responderType);
      if (stat != 0) return stat;
   }

   /* encode fuelType */

   if (pvalue->m.fuelTypePresent) {
      stat = asn1PE_FuelType (pctxt, pvalue->fuelType);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_VehicleClassification_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleClassification: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleSafetyExtensions (OSCTXT* pctxt, VehicleSafetyExtensions* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleSafetyExtensions: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "eventsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.eventsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pathHistoryPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pathHistoryPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pathPredictionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pathPredictionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "lightsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.lightsPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode events */

   if (pvalue->m.eventsPresent) {
      stat = asn1PE_VehicleEventFlags (pctxt, &pvalue->events);
      if (stat != 0) return stat;
   }

   /* encode pathHistory */

   if (pvalue->m.pathHistoryPresent) {
      stat = asn1PE_PathHistory (pctxt, &pvalue->pathHistory);
      if (stat != 0) return stat;
   }

   /* encode pathPrediction */

   if (pvalue->m.pathPredictionPresent) {
      stat = asn1PE_PathPrediction (pctxt, &pvalue->pathPrediction);
      if (stat != 0) return stat;
   }

   /* encode lights */

   if (pvalue->m.lightsPresent) {
      stat = asn1PE_ExteriorLights (pctxt, &pvalue->lights);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleSafetyExtensions: end\n");

   return (stat);
}

EXTERN int asn1PE_WiperSet (OSCTXT* pctxt, WiperSet* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_WiperSet: start\n");

   PU_NEWFIELD (pctxt, "statusRearPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.statusRearPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rateRearPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rateRearPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode statusFront */

   stat = asn1PE_WiperStatus (pctxt, pvalue->statusFront);
   if (stat != 0) return stat;

   /* encode rateFront */

   stat = asn1PE_WiperRate (pctxt, pvalue->rateFront);
   if (stat != 0) return stat;

   /* encode statusRear */

   if (pvalue->m.statusRearPresent) {
      stat = asn1PE_WiperStatus (pctxt, pvalue->statusRear);
      if (stat != 0) return stat;
   }

   /* encode rateRear */

   if (pvalue->m.rateRearPresent) {
      stat = asn1PE_WiperRate (pctxt, pvalue->rateRear);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_WiperSet: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleStatus_steering (OSCTXT* pctxt, VehicleStatus_steering* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatus_steering: start\n");

   PU_NEWFIELD (pctxt, "confidencePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.confidencePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "ratePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.ratePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "wheelsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.wheelsPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode angle */

   stat = asn1PE_SteeringWheelAngle (pctxt, pvalue->angle);
   if (stat != 0) return stat;

   /* encode confidence */

   if (pvalue->m.confidencePresent) {
      stat = asn1PE_SteeringWheelAngleConfidence (pctxt, pvalue->confidence);
      if (stat != 0) return stat;
   }

   /* encode rate */

   if (pvalue->m.ratePresent) {
      stat = asn1PE_SteeringWheelAngleRateOfChange (pctxt, pvalue->rate);
      if (stat != 0) return stat;
   }

   /* encode wheels */

   if (pvalue->m.wheelsPresent) {
      stat = asn1PE_DrivingWheelAngle (pctxt, pvalue->wheels);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatus_steering: end\n");

   return (stat);
}

EXTERN int asn1PE_AccelSteerYawRateConfidence (OSCTXT* pctxt, AccelSteerYawRateConfidence* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AccelSteerYawRateConfidence: start\n");

   /* encode yawRate */

   stat = asn1PE_YawRateConfidence (pctxt, pvalue->yawRate);
   if (stat != 0) return stat;

   /* encode acceleration */

   stat = asn1PE_AccelerationConfidence (pctxt, pvalue->acceleration);
   if (stat != 0) return stat;

   /* encode steeringWheelAngle */

   stat = asn1PE_SteeringWheelAngleConfidence (pctxt, pvalue->steeringWheelAngle);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_AccelSteerYawRateConfidence: end\n");

   return (stat);
}

EXTERN int asn1PE_ConfidenceSet (OSCTXT* pctxt, ConfidenceSet* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_ConfidenceSet: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "accelConfidencePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.accelConfidencePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "speedConfidencePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedConfidencePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeConfidencePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeConfidencePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "posConfidencePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.posConfidencePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "steerConfidencePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.steerConfidencePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headingConfidencePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headingConfidencePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "throttleConfidencePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.throttleConfidencePresent);

   PU_SETBITCOUNT (pctxt);

   /* encode accelConfidence */

   if (pvalue->m.accelConfidencePresent) {
      stat = asn1PE_AccelSteerYawRateConfidence (pctxt, &pvalue->accelConfidence);
      if (stat != 0) return stat;
   }

   /* encode speedConfidence */

   if (pvalue->m.speedConfidencePresent) {
      stat = asn1PE_SpeedandHeadingandThrottleConfidence (pctxt, &pvalue->speedConfidence);
      if (stat != 0) return stat;
   }

   /* encode timeConfidence */

   if (pvalue->m.timeConfidencePresent) {
      stat = asn1PE_TimeConfidence (pctxt, pvalue->timeConfidence);
      if (stat != 0) return stat;
   }

   /* encode posConfidence */

   if (pvalue->m.posConfidencePresent) {
      stat = asn1PE_PositionConfidenceSet (pctxt, &pvalue->posConfidence);
      if (stat != 0) return stat;
   }

   /* encode steerConfidence */

   if (pvalue->m.steerConfidencePresent) {
      stat = asn1PE_SteeringWheelAngleConfidence (pctxt, pvalue->steerConfidence);
      if (stat != 0) return stat;
   }

   /* encode headingConfidence */

   if (pvalue->m.headingConfidencePresent) {
      stat = asn1PE_HeadingConfidence (pctxt, pvalue->headingConfidence);
      if (stat != 0) return stat;
   }

   /* encode throttleConfidence */

   if (pvalue->m.throttleConfidencePresent) {
      stat = asn1PE_ThrottleConfidence (pctxt, pvalue->throttleConfidence);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ConfidenceSet: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleStatus_accelSets (OSCTXT* pctxt, VehicleStatus_accelSets* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatus_accelSets: start\n");

   PU_NEWFIELD (pctxt, "accel4wayPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.accel4wayPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "vertAccelThresPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vertAccelThresPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "yawRateConPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.yawRateConPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hozAccelConPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.hozAccelConPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "confidenceSetPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.confidenceSetPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode accel4way */

   if (pvalue->m.accel4wayPresent) {
      stat = asn1PE_AccelerationSet4Way (pctxt, &pvalue->accel4way);
      if (stat != 0) return stat;
   }

   /* encode vertAccelThres */

   if (pvalue->m.vertAccelThresPresent) {
      stat = asn1PE_VerticalAccelerationThreshold (pctxt, &pvalue->vertAccelThres);
      if (stat != 0) return stat;
   }

   /* encode yawRateCon */

   if (pvalue->m.yawRateConPresent) {
      stat = asn1PE_YawRateConfidence (pctxt, pvalue->yawRateCon);
      if (stat != 0) return stat;
   }

   /* encode hozAccelCon */

   if (pvalue->m.hozAccelConPresent) {
      stat = asn1PE_AccelerationConfidence (pctxt, pvalue->hozAccelCon);
      if (stat != 0) return stat;
   }

   /* encode confidenceSet */

   if (pvalue->m.confidenceSetPresent) {
      stat = asn1PE_ConfidenceSet (pctxt, &pvalue->confidenceSet);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatus_accelSets: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleStatus_object (OSCTXT* pctxt, VehicleStatus_object* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatus_object: start\n");

   /* encode obDist */

   stat = asn1PE_ObstacleDistance (pctxt, pvalue->obDist);
   if (stat != 0) return stat;

   /* encode obDirect */

   stat = asn1PE_Angle (pctxt, pvalue->obDirect);
   if (stat != 0) return stat;

   /* encode dateTime */

   stat = asn1PE_DDateTime (pctxt, &pvalue->dateTime);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatus_object: end\n");

   return (stat);
}

EXTERN int asn1PE_BumperHeights (OSCTXT* pctxt, BumperHeights* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_BumperHeights: start\n");

   /* encode front */

   stat = asn1PE_BumperHeight (pctxt, pvalue->front);
   if (stat != 0) return stat;

   /* encode rear */

   stat = asn1PE_BumperHeight (pctxt, pvalue->rear);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_BumperHeights: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleStatus_vehicleData (OSCTXT* pctxt, VehicleStatus_vehicleData* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatus_vehicleData: start\n");

   /* encode height */

   stat = asn1PE_VehicleHeight (pctxt, pvalue->height);
   if (stat != 0) return stat;

   /* encode bumpers */

   stat = asn1PE_BumperHeights (pctxt, &pvalue->bumpers);
   if (stat != 0) return stat;

   /* encode mass */

   stat = asn1PE_VehicleMass (pctxt, pvalue->mass);
   if (stat != 0) return stat;

   /* encode trailerWeight */

   stat = asn1PE_TrailerWeight (pctxt, pvalue->trailerWeight);
   if (stat != 0) return stat;

   /* encode type */

   stat = asn1PE_VehicleType (pctxt, pvalue->type);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatus_vehicleData: end\n");

   return (stat);
}

EXTERN int asn1PE_TireData (OSCTXT* pctxt, TireData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TireData: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "locationPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.locationPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pressurePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pressurePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tempPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.tempPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "wheelSensorStatusPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.wheelSensorStatusPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "wheelEndElectFaultPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.wheelEndElectFaultPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "leakageRatePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.leakageRatePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "detectionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.detectionPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode location */

   if (pvalue->m.locationPresent) {
      stat = asn1PE_TireLocation (pctxt, pvalue->location);
      if (stat != 0) return stat;
   }

   /* encode pressure */

   if (pvalue->m.pressurePresent) {
      stat = asn1PE_TirePressure (pctxt, pvalue->pressure);
      if (stat != 0) return stat;
   }

   /* encode temp */

   if (pvalue->m.tempPresent) {
      stat = asn1PE_TireTemp (pctxt, pvalue->temp);
      if (stat != 0) return stat;
   }

   /* encode wheelSensorStatus */

   if (pvalue->m.wheelSensorStatusPresent) {
      stat = asn1PE_WheelSensorStatus (pctxt, pvalue->wheelSensorStatus);
      if (stat != 0) return stat;
   }

   /* encode wheelEndElectFault */

   if (pvalue->m.wheelEndElectFaultPresent) {
      stat = asn1PE_WheelEndElectFault (pctxt, pvalue->wheelEndElectFault);
      if (stat != 0) return stat;
   }

   /* encode leakageRate */

   if (pvalue->m.leakageRatePresent) {
      stat = asn1PE_TireLeakageRate (pctxt, pvalue->leakageRate);
      if (stat != 0) return stat;
   }

   /* encode detection */

   if (pvalue->m.detectionPresent) {
      stat = asn1PE_TirePressureThresholdDetection (pctxt, pvalue->detection);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TireData: end\n");

   return (stat);
}

EXTERN int asn1PE_TireDataList (OSCTXT* pctxt, TireDataList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TireDataList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_TireData (pctxt, ((TireData*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TireDataList: end\n");

   return (stat);
}

EXTERN int asn1PE_AxleWeightSet (OSCTXT* pctxt, AxleWeightSet* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_AxleWeightSet: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "locationPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.locationPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "weightPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.weightPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode location */

   if (pvalue->m.locationPresent) {
      stat = asn1PE_AxleLocation (pctxt, pvalue->location);
      if (stat != 0) return stat;
   }

   /* encode weight */

   if (pvalue->m.weightPresent) {
      stat = asn1PE_AxleWeight (pctxt, pvalue->weight);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AxleWeightSet: end\n");

   return (stat);
}

EXTERN int asn1PE_AxleWeightList (OSCTXT* pctxt, AxleWeightList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_AxleWeightList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_AxleWeightSet (pctxt, ((AxleWeightSet*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AxleWeightList: end\n");

   return (stat);
}

EXTERN int asn1PE_J1939data (OSCTXT* pctxt, J1939data* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_J1939data: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "tiresPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.tiresPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "axlesPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.axlesPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "trailerWeightPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.trailerWeightPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "cargoWeightPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.cargoWeightPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "steeringAxleTemperaturePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.steeringAxleTemperaturePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "driveAxleLocationPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.driveAxleLocationPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "driveAxleLiftAirPressurePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.driveAxleLiftAirPressurePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "driveAxleTemperaturePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.driveAxleTemperaturePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "driveAxleLubePressurePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.driveAxleLubePressurePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "steeringAxleLubePressurePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.steeringAxleLubePressurePresent);

   PU_SETBITCOUNT (pctxt);

   /* encode tires */

   if (pvalue->m.tiresPresent) {
      stat = asn1PE_TireDataList (pctxt, &pvalue->tires);
      if (stat != 0) return stat;
   }

   /* encode axles */

   if (pvalue->m.axlesPresent) {
      stat = asn1PE_AxleWeightList (pctxt, &pvalue->axles);
      if (stat != 0) return stat;
   }

   /* encode trailerWeight */

   if (pvalue->m.trailerWeightPresent) {
      stat = asn1PE_TrailerWeight (pctxt, pvalue->trailerWeight);
      if (stat != 0) return stat;
   }

   /* encode cargoWeight */

   if (pvalue->m.cargoWeightPresent) {
      stat = asn1PE_CargoWeight (pctxt, pvalue->cargoWeight);
      if (stat != 0) return stat;
   }

   /* encode steeringAxleTemperature */

   if (pvalue->m.steeringAxleTemperaturePresent) {
      stat = asn1PE_SteeringAxleTemperature (pctxt, pvalue->steeringAxleTemperature);
      if (stat != 0) return stat;
   }

   /* encode driveAxleLocation */

   if (pvalue->m.driveAxleLocationPresent) {
      stat = asn1PE_DriveAxleLocation (pctxt, pvalue->driveAxleLocation);
      if (stat != 0) return stat;
   }

   /* encode driveAxleLiftAirPressure */

   if (pvalue->m.driveAxleLiftAirPressurePresent) {
      stat = asn1PE_DriveAxleLiftAirPressure (pctxt, pvalue->driveAxleLiftAirPressure);
      if (stat != 0) return stat;
   }

   /* encode driveAxleTemperature */

   if (pvalue->m.driveAxleTemperaturePresent) {
      stat = asn1PE_DriveAxleTemperature (pctxt, pvalue->driveAxleTemperature);
      if (stat != 0) return stat;
   }

   /* encode driveAxleLubePressure */

   if (pvalue->m.driveAxleLubePressurePresent) {
      stat = asn1PE_DriveAxleLubePressure (pctxt, pvalue->driveAxleLubePressure);
      if (stat != 0) return stat;
   }

   /* encode steeringAxleLubePressure */

   if (pvalue->m.steeringAxleLubePressurePresent) {
      stat = asn1PE_SteeringAxleLubePressure (pctxt, pvalue->steeringAxleLubePressure);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_J1939data: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleStatus_weatherReport (OSCTXT* pctxt, VehicleStatus_weatherReport* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatus_weatherReport: start\n");

   PU_NEWFIELD (pctxt, "rainRatePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rainRatePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "precipSituationPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.precipSituationPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "solarRadiationPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.solarRadiationPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "frictionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.frictionPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode isRaining */

   stat = asn1PE_EssPrecipYesNo (pctxt, pvalue->isRaining);
   if (stat != 0) return stat;

   /* encode rainRate */

   if (pvalue->m.rainRatePresent) {
      stat = asn1PE_EssPrecipRate (pctxt, pvalue->rainRate);
      if (stat != 0) return stat;
   }

   /* encode precipSituation */

   if (pvalue->m.precipSituationPresent) {
      stat = asn1PE_EssPrecipSituation (pctxt, pvalue->precipSituation);
      if (stat != 0) return stat;
   }

   /* encode solarRadiation */

   if (pvalue->m.solarRadiationPresent) {
      stat = asn1PE_EssSolarRadiation (pctxt, pvalue->solarRadiation);
      if (stat != 0) return stat;
   }

   /* encode friction */

   if (pvalue->m.frictionPresent) {
      stat = asn1PE_EssMobileFriction (pctxt, pvalue->friction);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatus_weatherReport: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleStatus (OSCTXT* pctxt, VehicleStatus* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatus: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "lightsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.lightsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "lightBarPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.lightBarPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "wipersPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.wipersPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "brakeStatusPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.brakeStatusPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "brakePressurePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.brakePressurePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "roadFrictionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.roadFrictionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "sunDataPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.sunDataPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rainDataPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rainDataPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "airTempPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.airTempPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "airPresPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.airPresPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "steeringPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.steeringPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "accelSetsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.accelSetsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "objectPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.objectPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "fullPosPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.fullPosPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "throttlePosPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.throttlePosPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "speedHeadCPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedHeadCPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "speedCPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedCPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "vehicleDataPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehicleDataPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "vehicleIdentPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehicleIdentPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "j1939dataPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.j1939dataPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "weatherReportPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.weatherReportPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "gnssStatusPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.gnssStatusPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode lights */

   if (pvalue->m.lightsPresent) {
      stat = asn1PE_ExteriorLights (pctxt, &pvalue->lights);
      if (stat != 0) return stat;
   }

   /* encode lightBar */

   if (pvalue->m.lightBarPresent) {
      stat = asn1PE_LightbarInUse (pctxt, pvalue->lightBar);
      if (stat != 0) return stat;
   }

   /* encode wipers */

   if (pvalue->m.wipersPresent) {
      stat = asn1PE_WiperSet (pctxt, &pvalue->wipers);
      if (stat != 0) return stat;
   }

   /* encode brakeStatus */

   if (pvalue->m.brakeStatusPresent) {
      stat = asn1PE_BrakeSystemStatus (pctxt, &pvalue->brakeStatus);
      if (stat != 0) return stat;
   }

   /* encode brakePressure */

   if (pvalue->m.brakePressurePresent) {
      stat = asn1PE_BrakeAppliedPressure (pctxt, pvalue->brakePressure);
      if (stat != 0) return stat;
   }

   /* encode roadFriction */

   if (pvalue->m.roadFrictionPresent) {
      stat = asn1PE_CoefficientOfFriction (pctxt, pvalue->roadFriction);
      if (stat != 0) return stat;
   }

   /* encode sunData */

   if (pvalue->m.sunDataPresent) {
      stat = asn1PE_SunSensor (pctxt, pvalue->sunData);
      if (stat != 0) return stat;
   }

   /* encode rainData */

   if (pvalue->m.rainDataPresent) {
      stat = asn1PE_RainSensor (pctxt, pvalue->rainData);
      if (stat != 0) return stat;
   }

   /* encode airTemp */

   if (pvalue->m.airTempPresent) {
      stat = asn1PE_AmbientAirTemperature (pctxt, pvalue->airTemp);
      if (stat != 0) return stat;
   }

   /* encode airPres */

   if (pvalue->m.airPresPresent) {
      stat = asn1PE_AmbientAirPressure (pctxt, pvalue->airPres);
      if (stat != 0) return stat;
   }

   /* encode steering */

   if (pvalue->m.steeringPresent) {
      stat = asn1PE_VehicleStatus_steering (pctxt, &pvalue->steering);
      if (stat != 0) return stat;
   }

   /* encode accelSets */

   if (pvalue->m.accelSetsPresent) {
      stat = asn1PE_VehicleStatus_accelSets (pctxt, &pvalue->accelSets);
      if (stat != 0) return stat;
   }

   /* encode object */

   if (pvalue->m.objectPresent) {
      stat = asn1PE_VehicleStatus_object (pctxt, &pvalue->object);
      if (stat != 0) return stat;
   }

   /* encode fullPos */

   if (pvalue->m.fullPosPresent) {
      stat = asn1PE_FullPositionVector (pctxt, &pvalue->fullPos);
      if (stat != 0) return stat;
   }

   /* encode throttlePos */

   if (pvalue->m.throttlePosPresent) {
      stat = asn1PE_ThrottlePosition (pctxt, pvalue->throttlePos);
      if (stat != 0) return stat;
   }

   /* encode speedHeadC */

   if (pvalue->m.speedHeadCPresent) {
      stat = asn1PE_SpeedandHeadingandThrottleConfidence (pctxt, &pvalue->speedHeadC);
      if (stat != 0) return stat;
   }

   /* encode speedC */

   if (pvalue->m.speedCPresent) {
      stat = asn1PE_SpeedConfidence (pctxt, pvalue->speedC);
      if (stat != 0) return stat;
   }

   /* encode vehicleData */

   if (pvalue->m.vehicleDataPresent) {
      stat = asn1PE_VehicleStatus_vehicleData (pctxt, &pvalue->vehicleData);
      if (stat != 0) return stat;
   }

   /* encode vehicleIdent */

   if (pvalue->m.vehicleIdentPresent) {
      stat = asn1PE_VehicleIdent (pctxt, &pvalue->vehicleIdent);
      if (stat != 0) return stat;
   }

   /* encode j1939data */

   if (pvalue->m.j1939dataPresent) {
      stat = asn1PE_J1939data (pctxt, &pvalue->j1939data);
      if (stat != 0) return stat;
   }

   /* encode weatherReport */

   if (pvalue->m.weatherReportPresent) {
      stat = asn1PE_VehicleStatus_weatherReport (pctxt, &pvalue->weatherReport);
      if (stat != 0) return stat;
   }

   /* encode gnssStatus */

   if (pvalue->m.gnssStatusPresent) {
      stat = asn1PE_GNSSstatus (pctxt, &pvalue->gnssStatus);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleStatus: end\n");

   return (stat);
}

EXTERN int asn1PE_Snapshot (OSCTXT* pctxt, Snapshot* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_Snapshot: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "safetyExtPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.safetyExtPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dataSetPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataSetPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode thePosition */

   stat = asn1PE_FullPositionVector (pctxt, &pvalue->thePosition);
   if (stat != 0) return stat;

   /* encode safetyExt */

   if (pvalue->m.safetyExtPresent) {
      stat = asn1PE_VehicleSafetyExtensions (pctxt, &pvalue->safetyExt);
      if (stat != 0) return stat;
   }

   /* encode dataSet */

   if (pvalue->m.dataSetPresent) {
      stat = asn1PE_VehicleStatus (pctxt, &pvalue->dataSet);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Snapshot: end\n");

   return (stat);
}

EXTERN int asn1PE_ProbeVehicleData_snapshots (OSCTXT* pctxt, ProbeVehicleData_snapshots* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeVehicleData_snapshots: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_Snapshot (pctxt, ((Snapshot*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeVehicleData_snapshots: end\n");

   return (stat);
}

EXTERN int asn1PE_ProbeVehicleData_regional (OSCTXT* pctxt, ProbeVehicleData_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeVehicleData_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeVehicleData_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_ProbeVehicleData (OSCTXT* pctxt, ProbeVehicleData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeVehicleData: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeStampPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "segNumPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.segNumPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "probeIDPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.probeIDPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode segNum */

   if (pvalue->m.segNumPresent) {
      stat = asn1PE_ProbeSegmentNumber (pctxt, pvalue->segNum);
      if (stat != 0) return stat;
   }

   /* encode probeID */

   if (pvalue->m.probeIDPresent) {
      stat = asn1PE_VehicleIdent (pctxt, &pvalue->probeID);
      if (stat != 0) return stat;
   }

   /* encode startVector */

   stat = asn1PE_FullPositionVector (pctxt, &pvalue->startVector);
   if (stat != 0) return stat;

   /* encode vehicleType */

   stat = asn1PE_VehicleClassification (pctxt, &pvalue->vehicleType);
   if (stat != 0) return stat;

   /* encode snapshots */

   stat = asn1PE_ProbeVehicleData_snapshots (pctxt, &pvalue->snapshots);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_ProbeVehicleData_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ProbeVehicleData: end\n");

   return (stat);
}

EXTERN int asn1PE_AntennaOffsetSet (OSCTXT* pctxt, AntennaOffsetSet* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AntennaOffsetSet: start\n");

   /* encode antOffsetX */

   stat = asn1PE_Offset_B12 (pctxt, pvalue->antOffsetX);
   if (stat != 0) return stat;

   /* encode antOffsetY */

   stat = asn1PE_Offset_B09 (pctxt, pvalue->antOffsetY);
   if (stat != 0) return stat;

   /* encode antOffsetZ */

   stat = asn1PE_Offset_B10 (pctxt, pvalue->antOffsetZ);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_AntennaOffsetSet: end\n");

   return (stat);
}

EXTERN int asn1PE_RTCMheader (OSCTXT* pctxt, RTCMheader* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RTCMheader: start\n");

   /* encode status */

   stat = asn1PE_GNSSstatus (pctxt, &pvalue->status);
   if (stat != 0) return stat;

   /* encode offsetSet */

   stat = asn1PE_AntennaOffsetSet (pctxt, &pvalue->offsetSet);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_RTCMheader: end\n");

   return (stat);
}

EXTERN int asn1PE_RTCMmessageList (OSCTXT* pctxt, RTCMmessageList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RTCMmessageList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(5), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_RTCMmessage (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RTCMmessageList: end\n");

   return (stat);
}

EXTERN int asn1PE_RTCMcorrections_regional (OSCTXT* pctxt, RTCMcorrections_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RTCMcorrections_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RTCMcorrections_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_RTCMcorrections (OSCTXT* pctxt, RTCMcorrections* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_RTCMcorrections: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeStampPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "anchorPointPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.anchorPointPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rtcmHeaderPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rtcmHeaderPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode msgCnt */

   stat = asn1PE_MsgCount (pctxt, pvalue->msgCnt);
   if (stat != 0) return stat;

   /* encode rev */

   stat = asn1PE_RTCM_Revision (pctxt, pvalue->rev);
   if (stat != 0) return stat;

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode anchorPoint */

   if (pvalue->m.anchorPointPresent) {
      stat = asn1PE_FullPositionVector (pctxt, &pvalue->anchorPoint);
      if (stat != 0) return stat;
   }

   /* encode rtcmHeader */

   if (pvalue->m.rtcmHeaderPresent) {
      stat = asn1PE_RTCMheader (pctxt, &pvalue->rtcmHeader);
      if (stat != 0) return stat;
   }

   /* encode msgs */

   stat = asn1PE_RTCMmessageList (pctxt, &pvalue->msgs);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RTCMcorrections_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RTCMcorrections: end\n");

   return (stat);
}

EXTERN int asn1PE_EnabledLaneList (OSCTXT* pctxt, EnabledLaneList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_EnabledLaneList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_LaneID (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_EnabledLaneList: end\n");

   return (stat);
}

EXTERN int asn1PE_TimeChangeDetails (OSCTXT* pctxt, TimeChangeDetails* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeChangeDetails: start\n");

   PU_NEWFIELD (pctxt, "startTimePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.startTimePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "maxEndTimePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.maxEndTimePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "likelyTimePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.likelyTimePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "confidencePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.confidencePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "nextTimePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.nextTimePresent);

   PU_SETBITCOUNT (pctxt);

   /* encode startTime */

   if (pvalue->m.startTimePresent) {
      stat = asn1PE_TimeMark (pctxt, pvalue->startTime);
      if (stat != 0) return stat;
   }

   /* encode minEndTime */

   stat = asn1PE_TimeMark (pctxt, pvalue->minEndTime);
   if (stat != 0) return stat;

   /* encode maxEndTime */

   if (pvalue->m.maxEndTimePresent) {
      stat = asn1PE_TimeMark (pctxt, pvalue->maxEndTime);
      if (stat != 0) return stat;
   }

   /* encode likelyTime */

   if (pvalue->m.likelyTimePresent) {
      stat = asn1PE_TimeMark (pctxt, pvalue->likelyTime);
      if (stat != 0) return stat;
   }

   /* encode confidence */

   if (pvalue->m.confidencePresent) {
      stat = asn1PE_TimeIntervalConfidence (pctxt, pvalue->confidence);
      if (stat != 0) return stat;
   }

   /* encode nextTime */

   if (pvalue->m.nextTimePresent) {
      stat = asn1PE_TimeMark (pctxt, pvalue->nextTime);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TimeChangeDetails: end\n");

   return (stat);
}

EXTERN int asn1PE_AdvisorySpeed_regional (OSCTXT* pctxt, AdvisorySpeed_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_AdvisorySpeed_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AdvisorySpeed_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_AdvisorySpeed (OSCTXT* pctxt, AdvisorySpeed* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_AdvisorySpeed: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "speedPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "confidencePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.confidencePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "distancePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.distancePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "class_Present");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.class_Present);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode type */

   stat = asn1PE_AdvisorySpeedType (pctxt, pvalue->type);
   if (stat != 0) return stat;

   /* encode speed */

   if (pvalue->m.speedPresent) {
      stat = asn1PE_SpeedAdvice (pctxt, pvalue->speed);
      if (stat != 0) return stat;
   }

   /* encode confidence */

   if (pvalue->m.confidencePresent) {
      stat = asn1PE_SpeedConfidence (pctxt, pvalue->confidence);
      if (stat != 0) return stat;
   }

   /* encode distance */

   if (pvalue->m.distancePresent) {
      stat = asn1PE_ZoneLength (pctxt, pvalue->distance);
      if (stat != 0) return stat;
   }

   /* encode class_ */

   if (pvalue->m.class_Present) {
      stat = asn1PE_RestrictionClassID (pctxt, pvalue->class_);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_AdvisorySpeed_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AdvisorySpeed: end\n");

   return (stat);
}

EXTERN int asn1PE_AdvisorySpeedList (OSCTXT* pctxt, AdvisorySpeedList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_AdvisorySpeedList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_AdvisorySpeed (pctxt, ((AdvisorySpeed*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AdvisorySpeedList: end\n");

   return (stat);
}

EXTERN int asn1PE_MovementEvent_regional (OSCTXT* pctxt, MovementEvent_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_MovementEvent_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MovementEvent_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_MovementEvent (OSCTXT* pctxt, MovementEvent* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_MovementEvent: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timingPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timingPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "speedsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode eventState */

   stat = asn1PE_MovementPhaseState (pctxt, pvalue->eventState);
   if (stat != 0) return stat;

   /* encode timing */

   if (pvalue->m.timingPresent) {
      stat = asn1PE_TimeChangeDetails (pctxt, &pvalue->timing);
      if (stat != 0) return stat;
   }

   /* encode speeds */

   if (pvalue->m.speedsPresent) {
      stat = asn1PE_AdvisorySpeedList (pctxt, &pvalue->speeds);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_MovementEvent_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MovementEvent: end\n");

   return (stat);
}

EXTERN int asn1PE_MovementEventList (OSCTXT* pctxt, MovementEventList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_MovementEventList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_MovementEvent (pctxt, ((MovementEvent*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MovementEventList: end\n");

   return (stat);
}

EXTERN int asn1PE_ConnectionManeuverAssist_regional (OSCTXT* pctxt, ConnectionManeuverAssist_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_ConnectionManeuverAssist_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ConnectionManeuverAssist_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_ConnectionManeuverAssist (OSCTXT* pctxt, ConnectionManeuverAssist* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_ConnectionManeuverAssist: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "queueLengthPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.queueLengthPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "availableStorageLengthPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.availableStorageLengthPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "waitOnStopPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.waitOnStopPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "pedBicycleDetectPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.pedBicycleDetectPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode connectionID */

   stat = asn1PE_LaneConnectionID (pctxt, pvalue->connectionID);
   if (stat != 0) return stat;

   /* encode queueLength */

   if (pvalue->m.queueLengthPresent) {
      stat = asn1PE_ZoneLength (pctxt, pvalue->queueLength);
      if (stat != 0) return stat;
   }

   /* encode availableStorageLength */

   if (pvalue->m.availableStorageLengthPresent) {
      stat = asn1PE_ZoneLength (pctxt, pvalue->availableStorageLength);
      if (stat != 0) return stat;
   }

   /* encode waitOnStop */

   if (pvalue->m.waitOnStopPresent) {
      stat = asn1PE_WaitOnStopline (pctxt, pvalue->waitOnStop);
      if (stat != 0) return stat;
   }

   /* encode pedBicycleDetect */

   if (pvalue->m.pedBicycleDetectPresent) {
      stat = asn1PE_PedestrianBicycleDetect (pctxt, pvalue->pedBicycleDetect);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_ConnectionManeuverAssist_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ConnectionManeuverAssist: end\n");

   return (stat);
}

EXTERN int asn1PE_ManeuverAssistList (OSCTXT* pctxt, ManeuverAssistList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_ManeuverAssistList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_ConnectionManeuverAssist (pctxt, ((ConnectionManeuverAssist*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ManeuverAssistList: end\n");

   return (stat);
}

EXTERN int asn1PE_MovementState_regional (OSCTXT* pctxt, MovementState_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_MovementState_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MovementState_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_MovementState (OSCTXT* pctxt, MovementState* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_MovementState: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "movementNamePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.movementNamePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "maneuverAssistListPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.maneuverAssistListPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode movementName */

   if (pvalue->m.movementNamePresent) {
      stat = asn1PE_DescriptiveName (pctxt, pvalue->movementName);
      if (stat != 0) return stat;
   }

   /* encode signalGroup */

   stat = asn1PE_SignalGroupID (pctxt, pvalue->signalGroup);
   if (stat != 0) return stat;

   /* encode state_time_speed */

   stat = asn1PE_MovementEventList (pctxt, &pvalue->state_time_speed);
   if (stat != 0) return stat;

   /* encode maneuverAssistList */

   if (pvalue->m.maneuverAssistListPresent) {
      stat = asn1PE_ManeuverAssistList (pctxt, &pvalue->maneuverAssistList);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_MovementState_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MovementState: end\n");

   return (stat);
}

EXTERN int asn1PE_MovementList (OSCTXT* pctxt, MovementList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_MovementList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_MovementState (pctxt, ((MovementState*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_MovementList: end\n");

   return (stat);
}

EXTERN int asn1PE_IntersectionState_regional (OSCTXT* pctxt, IntersectionState_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionState_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionState_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_IntersectionState (OSCTXT* pctxt, IntersectionState* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionState: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "namePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.namePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "moyPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.moyPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeStampPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "enabledLanesPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.enabledLanesPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "maneuverAssistListPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.maneuverAssistListPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode name */

   if (pvalue->m.namePresent) {
      stat = asn1PE_DescriptiveName (pctxt, pvalue->name);
      if (stat != 0) return stat;
   }

   /* encode id */

   stat = asn1PE_IntersectionReferenceID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* encode revision */

   stat = asn1PE_MsgCount (pctxt, pvalue->revision);
   if (stat != 0) return stat;

   /* encode status */

   stat = asn1PE_IntersectionStatusObject (pctxt, &pvalue->status);
   if (stat != 0) return stat;

   /* encode moy */

   if (pvalue->m.moyPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->moy);
      if (stat != 0) return stat;
   }

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_DSecond (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode enabledLanes */

   if (pvalue->m.enabledLanesPresent) {
      stat = asn1PE_EnabledLaneList (pctxt, &pvalue->enabledLanes);
      if (stat != 0) return stat;
   }

   /* encode states */

   stat = asn1PE_MovementList (pctxt, &pvalue->states);
   if (stat != 0) return stat;

   /* encode maneuverAssistList */

   if (pvalue->m.maneuverAssistListPresent) {
      stat = asn1PE_ManeuverAssistList (pctxt, &pvalue->maneuverAssistList);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_IntersectionState_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionState: end\n");

   return (stat);
}

EXTERN int asn1PE_IntersectionStateList (OSCTXT* pctxt, IntersectionStateList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionStateList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_IntersectionState (pctxt, ((IntersectionState*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionStateList: end\n");

   return (stat);
}

EXTERN int asn1PE_SPAT_regional (OSCTXT* pctxt, SPAT_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SPAT_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SPAT_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_SPAT (OSCTXT* pctxt, SPAT* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_SPAT: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeStampPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "namePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.namePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode name */

   if (pvalue->m.namePresent) {
      stat = asn1PE_DescriptiveName (pctxt, pvalue->name);
      if (stat != 0) return stat;
   }

   /* encode intersections */

   stat = asn1PE_IntersectionStateList (pctxt, &pvalue->intersections);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_SPAT_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SPAT: end\n");

   return (stat);
}

EXTERN int asn1PE_IntersectionAccessPoint (OSCTXT* pctxt, IntersectionAccessPoint* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionAccessPoint: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 3);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 2);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* lane */
         case 1:
            stat = asn1PE_LaneID (pctxt, pvalue->u.lane);
            if (stat != 0) return stat;
            break;

         /* approach */
         case 2:
            stat = asn1PE_ApproachID (pctxt, pvalue->u.approach);
            if (stat != 0) return stat;
            break;

         /* connection */
         case 3:
            stat = asn1PE_LaneConnectionID (pctxt, pvalue->u.connection);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_IntersectionAccessPoint: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalRequest_regional (OSCTXT* pctxt, SignalRequest_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequest_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequest_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalRequest (OSCTXT* pctxt, SignalRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "outBoundLanePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.outBoundLanePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode id */

   stat = asn1PE_IntersectionReferenceID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* encode requestID */

   stat = asn1PE_RequestID (pctxt, pvalue->requestID);
   if (stat != 0) return stat;

   /* encode requestType */

   stat = asn1PE_PriorityRequestType (pctxt, pvalue->requestType);
   if (stat != 0) return stat;

   /* encode inBoundLane */

   stat = asn1PE_IntersectionAccessPoint (pctxt, &pvalue->inBoundLane);
   if (stat != 0) return stat;

   /* encode outBoundLane */

   if (pvalue->m.outBoundLanePresent) {
      stat = asn1PE_IntersectionAccessPoint (pctxt, &pvalue->outBoundLane);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_SignalRequest_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequest: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalRequestPackage_regional (OSCTXT* pctxt, SignalRequestPackage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequestPackage_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequestPackage_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalRequestPackage (OSCTXT* pctxt, SignalRequestPackage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequestPackage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minutePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.minutePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "secondPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.secondPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "durationPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.durationPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode request */

   stat = asn1PE_SignalRequest (pctxt, &pvalue->request);
   if (stat != 0) return stat;

   /* encode minute */

   if (pvalue->m.minutePresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->minute);
      if (stat != 0) return stat;
   }

   /* encode second */

   if (pvalue->m.secondPresent) {
      stat = asn1PE_DSecond (pctxt, pvalue->second);
      if (stat != 0) return stat;
   }

   /* encode duration */

   if (pvalue->m.durationPresent) {
      stat = asn1PE_DSecond (pctxt, pvalue->duration);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_SignalRequestPackage_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequestPackage: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalRequestList (OSCTXT* pctxt, SignalRequestList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequestList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_SignalRequestPackage (pctxt, ((SignalRequestPackage*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequestList: end\n");

   return (stat);
}

EXTERN int asn1PE_RequestorType (OSCTXT* pctxt, RequestorType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestorType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "subrolePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.subrolePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "requestPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.requestPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "iso3883Present");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.iso3883Present);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "hpmsTypePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.hpmsTypePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode role */

   stat = asn1PE_BasicVehicleRole (pctxt, pvalue->role);
   if (stat != 0) return stat;

   /* encode subrole */

   if (pvalue->m.subrolePresent) {
      stat = asn1PE_RequestSubRole (pctxt, pvalue->subrole);
      if (stat != 0) return stat;
   }

   /* encode request */

   if (pvalue->m.requestPresent) {
      stat = asn1PE_RequestImportanceLevel (pctxt, pvalue->request);
      if (stat != 0) return stat;
   }

   /* encode iso3883 */

   if (pvalue->m.iso3883Present) {
      stat = asn1PE_Iso3833VehicleType (pctxt, pvalue->iso3883);
      if (stat != 0) return stat;
   }

   /* encode hpmsType */

   if (pvalue->m.hpmsTypePresent) {
      stat = asn1PE_VehicleType (pctxt, pvalue->hpmsType);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestorType: end\n");

   return (stat);
}

EXTERN int asn1PE_RequestorPositionVector (OSCTXT* pctxt, RequestorPositionVector* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestorPositionVector: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headingPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headingPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "speedPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode position */

   stat = asn1PE_Position3D (pctxt, &pvalue->position);
   if (stat != 0) return stat;

   /* encode heading */

   if (pvalue->m.headingPresent) {
      stat = asn1PE_Angle (pctxt, pvalue->heading);
      if (stat != 0) return stat;
   }

   /* encode speed */

   if (pvalue->m.speedPresent) {
      stat = asn1PE_TransmissionAndSpeed (pctxt, &pvalue->speed);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestorPositionVector: end\n");

   return (stat);
}

EXTERN int asn1PE_RequestorDescription_regional (OSCTXT* pctxt, RequestorDescription_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestorDescription_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestorDescription_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_RequestorDescription (OSCTXT* pctxt, RequestorDescription* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestorDescription: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "typePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.typePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "positionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.positionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "namePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.namePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "routeNamePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.routeNamePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transitStatusPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.transitStatusPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transitOccupancyPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.transitOccupancyPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "transitSchedulePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.transitSchedulePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode id */

   stat = asn1PE_VehicleID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* encode type */

   if (pvalue->m.typePresent) {
      stat = asn1PE_RequestorType (pctxt, &pvalue->type);
      if (stat != 0) return stat;
   }

   /* encode position */

   if (pvalue->m.positionPresent) {
      stat = asn1PE_RequestorPositionVector (pctxt, &pvalue->position);
      if (stat != 0) return stat;
   }

   /* encode name */

   if (pvalue->m.namePresent) {
      stat = asn1PE_DescriptiveName (pctxt, pvalue->name);
      if (stat != 0) return stat;
   }

   /* encode routeName */

   if (pvalue->m.routeNamePresent) {
      stat = asn1PE_DescriptiveName (pctxt, pvalue->routeName);
      if (stat != 0) return stat;
   }

   /* encode transitStatus */

   if (pvalue->m.transitStatusPresent) {
      stat = asn1PE_TransitVehicleStatus (pctxt, &pvalue->transitStatus);
      if (stat != 0) return stat;
   }

   /* encode transitOccupancy */

   if (pvalue->m.transitOccupancyPresent) {
      stat = asn1PE_TransitVehicleOccupancy (pctxt, pvalue->transitOccupancy);
      if (stat != 0) return stat;
   }

   /* encode transitSchedule */

   if (pvalue->m.transitSchedulePresent) {
      stat = asn1PE_DeltaTime (pctxt, pvalue->transitSchedule);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RequestorDescription_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RequestorDescription: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalRequestMessage_regional (OSCTXT* pctxt, SignalRequestMessage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequestMessage_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequestMessage_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalRequestMessage (OSCTXT* pctxt, SignalRequestMessage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequestMessage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeStampPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "sequenceNumberPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.sequenceNumberPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "requestsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.requestsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode second */

   stat = asn1PE_DSecond (pctxt, pvalue->second);
   if (stat != 0) return stat;

   /* encode sequenceNumber */

   if (pvalue->m.sequenceNumberPresent) {
      stat = asn1PE_MsgCount (pctxt, pvalue->sequenceNumber);
      if (stat != 0) return stat;
   }

   /* encode requests */

   if (pvalue->m.requestsPresent) {
      stat = asn1PE_SignalRequestList (pctxt, &pvalue->requests);
      if (stat != 0) return stat;
   }

   /* encode requestor */

   stat = asn1PE_RequestorDescription (pctxt, &pvalue->requestor);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_SignalRequestMessage_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequestMessage: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalRequesterInfo (OSCTXT* pctxt, SignalRequesterInfo* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequesterInfo: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rolePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rolePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "typeDataPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.typeDataPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode id */

   stat = asn1PE_VehicleID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* encode request */

   stat = asn1PE_RequestID (pctxt, pvalue->request);
   if (stat != 0) return stat;

   /* encode sequenceNumber */

   stat = asn1PE_MsgCount (pctxt, pvalue->sequenceNumber);
   if (stat != 0) return stat;

   /* encode role */

   if (pvalue->m.rolePresent) {
      stat = asn1PE_BasicVehicleRole (pctxt, pvalue->role);
      if (stat != 0) return stat;
   }

   /* encode typeData */

   if (pvalue->m.typeDataPresent) {
      stat = asn1PE_RequestorType (pctxt, &pvalue->typeData);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalRequesterInfo: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalStatusPackage_regional (OSCTXT* pctxt, SignalStatusPackage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatusPackage_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatusPackage_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalStatusPackage (OSCTXT* pctxt, SignalStatusPackage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatusPackage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "requesterPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.requesterPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "outboundOnPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.outboundOnPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "minutePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.minutePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "secondPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.secondPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "durationPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.durationPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode requester */

   if (pvalue->m.requesterPresent) {
      stat = asn1PE_SignalRequesterInfo (pctxt, &pvalue->requester);
      if (stat != 0) return stat;
   }

   /* encode inboundOn */

   stat = asn1PE_IntersectionAccessPoint (pctxt, &pvalue->inboundOn);
   if (stat != 0) return stat;

   /* encode outboundOn */

   if (pvalue->m.outboundOnPresent) {
      stat = asn1PE_IntersectionAccessPoint (pctxt, &pvalue->outboundOn);
      if (stat != 0) return stat;
   }

   /* encode minute */

   if (pvalue->m.minutePresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->minute);
      if (stat != 0) return stat;
   }

   /* encode second */

   if (pvalue->m.secondPresent) {
      stat = asn1PE_DSecond (pctxt, pvalue->second);
      if (stat != 0) return stat;
   }

   /* encode duration */

   if (pvalue->m.durationPresent) {
      stat = asn1PE_DSecond (pctxt, pvalue->duration);
      if (stat != 0) return stat;
   }

   /* encode status */

   stat = asn1PE_PrioritizationResponseStatus (pctxt, pvalue->status);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_SignalStatusPackage_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatusPackage: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalStatusPackageList (OSCTXT* pctxt, SignalStatusPackageList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatusPackageList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_SignalStatusPackage (pctxt, ((SignalStatusPackage*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatusPackageList: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalStatus_regional (OSCTXT* pctxt, SignalStatus_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatus_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatus_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalStatus (OSCTXT* pctxt, SignalStatus* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatus: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode sequenceNumber */

   stat = asn1PE_MsgCount (pctxt, pvalue->sequenceNumber);
   if (stat != 0) return stat;

   /* encode id */

   stat = asn1PE_IntersectionReferenceID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* encode sigStatus */

   stat = asn1PE_SignalStatusPackageList (pctxt, &pvalue->sigStatus);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_SignalStatus_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatus: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalStatusList (OSCTXT* pctxt, SignalStatusList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatusList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_SignalStatus (pctxt, ((SignalStatus*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatusList: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalStatusMessage_regional (OSCTXT* pctxt, SignalStatusMessage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatusMessage_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatusMessage_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_SignalStatusMessage (OSCTXT* pctxt, SignalStatusMessage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatusMessage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeStampPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "sequenceNumberPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.sequenceNumberPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode second */

   stat = asn1PE_DSecond (pctxt, pvalue->second);
   if (stat != 0) return stat;

   /* encode sequenceNumber */

   if (pvalue->m.sequenceNumberPresent) {
      stat = asn1PE_MsgCount (pctxt, pvalue->sequenceNumber);
      if (stat != 0) return stat;
   }

   /* encode status */

   stat = asn1PE_SignalStatusList (pctxt, &pvalue->status);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_SignalStatusMessage_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SignalStatusMessage: end\n");

   return (stat);
}

EXTERN int asn1PE_RoadSignID (OSCTXT* pctxt, RoadSignID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSignID: start\n");

   PU_NEWFIELD (pctxt, "mutcdCodePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.mutcdCodePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "crcPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.crcPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode position */

   stat = asn1PE_Position3D (pctxt, &pvalue->position);
   if (stat != 0) return stat;

   /* encode viewAngle */

   stat = asn1PE_HeadingSlice (pctxt, &pvalue->viewAngle);
   if (stat != 0) return stat;

   /* encode mutcdCode */

   if (pvalue->m.mutcdCodePresent) {
      stat = asn1PE_MUTCDCode (pctxt, pvalue->mutcdCode);
      if (stat != 0) return stat;
   }

   /* encode crc */

   if (pvalue->m.crcPresent) {
      stat = asn1PE_MsgCRC (pctxt, &pvalue->crc);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RoadSignID: end\n");

   return (stat);
}

EXTERN int asn1PE_TravelerDataFrame_msgId (OSCTXT* pctxt, TravelerDataFrame_msgId* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerDataFrame_msgId: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* furtherInfoID */
      case 1:
         stat = asn1PE_FurtherInfoID (pctxt, pvalue->u.furtherInfoID);
         if (stat != 0) return stat;
         break;

      /* roadSignID */
      case 2:
         stat = asn1PE_RoadSignID (pctxt, pvalue->u.roadSignID);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerDataFrame_msgId: end\n");

   return (stat);
}

EXTERN int asn1PE_Node_LL_24B (OSCTXT* pctxt, Node_LL_24B* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_LL_24B: start\n");

   /* encode lon */

   stat = asn1PE_OffsetLL_B12 (pctxt, pvalue->lon);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_OffsetLL_B12 (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_LL_24B: end\n");

   return (stat);
}

EXTERN int asn1PE_Node_LL_28B (OSCTXT* pctxt, Node_LL_28B* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_LL_28B: start\n");

   /* encode lon */

   stat = asn1PE_OffsetLL_B14 (pctxt, pvalue->lon);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_OffsetLL_B14 (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_LL_28B: end\n");

   return (stat);
}

EXTERN int asn1PE_Node_LL_32B (OSCTXT* pctxt, Node_LL_32B* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_LL_32B: start\n");

   /* encode lon */

   stat = asn1PE_OffsetLL_B16 (pctxt, pvalue->lon);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_OffsetLL_B16 (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_LL_32B: end\n");

   return (stat);
}

EXTERN int asn1PE_Node_LL_36B (OSCTXT* pctxt, Node_LL_36B* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_LL_36B: start\n");

   /* encode lon */

   stat = asn1PE_OffsetLL_B18 (pctxt, pvalue->lon);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_OffsetLL_B18 (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_LL_36B: end\n");

   return (stat);
}

EXTERN int asn1PE_Node_LL_44B (OSCTXT* pctxt, Node_LL_44B* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_LL_44B: start\n");

   /* encode lon */

   stat = asn1PE_OffsetLL_B22 (pctxt, pvalue->lon);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_OffsetLL_B22 (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_LL_44B: end\n");

   return (stat);
}

EXTERN int asn1PE_Node_LL_48B (OSCTXT* pctxt, Node_LL_48B* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_LL_48B: start\n");

   /* encode lon */

   stat = asn1PE_OffsetLL_B24 (pctxt, pvalue->lon);
   if (stat != 0) return stat;

   /* encode lat */

   stat = asn1PE_OffsetLL_B24 (pctxt, pvalue->lat);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Node_LL_48B: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeOffsetPointLL (OSCTXT* pctxt, NodeOffsetPointLL* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeOffsetPointLL: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 3);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* node_LL1 */
      case 1:
         stat = asn1PE_Node_LL_24B (pctxt, pvalue->u.node_LL1);
         if (stat != 0) return stat;
         break;

      /* node_LL2 */
      case 2:
         stat = asn1PE_Node_LL_28B (pctxt, pvalue->u.node_LL2);
         if (stat != 0) return stat;
         break;

      /* node_LL3 */
      case 3:
         stat = asn1PE_Node_LL_32B (pctxt, pvalue->u.node_LL3);
         if (stat != 0) return stat;
         break;

      /* node_LL4 */
      case 4:
         stat = asn1PE_Node_LL_36B (pctxt, pvalue->u.node_LL4);
         if (stat != 0) return stat;
         break;

      /* node_LL5 */
      case 5:
         stat = asn1PE_Node_LL_44B (pctxt, pvalue->u.node_LL5);
         if (stat != 0) return stat;
         break;

      /* node_LL6 */
      case 6:
         stat = asn1PE_Node_LL_48B (pctxt, pvalue->u.node_LL6);
         if (stat != 0) return stat;
         break;

      /* node_LatLon */
      case 7:
         stat = asn1PE_Node_LLmD_64b (pctxt, pvalue->u.node_LatLon);
         if (stat != 0) return stat;
         break;

      /* regional */
      case 8:
         stat = asn1PE_RegionalExtension (pctxt, pvalue->u.regional);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeOffsetPointLL: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeAttributeLLList (OSCTXT* pctxt, NodeAttributeLLList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeLLList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_NodeAttributeLL (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeLLList: end\n");

   return (stat);
}

EXTERN int asn1PE_SegmentAttributeLLList (OSCTXT* pctxt, SegmentAttributeLLList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SegmentAttributeLLList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_SegmentAttributeLL (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SegmentAttributeLLList: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeAttributeSetLL_regional (OSCTXT* pctxt, NodeAttributeSetLL_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeSetLL_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeSetLL_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeAttributeSetLL (OSCTXT* pctxt, NodeAttributeSetLL* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeSetLL: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "localNodePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.localNodePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "disabledPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.disabledPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "enabledPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.enabledPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dataPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dWidthPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dWidthPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "dElevationPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.dElevationPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode localNode */

   if (pvalue->m.localNodePresent) {
      stat = asn1PE_NodeAttributeLLList (pctxt, &pvalue->localNode);
      if (stat != 0) return stat;
   }

   /* encode disabled */

   if (pvalue->m.disabledPresent) {
      stat = asn1PE_SegmentAttributeLLList (pctxt, &pvalue->disabled);
      if (stat != 0) return stat;
   }

   /* encode enabled */

   if (pvalue->m.enabledPresent) {
      stat = asn1PE_SegmentAttributeLLList (pctxt, &pvalue->enabled);
      if (stat != 0) return stat;
   }

   /* encode data */

   if (pvalue->m.dataPresent) {
      stat = asn1PE_LaneDataAttributeList (pctxt, &pvalue->data);
      if (stat != 0) return stat;
   }

   /* encode dWidth */

   if (pvalue->m.dWidthPresent) {
      stat = asn1PE_Offset_B10 (pctxt, pvalue->dWidth);
      if (stat != 0) return stat;
   }

   /* encode dElevation */

   if (pvalue->m.dElevationPresent) {
      stat = asn1PE_Offset_B10 (pctxt, pvalue->dElevation);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_NodeAttributeSetLL_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeAttributeSetLL: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeLL (OSCTXT* pctxt, NodeLL* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeLL: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "attributesPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.attributesPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode delta */

   stat = asn1PE_NodeOffsetPointLL (pctxt, &pvalue->delta);
   if (stat != 0) return stat;

   /* encode attributes */

   if (pvalue->m.attributesPresent) {
      stat = asn1PE_NodeAttributeSetLL (pctxt, &pvalue->attributes);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeLL: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeSetLL (OSCTXT* pctxt, NodeSetLL* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeSetLL: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(63), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_NodeLL (pctxt, ((NodeLL*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeSetLL: end\n");

   return (stat);
}

EXTERN int asn1PE_NodeListLL (OSCTXT* pctxt, NodeListLL* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeListLL: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 1);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* nodes */
         case 1:
            stat = asn1PE_NodeSetLL (pctxt, pvalue->u.nodes);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NodeListLL: end\n");

   return (stat);
}

EXTERN int asn1PE_OffsetSystem_offset (OSCTXT* pctxt, OffsetSystem_offset* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetSystem_offset: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* xy */
      case 1:
         stat = asn1PE_NodeListXY (pctxt, pvalue->u.xy);
         if (stat != 0) return stat;
         break;

      /* ll */
      case 2:
         stat = asn1PE_NodeListLL (pctxt, pvalue->u.ll);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetSystem_offset: end\n");

   return (stat);
}

EXTERN int asn1PE_OffsetSystem (OSCTXT* pctxt, OffsetSystem* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetSystem: start\n");

   PU_NEWFIELD (pctxt, "scalePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.scalePresent);

   PU_SETBITCOUNT (pctxt);

   /* encode scale */

   if (pvalue->m.scalePresent) {
      stat = asn1PE_Zoom (pctxt, pvalue->scale);
      if (stat != 0) return stat;
   }

   /* encode offset */

   stat = asn1PE_OffsetSystem_offset (pctxt, &pvalue->offset);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_OffsetSystem: end\n");

   return (stat);
}

EXTERN int asn1PE_Circle (OSCTXT* pctxt, Circle* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Circle: start\n");

   /* encode center */

   stat = asn1PE_Position3D (pctxt, &pvalue->center);
   if (stat != 0) return stat;

   /* encode radius */

   stat = asn1PE_Radius_B12 (pctxt, pvalue->radius);
   if (stat != 0) return stat;

   /* encode units */

   stat = asn1PE_DistanceUnits (pctxt, pvalue->units);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_Circle: end\n");

   return (stat);
}

EXTERN int asn1PE_GeometricProjection_regional (OSCTXT* pctxt, GeometricProjection_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_GeometricProjection_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GeometricProjection_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_GeometricProjection (OSCTXT* pctxt, GeometricProjection* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_GeometricProjection: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "extentPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.extentPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "laneWidthPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.laneWidthPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode direction */

   stat = asn1PE_HeadingSlice (pctxt, &pvalue->direction);
   if (stat != 0) return stat;

   /* encode extent */

   if (pvalue->m.extentPresent) {
      stat = asn1PE_Extent (pctxt, pvalue->extent);
      if (stat != 0) return stat;
   }

   /* encode laneWidth */

   if (pvalue->m.laneWidthPresent) {
      stat = asn1PE_LaneWidth (pctxt, pvalue->laneWidth);
      if (stat != 0) return stat;
   }

   /* encode circle */

   stat = asn1PE_Circle (pctxt, &pvalue->circle);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_GeometricProjection_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GeometricProjection: end\n");

   return (stat);
}

EXTERN int asn1PE_ShapePointSet (OSCTXT* pctxt, ShapePointSet* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_ShapePointSet: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "anchorPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.anchorPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "laneWidthPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.laneWidthPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "directionalityPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.directionalityPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode anchor */

   if (pvalue->m.anchorPresent) {
      stat = asn1PE_Position3D (pctxt, &pvalue->anchor);
      if (stat != 0) return stat;
   }

   /* encode laneWidth */

   if (pvalue->m.laneWidthPresent) {
      stat = asn1PE_LaneWidth (pctxt, pvalue->laneWidth);
      if (stat != 0) return stat;
   }

   /* encode directionality */

   if (pvalue->m.directionalityPresent) {
      stat = asn1PE_DirectionOfUse (pctxt, pvalue->directionality);
      if (stat != 0) return stat;
   }

   /* encode nodeList */

   stat = asn1PE_NodeListXY (pctxt, &pvalue->nodeList);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ShapePointSet: end\n");

   return (stat);
}

EXTERN int asn1PE_RegionOffsets (OSCTXT* pctxt, RegionOffsets* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RegionOffsets: start\n");

   PU_NEWFIELD (pctxt, "zOffsetPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.zOffsetPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode xOffset */

   stat = asn1PE_OffsetLL_B16 (pctxt, pvalue->xOffset);
   if (stat != 0) return stat;

   /* encode yOffset */

   stat = asn1PE_OffsetLL_B16 (pctxt, pvalue->yOffset);
   if (stat != 0) return stat;

   /* encode zOffset */

   if (pvalue->m.zOffsetPresent) {
      stat = asn1PE_OffsetLL_B16 (pctxt, pvalue->zOffset);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RegionOffsets: end\n");

   return (stat);
}

EXTERN int asn1PE_RegionList (OSCTXT* pctxt, RegionList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RegionList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionOffsets (pctxt, ((RegionOffsets*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RegionList: end\n");

   return (stat);
}

EXTERN int asn1PE_RegionPointSet (OSCTXT* pctxt, RegionPointSet* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_RegionPointSet: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "anchorPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.anchorPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "scalePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.scalePresent);

   PU_SETBITCOUNT (pctxt);

   /* encode anchor */

   if (pvalue->m.anchorPresent) {
      stat = asn1PE_Position3D (pctxt, &pvalue->anchor);
      if (stat != 0) return stat;
   }

   /* encode scale */

   if (pvalue->m.scalePresent) {
      stat = asn1PE_Zoom (pctxt, pvalue->scale);
      if (stat != 0) return stat;
   }

   /* encode nodeList */

   stat = asn1PE_RegionList (pctxt, &pvalue->nodeList);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RegionPointSet: end\n");

   return (stat);
}

EXTERN int asn1PE_ValidRegion_area (OSCTXT* pctxt, ValidRegion_area* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ValidRegion_area: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 2);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* shapePointSet */
      case 1:
         stat = asn1PE_ShapePointSet (pctxt, pvalue->u.shapePointSet);
         if (stat != 0) return stat;
         break;

      /* circle */
      case 2:
         stat = asn1PE_Circle (pctxt, pvalue->u.circle);
         if (stat != 0) return stat;
         break;

      /* regionPointSet */
      case 3:
         stat = asn1PE_RegionPointSet (pctxt, pvalue->u.regionPointSet);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ValidRegion_area: end\n");

   return (stat);
}

EXTERN int asn1PE_ValidRegion (OSCTXT* pctxt, ValidRegion* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ValidRegion: start\n");

   PU_NEWFIELD (pctxt, "extentPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.extentPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode direction */

   stat = asn1PE_HeadingSlice (pctxt, &pvalue->direction);
   if (stat != 0) return stat;

   /* encode extent */

   if (pvalue->m.extentPresent) {
      stat = asn1PE_Extent (pctxt, pvalue->extent);
      if (stat != 0) return stat;
   }

   /* encode area */

   stat = asn1PE_ValidRegion_area (pctxt, &pvalue->area);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_ValidRegion: end\n");

   return (stat);
}

EXTERN int asn1PE_GeographicalPath_description (OSCTXT* pctxt, GeographicalPath_description* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_GeographicalPath_description: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->t > 3);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {

      /* Encode choice index value */

      stat = rtxEncBits (pctxt, pvalue->t - 1, 2);
      if (stat != 0) return stat;

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* path */
         case 1:
            stat = asn1PE_OffsetSystem (pctxt, pvalue->u.path);
            if (stat != 0) return stat;
            break;

         /* geometry */
         case 2:
            stat = asn1PE_GeometricProjection (pctxt, pvalue->u.geometry);
            if (stat != 0) return stat;
            break;

         /* oldRegion */
         case 3:
            stat = asn1PE_ValidRegion (pctxt, pvalue->u.oldRegion);
            if (stat != 0) return stat;
            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      /* Encode extension choice index value */

      PU_NEWFIELD (pctxt, "choice index");

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GeographicalPath_description: end\n");

   return (stat);
}

EXTERN int asn1PE_GeographicalPath_regional (OSCTXT* pctxt, GeographicalPath_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_GeographicalPath_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GeographicalPath_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_GeographicalPath (OSCTXT* pctxt, GeographicalPath* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_GeographicalPath: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "namePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.namePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "idPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.idPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "anchorPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.anchorPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "laneWidthPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.laneWidthPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "directionalityPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.directionalityPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "closedPathPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.closedPathPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "directionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.directionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "descriptionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.descriptionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode name */

   if (pvalue->m.namePresent) {
      stat = asn1PE_DescriptiveName (pctxt, pvalue->name);
      if (stat != 0) return stat;
   }

   /* encode id */

   if (pvalue->m.idPresent) {
      stat = asn1PE_RoadSegmentReferenceID (pctxt, &pvalue->id);
      if (stat != 0) return stat;
   }

   /* encode anchor */

   if (pvalue->m.anchorPresent) {
      stat = asn1PE_Position3D (pctxt, &pvalue->anchor);
      if (stat != 0) return stat;
   }

   /* encode laneWidth */

   if (pvalue->m.laneWidthPresent) {
      stat = asn1PE_LaneWidth (pctxt, pvalue->laneWidth);
      if (stat != 0) return stat;
   }

   /* encode directionality */

   if (pvalue->m.directionalityPresent) {
      stat = asn1PE_DirectionOfUse (pctxt, pvalue->directionality);
      if (stat != 0) return stat;
   }

   /* encode closedPath */

   if (pvalue->m.closedPathPresent) {
      PU_NEWFIELD (pctxt, "boolean");

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->closedPath);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);
   }

   /* encode direction */

   if (pvalue->m.directionPresent) {
      stat = asn1PE_HeadingSlice (pctxt, &pvalue->direction);
      if (stat != 0) return stat;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = asn1PE_GeographicalPath_description (pctxt, &pvalue->description);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_GeographicalPath_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GeographicalPath: end\n");

   return (stat);
}

EXTERN int asn1PE_TravelerDataFrame_regions (OSCTXT* pctxt, TravelerDataFrame_regions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerDataFrame_regions: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_GeographicalPath (pctxt, ((GeographicalPath*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerDataFrame_regions: end\n");

   return (stat);
}

EXTERN int asn1PE_WorkZone_element_item (OSCTXT* pctxt, WorkZone_element_item* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_WorkZone_element_item: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* itis */
      case 1:
         stat = asn1PE_ITIScodes (pctxt, pvalue->u.itis);
         if (stat != 0) return stat;
         break;

      /* text */
      case 2:
         stat = asn1PE_ITIStextPhrase (pctxt, pvalue->u.text);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_WorkZone_element_item: end\n");

   return (stat);
}

EXTERN int asn1PE_WorkZone_element (OSCTXT* pctxt, WorkZone_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_WorkZone_element: start\n");

   /* encode item */

   stat = asn1PE_WorkZone_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_WorkZone_element: end\n");

   return (stat);
}

EXTERN int asn1PE_WorkZone (OSCTXT* pctxt, WorkZone* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_WorkZone: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_WorkZone_element (pctxt, ((WorkZone_element*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_WorkZone: end\n");

   return (stat);
}

EXTERN int asn1PE_GenericSignage_element_item (OSCTXT* pctxt, GenericSignage_element_item* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GenericSignage_element_item: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* itis */
      case 1:
         stat = asn1PE_ITIScodes (pctxt, pvalue->u.itis);
         if (stat != 0) return stat;
         break;

      /* text */
      case 2:
         stat = asn1PE_ITIStextPhrase (pctxt, pvalue->u.text);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GenericSignage_element_item: end\n");

   return (stat);
}

EXTERN int asn1PE_GenericSignage_element (OSCTXT* pctxt, GenericSignage_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_GenericSignage_element: start\n");

   /* encode item */

   stat = asn1PE_GenericSignage_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_GenericSignage_element: end\n");

   return (stat);
}

EXTERN int asn1PE_GenericSignage (OSCTXT* pctxt, GenericSignage* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_GenericSignage: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_GenericSignage_element (pctxt, ((GenericSignage_element*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_GenericSignage: end\n");

   return (stat);
}

EXTERN int asn1PE_SpeedLimit_element_item (OSCTXT* pctxt, SpeedLimit_element_item* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedLimit_element_item: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* itis */
      case 1:
         stat = asn1PE_ITIScodes (pctxt, pvalue->u.itis);
         if (stat != 0) return stat;
         break;

      /* text */
      case 2:
         stat = asn1PE_ITIStextPhrase (pctxt, pvalue->u.text);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedLimit_element_item: end\n");

   return (stat);
}

EXTERN int asn1PE_SpeedLimit_element (OSCTXT* pctxt, SpeedLimit_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedLimit_element: start\n");

   /* encode item */

   stat = asn1PE_SpeedLimit_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedLimit_element: end\n");

   return (stat);
}

EXTERN int asn1PE_SpeedLimit (OSCTXT* pctxt, SpeedLimit* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedLimit: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_SpeedLimit_element (pctxt, ((SpeedLimit_element*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedLimit: end\n");

   return (stat);
}

EXTERN int asn1PE_ExitService_element_item (OSCTXT* pctxt, ExitService_element_item* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ExitService_element_item: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 1);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* itis */
      case 1:
         stat = asn1PE_ITIScodes (pctxt, pvalue->u.itis);
         if (stat != 0) return stat;
         break;

      /* text */
      case 2:
         stat = asn1PE_ITIStextPhrase (pctxt, pvalue->u.text);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ExitService_element_item: end\n");

   return (stat);
}

EXTERN int asn1PE_ExitService_element (OSCTXT* pctxt, ExitService_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ExitService_element: start\n");

   /* encode item */

   stat = asn1PE_ExitService_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_ExitService_element: end\n");

   return (stat);
}

EXTERN int asn1PE_ExitService (OSCTXT* pctxt, ExitService* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_ExitService: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_ExitService_element (pctxt, ((ExitService_element*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ExitService: end\n");

   return (stat);
}

EXTERN int asn1PE_TravelerDataFrame_content (OSCTXT* pctxt, TravelerDataFrame_content* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerDataFrame_content: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 3);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* advisory */
      case 1:
         stat = asn1PE_ITIScodesAndText (pctxt, pvalue->u.advisory);
         if (stat != 0) return stat;
         break;

      /* workZone */
      case 2:
         stat = asn1PE_WorkZone (pctxt, pvalue->u.workZone);
         if (stat != 0) return stat;
         break;

      /* genericSign */
      case 3:
         stat = asn1PE_GenericSignage (pctxt, pvalue->u.genericSign);
         if (stat != 0) return stat;
         break;

      /* speedLimit */
      case 4:
         stat = asn1PE_SpeedLimit (pctxt, pvalue->u.speedLimit);
         if (stat != 0) return stat;
         break;

      /* exitService */
      case 5:
         stat = asn1PE_ExitService (pctxt, pvalue->u.exitService);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerDataFrame_content: end\n");

   return (stat);
}

EXTERN int asn1PE_TravelerDataFrame (OSCTXT* pctxt, TravelerDataFrame* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerDataFrame: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "startYearPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.startYearPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "urlPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.urlPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode sspTimRights */

   stat = asn1PE_SSPindex (pctxt, pvalue->sspTimRights);
   if (stat != 0) return stat;

   /* encode frameType */

   stat = asn1PE_TravelerInfoType (pctxt, pvalue->frameType);
   if (stat != 0) return stat;

   /* encode msgId */

   stat = asn1PE_TravelerDataFrame_msgId (pctxt, &pvalue->msgId);
   if (stat != 0) return stat;

   /* encode startYear */

   if (pvalue->m.startYearPresent) {
      stat = asn1PE_DYear (pctxt, pvalue->startYear);
      if (stat != 0) return stat;
   }

   /* encode startTime */

   stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->startTime);
   if (stat != 0) return stat;

   /* encode duratonTime */

   stat = asn1PE_MinutesDuration (pctxt, pvalue->duratonTime);
   if (stat != 0) return stat;

   /* encode priority */

   stat = asn1PE_SignPrority (pctxt, pvalue->priority);
   if (stat != 0) return stat;

   /* encode sspLocationRights */

   stat = asn1PE_SSPindex (pctxt, pvalue->sspLocationRights);
   if (stat != 0) return stat;

   /* encode regions */

   stat = asn1PE_TravelerDataFrame_regions (pctxt, &pvalue->regions);
   if (stat != 0) return stat;

   /* encode sspMsgRights1 */

   stat = asn1PE_SSPindex (pctxt, pvalue->sspMsgRights1);
   if (stat != 0) return stat;

   /* encode sspMsgRights2 */

   stat = asn1PE_SSPindex (pctxt, pvalue->sspMsgRights2);
   if (stat != 0) return stat;

   /* encode content */

   stat = asn1PE_TravelerDataFrame_content (pctxt, &pvalue->content);
   if (stat != 0) return stat;

   /* encode url */

   if (pvalue->m.urlPresent) {
      stat = asn1PE_URL_Short (pctxt, pvalue->url);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerDataFrame: end\n");

   return (stat);
}

EXTERN int asn1PE_TravelerDataFrameList (OSCTXT* pctxt, TravelerDataFrameList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerDataFrameList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_TravelerDataFrame (pctxt, ((TravelerDataFrame*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerDataFrameList: end\n");

   return (stat);
}

EXTERN int asn1PE_TravelerInformation_regional (OSCTXT* pctxt, TravelerInformation_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerInformation_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerInformation_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_TravelerInformation (OSCTXT* pctxt, TravelerInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeStampPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "packetIDPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.packetIDPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "urlBPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.urlBPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode msgCnt */

   stat = asn1PE_MsgCount (pctxt, pvalue->msgCnt);
   if (stat != 0) return stat;

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode packetID */

   if (pvalue->m.packetIDPresent) {
      stat = asn1PE_UniqueMSGID (pctxt, &pvalue->packetID);
      if (stat != 0) return stat;
   }

   /* encode urlB */

   if (pvalue->m.urlBPresent) {
      stat = asn1PE_URL_Base (pctxt, pvalue->urlB);
      if (stat != 0) return stat;
   }

   /* encode dataFrames */

   stat = asn1PE_TravelerDataFrameList (pctxt, &pvalue->dataFrames);
   if (stat != 0) return stat;

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_TravelerInformation_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TravelerInformation: end\n");

   return (stat);
}

EXTERN int asn1PE_Header (OSCTXT* pctxt, Header* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_Header: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "yearPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.yearPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "timeStampPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.timeStampPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "secMarkPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.secMarkPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "msgIssueRevisionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.msgIssueRevisionPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode year */

   if (pvalue->m.yearPresent) {
      stat = asn1PE_DYear (pctxt, pvalue->year);
      if (stat != 0) return stat;
   }

   /* encode timeStamp */

   if (pvalue->m.timeStampPresent) {
      stat = asn1PE_MinuteOfTheYear (pctxt, pvalue->timeStamp);
      if (stat != 0) return stat;
   }

   /* encode secMark */

   if (pvalue->m.secMarkPresent) {
      stat = asn1PE_DSecond (pctxt, pvalue->secMark);
      if (stat != 0) return stat;
   }

   /* encode msgIssueRevision */

   if (pvalue->m.msgIssueRevisionPresent) {
      stat = asn1PE_MsgCount (pctxt, pvalue->msgIssueRevision);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Header: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage00 (OSCTXT* pctxt, TestMessage00* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage00: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage00: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage01 (OSCTXT* pctxt, TestMessage01* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage01: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage01: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage02 (OSCTXT* pctxt, TestMessage02* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage02: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage02: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage03 (OSCTXT* pctxt, TestMessage03* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage03: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage03: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage04 (OSCTXT* pctxt, TestMessage04* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage04: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage04: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage05 (OSCTXT* pctxt, TestMessage05* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage05: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage05: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage06 (OSCTXT* pctxt, TestMessage06* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage06: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage06: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage07 (OSCTXT* pctxt, TestMessage07* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage07: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage07: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage08 (OSCTXT* pctxt, TestMessage08* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage08: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage08: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage09 (OSCTXT* pctxt, TestMessage09* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage09: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage09: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage10 (OSCTXT* pctxt, TestMessage10* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage10: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage10: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage11 (OSCTXT* pctxt, TestMessage11* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage11: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage11: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage12 (OSCTXT* pctxt, TestMessage12* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage12: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage12: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage13 (OSCTXT* pctxt, TestMessage13* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage13: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage13: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage14 (OSCTXT* pctxt, TestMessage14* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage14: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage14: end\n");

   return (stat);
}

EXTERN int asn1PE_TestMessage15 (OSCTXT* pctxt, TestMessage15* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage15: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headerPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headerPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = asn1PE_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TestMessage15: end\n");

   return (stat);
}

EXTERN int asn1PE_DDate (OSCTXT* pctxt, DDate* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DDate: start\n");

   /* encode year */

   stat = asn1PE_DYear (pctxt, pvalue->year);
   if (stat != 0) return stat;

   /* encode month */

   stat = asn1PE_DMonth (pctxt, pvalue->month);
   if (stat != 0) return stat;

   /* encode day */

   stat = asn1PE_DDay (pctxt, pvalue->day);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DDate: end\n");

   return (stat);
}

EXTERN int asn1PE_DFullTime (OSCTXT* pctxt, DFullTime* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DFullTime: start\n");

   /* encode year */

   stat = asn1PE_DYear (pctxt, pvalue->year);
   if (stat != 0) return stat;

   /* encode month */

   stat = asn1PE_DMonth (pctxt, pvalue->month);
   if (stat != 0) return stat;

   /* encode day */

   stat = asn1PE_DDay (pctxt, pvalue->day);
   if (stat != 0) return stat;

   /* encode hour */

   stat = asn1PE_DHour (pctxt, pvalue->hour);
   if (stat != 0) return stat;

   /* encode minute */

   stat = asn1PE_DMinute (pctxt, pvalue->minute);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DFullTime: end\n");

   return (stat);
}

EXTERN int asn1PE_DMonthDay (OSCTXT* pctxt, DMonthDay* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DMonthDay: start\n");

   /* encode month */

   stat = asn1PE_DMonth (pctxt, pvalue->month);
   if (stat != 0) return stat;

   /* encode day */

   stat = asn1PE_DDay (pctxt, pvalue->day);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DMonthDay: end\n");

   return (stat);
}

EXTERN int asn1PE_DTime (OSCTXT* pctxt, DTime* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DTime: start\n");

   PU_NEWFIELD (pctxt, "offsetPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.offsetPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode hour */

   stat = asn1PE_DHour (pctxt, pvalue->hour);
   if (stat != 0) return stat;

   /* encode minute */

   stat = asn1PE_DMinute (pctxt, pvalue->minute);
   if (stat != 0) return stat;

   /* encode second */

   stat = asn1PE_DSecond (pctxt, pvalue->second);
   if (stat != 0) return stat;

   /* encode offset */

   if (pvalue->m.offsetPresent) {
      stat = asn1PE_DOffset (pctxt, pvalue->offset);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DTime: end\n");

   return (stat);
}

EXTERN int asn1PE_DYearMonth (OSCTXT* pctxt, DYearMonth* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DYearMonth: start\n");

   /* encode year */

   stat = asn1PE_DYear (pctxt, pvalue->year);
   if (stat != 0) return stat;

   /* encode month */

   stat = asn1PE_DMonth (pctxt, pvalue->month);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt, "asn1PE_DYearMonth: end\n");

   return (stat);
}

EXTERN int asn1PE_DisabledVehicle (OSCTXT* pctxt, DisabledVehicle* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_DisabledVehicle: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "locationDetailsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.locationDetailsPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode statusDetails */

   stat = pe_ConsUnsigned (pctxt, pvalue->statusDetails, 523, 541);
   if (stat != 0) return stat;

   /* encode locationDetails */

   if (pvalue->m.locationDetailsPresent) {
      stat = asn1PE_GenericLocations (pctxt, pvalue->locationDetails);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DisabledVehicle: end\n");

   return (stat);
}

EXTERN int asn1PE_EventDescription_description (OSCTXT* pctxt, EventDescription_description* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_EventDescription_description: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_ITIScodes (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_EventDescription_description: end\n");

   return (stat);
}

EXTERN int asn1PE_EventDescription_regional (OSCTXT* pctxt, EventDescription_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_EventDescription_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_EventDescription_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_EventDescription (OSCTXT* pctxt, EventDescription* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_EventDescription: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "descriptionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.descriptionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "priorityPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.priorityPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headingPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headingPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "extentPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.extentPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode typeEvent */

   stat = asn1PE_ITIScodes (pctxt, pvalue->typeEvent);
   if (stat != 0) return stat;

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = asn1PE_EventDescription_description (pctxt, &pvalue->description);
      if (stat != 0) return stat;
   }

   /* encode priority */

   if (pvalue->m.priorityPresent) {
      stat = asn1PE_Priority (pctxt, &pvalue->priority);
      if (stat != 0) return stat;
   }

   /* encode heading */

   if (pvalue->m.headingPresent) {
      stat = asn1PE_HeadingSlice (pctxt, &pvalue->heading);
      if (stat != 0) return stat;
   }

   /* encode extent */

   if (pvalue->m.extentPresent) {
      stat = asn1PE_Extent (pctxt, pvalue->extent);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_EventDescription_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_EventDescription: end\n");

   return (stat);
}

EXTERN int asn1PE_ObstacleDetection (OSCTXT* pctxt, ObstacleDetection* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_ObstacleDetection: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "descriptionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.descriptionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "locationDetailsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.locationDetailsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "vertEventPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vertEventPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode obDist */

   stat = asn1PE_ObstacleDistance (pctxt, pvalue->obDist);
   if (stat != 0) return stat;

   /* encode obDirect */

   stat = asn1PE_ObstacleDirection (pctxt, pvalue->obDirect);
   if (stat != 0) return stat;

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = pe_ConsUnsigned (pctxt, pvalue->description, 523, 541);
      if (stat != 0) return stat;

   }

   /* encode locationDetails */

   if (pvalue->m.locationDetailsPresent) {
      stat = asn1PE_GenericLocations (pctxt, pvalue->locationDetails);
      if (stat != 0) return stat;
   }

   /* encode dateTime */

   stat = asn1PE_DDateTime (pctxt, &pvalue->dateTime);
   if (stat != 0) return stat;

   /* encode vertEvent */

   if (pvalue->m.vertEventPresent) {
      stat = asn1PE_VerticalAccelerationThreshold (pctxt, &pvalue->vertEvent);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ObstacleDetection: end\n");

   return (stat);
}

EXTERN int asn1PE_PivotPointDescription (OSCTXT* pctxt, PivotPointDescription* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_PivotPointDescription: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   /* encode pivotOffset */

   stat = asn1PE_Offset_B11 (pctxt, pvalue->pivotOffset);
   if (stat != 0) return stat;

   /* encode pivotAngle */

   stat = asn1PE_Angle (pctxt, pvalue->pivotAngle);
   if (stat != 0) return stat;

   /* encode pivots */

   stat = asn1PE_PivotingAllowed (pctxt, pvalue->pivots);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PivotPointDescription: end\n");

   return (stat);
}

EXTERN int asn1PE_RTCMPackage (OSCTXT* pctxt, RTCMPackage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_RTCMPackage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rtcmHeaderPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rtcmHeaderPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode rtcmHeader */

   if (pvalue->m.rtcmHeaderPresent) {
      stat = asn1PE_RTCMheader (pctxt, &pvalue->rtcmHeader);
      if (stat != 0) return stat;
   }

   /* encode msgs */

   stat = asn1PE_RTCMmessageList (pctxt, &pvalue->msgs);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RTCMPackage: end\n");

   return (stat);
}

EXTERN int asn1PE_TrailerHistoryPoint (OSCTXT* pctxt, TrailerHistoryPoint* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TrailerHistoryPoint: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "elevationOffsetPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.elevationOffsetPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "headingPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.headingPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode pivotAngle */

   stat = asn1PE_Angle (pctxt, pvalue->pivotAngle);
   if (stat != 0) return stat;

   /* encode timeOffset */

   stat = asn1PE_TimeOffset (pctxt, pvalue->timeOffset);
   if (stat != 0) return stat;

   /* encode positionOffset */

   stat = asn1PE_Node_XY_24b (pctxt, &pvalue->positionOffset);
   if (stat != 0) return stat;

   /* encode elevationOffset */

   if (pvalue->m.elevationOffsetPresent) {
      stat = asn1PE_VertOffset_B07 (pctxt, pvalue->elevationOffset);
      if (stat != 0) return stat;
   }

   /* encode heading */

   if (pvalue->m.headingPresent) {
      stat = asn1PE_CoarseHeading (pctxt, pvalue->heading);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TrailerHistoryPoint: end\n");

   return (stat);
}

EXTERN int asn1PE_TrailerHistoryPointList (OSCTXT* pctxt, TrailerHistoryPointList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TrailerHistoryPointList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(23), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_TrailerHistoryPoint (pctxt, ((TrailerHistoryPoint*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TrailerHistoryPointList: end\n");

   return (stat);
}

EXTERN int asn1PE_TrailerUnitDescription (OSCTXT* pctxt, TrailerUnitDescription* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TrailerUnitDescription: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "heightPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.heightPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "massPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.massPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bumperHeightsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.bumperHeightsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "centerOfGravityPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.centerOfGravityPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rearPivotPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rearPivotPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rearWheelOffsetPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rearWheelOffsetPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "elevationOffsetPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.elevationOffsetPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "crumbDataPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.crumbDataPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode isDolly */

   stat = asn1PE_IsDolly (pctxt, pvalue->isDolly);
   if (stat != 0) return stat;

   /* encode width */

   stat = asn1PE_VehicleWidth (pctxt, pvalue->width);
   if (stat != 0) return stat;

   /* encode length */

   stat = asn1PE_VehicleLength (pctxt, pvalue->length);
   if (stat != 0) return stat;

   /* encode height */

   if (pvalue->m.heightPresent) {
      stat = asn1PE_VehicleHeight (pctxt, pvalue->height);
      if (stat != 0) return stat;
   }

   /* encode mass */

   if (pvalue->m.massPresent) {
      stat = asn1PE_TrailerMass (pctxt, pvalue->mass);
      if (stat != 0) return stat;
   }

   /* encode bumperHeights */

   if (pvalue->m.bumperHeightsPresent) {
      stat = asn1PE_BumperHeights (pctxt, &pvalue->bumperHeights);
      if (stat != 0) return stat;
   }

   /* encode centerOfGravity */

   if (pvalue->m.centerOfGravityPresent) {
      stat = asn1PE_VehicleHeight (pctxt, pvalue->centerOfGravity);
      if (stat != 0) return stat;
   }

   /* encode frontPivot */

   stat = asn1PE_PivotPointDescription (pctxt, &pvalue->frontPivot);
   if (stat != 0) return stat;

   /* encode rearPivot */

   if (pvalue->m.rearPivotPresent) {
      stat = asn1PE_PivotPointDescription (pctxt, &pvalue->rearPivot);
      if (stat != 0) return stat;
   }

   /* encode rearWheelOffset */

   if (pvalue->m.rearWheelOffsetPresent) {
      stat = asn1PE_Offset_B12 (pctxt, pvalue->rearWheelOffset);
      if (stat != 0) return stat;
   }

   /* encode positionOffset */

   stat = asn1PE_Node_XY_24b (pctxt, &pvalue->positionOffset);
   if (stat != 0) return stat;

   /* encode elevationOffset */

   if (pvalue->m.elevationOffsetPresent) {
      stat = asn1PE_VertOffset_B07 (pctxt, pvalue->elevationOffset);
      if (stat != 0) return stat;
   }

   /* encode crumbData */

   if (pvalue->m.crumbDataPresent) {
      stat = asn1PE_TrailerHistoryPointList (pctxt, &pvalue->crumbData);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TrailerUnitDescription: end\n");

   return (stat);
}

EXTERN int asn1PE_TrailerUnitDescriptionList (OSCTXT* pctxt, TrailerUnitDescriptionList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TrailerUnitDescriptionList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_TrailerUnitDescription (pctxt, ((TrailerUnitDescription*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TrailerUnitDescriptionList: end\n");

   return (stat);
}

EXTERN int asn1PE_TrailerData (OSCTXT* pctxt, TrailerData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_TrailerData: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   /* encode sspRights */

   stat = asn1PE_SSPindex (pctxt, pvalue->sspRights);
   if (stat != 0) return stat;

   /* encode connection */

   stat = asn1PE_PivotPointDescription (pctxt, &pvalue->connection);
   if (stat != 0) return stat;

   /* encode units */

   stat = asn1PE_TrailerUnitDescriptionList (pctxt, &pvalue->units);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TrailerData: end\n");

   return (stat);
}

EXTERN int asn1PE_SpecialVehicleExtensions (OSCTXT* pctxt, SpecialVehicleExtensions* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpecialVehicleExtensions: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "vehicleAlertsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehicleAlertsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "descriptionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.descriptionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "trailersPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.trailersPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode vehicleAlerts */

   if (pvalue->m.vehicleAlertsPresent) {
      stat = asn1PE_EmergencyDetails (pctxt, &pvalue->vehicleAlerts);
      if (stat != 0) return stat;
   }

   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = asn1PE_EventDescription (pctxt, &pvalue->description);
      if (stat != 0) return stat;
   }

   /* encode trailers */

   if (pvalue->m.trailersPresent) {
      stat = asn1PE_TrailerData (pctxt, &pvalue->trailers);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SpecialVehicleExtensions: end\n");

   return (stat);
}

EXTERN int asn1PE_SpeedProfileMeasurementList (OSCTXT* pctxt, SpeedProfileMeasurementList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedProfileMeasurementList: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(20), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return stat;

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PE_SpeedProfileMeasurement (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedProfileMeasurementList: end\n");

   return (stat);
}

EXTERN int asn1PE_SpeedProfile (OSCTXT* pctxt, SpeedProfile* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedProfile: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   /* encode speedReports */

   stat = asn1PE_SpeedProfileMeasurementList (pctxt, &pvalue->speedReports);
   if (stat != 0) return stat;

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SpeedProfile: end\n");

   return (stat);
}

EXTERN int asn1PE_VehicleData (OSCTXT* pctxt, VehicleData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleData: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "heightPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.heightPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "bumpersPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.bumpersPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "massPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.massPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "trailerWeightPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.trailerWeightPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode height */

   if (pvalue->m.heightPresent) {
      stat = asn1PE_VehicleHeight (pctxt, pvalue->height);
      if (stat != 0) return stat;
   }

   /* encode bumpers */

   if (pvalue->m.bumpersPresent) {
      stat = asn1PE_BumperHeights (pctxt, &pvalue->bumpers);
      if (stat != 0) return stat;
   }

   /* encode mass */

   if (pvalue->m.massPresent) {
      stat = asn1PE_VehicleMass (pctxt, pvalue->mass);
      if (stat != 0) return stat;
   }

   /* encode trailerWeight */

   if (pvalue->m.trailerWeightPresent) {
      stat = asn1PE_TrailerWeight (pctxt, pvalue->trailerWeight);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_VehicleData: end\n");

   return (stat);
}

EXTERN int asn1PE_WeatherReport (OSCTXT* pctxt, WeatherReport* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_WeatherReport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rainRatePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rainRatePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "precipSituationPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.precipSituationPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "solarRadiationPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.solarRadiationPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "frictionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.frictionPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "roadFrictionPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.roadFrictionPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode isRaining */

   stat = asn1PE_EssPrecipYesNo (pctxt, pvalue->isRaining);
   if (stat != 0) return stat;

   /* encode rainRate */

   if (pvalue->m.rainRatePresent) {
      stat = asn1PE_EssPrecipRate (pctxt, pvalue->rainRate);
      if (stat != 0) return stat;
   }

   /* encode precipSituation */

   if (pvalue->m.precipSituationPresent) {
      stat = asn1PE_EssPrecipSituation (pctxt, pvalue->precipSituation);
      if (stat != 0) return stat;
   }

   /* encode solarRadiation */

   if (pvalue->m.solarRadiationPresent) {
      stat = asn1PE_EssSolarRadiation (pctxt, pvalue->solarRadiation);
      if (stat != 0) return stat;
   }

   /* encode friction */

   if (pvalue->m.frictionPresent) {
      stat = asn1PE_EssMobileFriction (pctxt, pvalue->friction);
      if (stat != 0) return stat;
   }

   /* encode roadFriction */

   if (pvalue->m.roadFrictionPresent) {
      stat = asn1PE_CoefficientOfFriction (pctxt, pvalue->roadFriction);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_WeatherReport: end\n");

   return (stat);
}

EXTERN int asn1PE_WeatherProbe (OSCTXT* pctxt, WeatherProbe* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_WeatherProbe: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "airTempPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.airTempPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "airPressurePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.airPressurePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "rainRatesPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.rainRatesPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode airTemp */

   if (pvalue->m.airTempPresent) {
      stat = asn1PE_AmbientAirTemperature (pctxt, pvalue->airTemp);
      if (stat != 0) return stat;
   }

   /* encode airPressure */

   if (pvalue->m.airPressurePresent) {
      stat = asn1PE_AmbientAirPressure (pctxt, pvalue->airPressure);
      if (stat != 0) return stat;
   }

   /* encode rainRates */

   if (pvalue->m.rainRatesPresent) {
      stat = asn1PE_WiperSet (pctxt, &pvalue->rainRates);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_WeatherProbe: end\n");

   return (stat);
}

EXTERN int asn1PE_SupplementalVehicleExtensions_regional (OSCTXT* pctxt, SupplementalVehicleExtensions_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SupplementalVehicleExtensions_regional: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return stat;

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      stat = asn1PE_RegionalExtension (pctxt, ((RegionalExtension*)pnode->data));
      if (stat != 0) return stat;

      xx1++;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SupplementalVehicleExtensions_regional: end\n");

   return (stat);
}

EXTERN int asn1PE_SupplementalVehicleExtensions (OSCTXT* pctxt, SupplementalVehicleExtensions* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt, "asn1PE_SupplementalVehicleExtensions: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   rtxEncBit (pctxt, extbit);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "classificationPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.classificationPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "classDetailsPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.classDetailsPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "vehicleDataPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.vehicleDataPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "weatherReportPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.weatherReportPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "weatherProbePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.weatherProbePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "obstaclePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.obstaclePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "statusPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.statusPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "speedProfilePresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.speedProfilePresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "theRTCMPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.theRTCMPresent);

   PU_SETBITCOUNT (pctxt);

   PU_NEWFIELD (pctxt, "regionalPresent");

   rtxEncBit (pctxt, (OSBOOL)pvalue->m.regionalPresent);

   PU_SETBITCOUNT (pctxt);

   /* encode classification */

   if (pvalue->m.classificationPresent) {
      stat = asn1PE_BasicVehicleClass (pctxt, pvalue->classification);
      if (stat != 0) return stat;
   }

   /* encode classDetails */

   if (pvalue->m.classDetailsPresent) {
      stat = asn1PE_VehicleClassification (pctxt, &pvalue->classDetails);
      if (stat != 0) return stat;
   }

   /* encode vehicleData */

   if (pvalue->m.vehicleDataPresent) {
      stat = asn1PE_VehicleData (pctxt, &pvalue->vehicleData);
      if (stat != 0) return stat;
   }

   /* encode weatherReport */

   if (pvalue->m.weatherReportPresent) {
      stat = asn1PE_WeatherReport (pctxt, &pvalue->weatherReport);
      if (stat != 0) return stat;
   }

   /* encode weatherProbe */

   if (pvalue->m.weatherProbePresent) {
      stat = asn1PE_WeatherProbe (pctxt, &pvalue->weatherProbe);
      if (stat != 0) return stat;
   }

   /* encode obstacle */

   if (pvalue->m.obstaclePresent) {
      stat = asn1PE_ObstacleDetection (pctxt, &pvalue->obstacle);
      if (stat != 0) return stat;
   }

   /* encode status */

   if (pvalue->m.statusPresent) {
      stat = asn1PE_DisabledVehicle (pctxt, &pvalue->status);
      if (stat != 0) return stat;
   }

   /* encode speedProfile */

   if (pvalue->m.speedProfilePresent) {
      stat = asn1PE_SpeedProfile (pctxt, &pvalue->speedProfile);
      if (stat != 0) return stat;
   }

   /* encode theRTCM */

   if (pvalue->m.theRTCMPresent) {
      stat = asn1PE_RTCMPackage (pctxt, &pvalue->theRTCM);
      if (stat != 0) return stat;
   }

   /* encode regional */

   if (pvalue->m.regionalPresent) {
      stat = asn1PE_SupplementalVehicleExtensions_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;
   }

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SupplementalVehicleExtensions: end\n");

   return (stat);
}

EXTERN int asn1PE_VerticalOffset (OSCTXT* pctxt, VerticalOffset* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_VerticalOffset: start\n");

   /* Encode choice index value */

   stat = rtxEncBits (pctxt, pvalue->t - 1, 3);
   if (stat != 0) return stat;

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* offset1 */
      case 1:
         stat = asn1PE_VertOffset_B07 (pctxt, pvalue->u.offset1);
         if (stat != 0) return stat;
         break;

      /* offset2 */
      case 2:
         stat = asn1PE_VertOffset_B08 (pctxt, pvalue->u.offset2);
         if (stat != 0) return stat;
         break;

      /* offset3 */
      case 3:
         stat = asn1PE_VertOffset_B09 (pctxt, pvalue->u.offset3);
         if (stat != 0) return stat;
         break;

      /* offset4 */
      case 4:
         stat = asn1PE_VertOffset_B10 (pctxt, pvalue->u.offset4);
         if (stat != 0) return stat;
         break;

      /* offset5 */
      case 5:
         stat = asn1PE_VertOffset_B11 (pctxt, pvalue->u.offset5);
         if (stat != 0) return stat;
         break;

      /* offset6 */
      case 6:
         stat = asn1PE_VertOffset_B12 (pctxt, pvalue->u.offset6);
         if (stat != 0) return stat;
         break;

      /* elevation */
      case 7:
         stat = asn1PE_Elevation (pctxt, pvalue->u.elevation);
         if (stat != 0) return stat;
         break;

      /* regional */
      case 8:
         stat = asn1PE_RegionalExtension (pctxt, pvalue->u.regional);
         if (stat != 0) return stat;
         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_VerticalOffset: end\n");

   return (stat);
}

