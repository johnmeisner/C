/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.2.4, Date: 06-Mar-2019.
 */
#include "AddGrpC.h"
#include "rtsrc/rtPrintToStream.h"
#include "rtxsrc/rtxCharStr.h"
#include "rtxsrc/rtxCommon.h"

int asn1PrtToStrm_AltitudeConfidence (OSCTXT *pctxt, 
   const char* name, const AltitudeConfidence* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = alt-000-01\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = alt-000-02\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = alt-000-05\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = alt-000-10\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = alt-000-20\n");
         break;
      case 5:
         rtxPrintToStream (pctxt, " = alt-000-50\n");
         break;
      case 6:
         rtxPrintToStream (pctxt, " = alt-001-00\n");
         break;
      case 7:
         rtxPrintToStream (pctxt, " = alt-002-00\n");
         break;
      case 8:
         rtxPrintToStream (pctxt, " = alt-005-00\n");
         break;
      case 9:
         rtxPrintToStream (pctxt, " = alt-010-00\n");
         break;
      case 10:
         rtxPrintToStream (pctxt, " = alt-020-00\n");
         break;
      case 11:
         rtxPrintToStream (pctxt, " = alt-050-00\n");
         break;
      case 12:
         rtxPrintToStream (pctxt, " = alt-100-00\n");
         break;
      case 13:
         rtxPrintToStream (pctxt, " = alt-200-00\n");
         break;
      case 14:
         rtxPrintToStream (pctxt, " = outOfRange\n");
         break;
      case 15:
         rtxPrintToStream (pctxt, " = unavailable\n");
         break;
      default:
         rtxPrintToStream (pctxt," = ???\n");
   }

   return 0;
}

int asn1PrtToStrm_AltitudeValue (OSCTXT *pctxt, 
   const char* name, const AltitudeValue* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, name, *pvalue);
   return 0;
}

int asn1PrtToStrm_EmissionType (OSCTXT *pctxt, 
   const char* name, const EmissionType* pvalue)
{
   rtPrintToStreamIndent (pctxt);
   rtxPrintToStream (pctxt, name);
   switch (*pvalue) {
      case 0:
         rtxPrintToStream (pctxt, " = typeA\n");
         break;
      case 1:
         rtxPrintToStream (pctxt, " = typeB\n");
         break;
      case 2:
         rtxPrintToStream (pctxt, " = typeC\n");
         break;
      case 3:
         rtxPrintToStream (pctxt, " = typeD\n");
         break;
      case 4:
         rtxPrintToStream (pctxt, " = typeE\n");
         break;
      default:
         rtPrintToStreamUnsigned (pctxt, "", *pvalue);
   }

   return 0;
}

int asn1PrtToStrm_Altitude (OSCTXT *pctxt, 
   const char* name, const Altitude* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_AltitudeValue (pctxt, "value", &pvalue->value);

   asn1PrtToStrm_AltitudeConfidence (pctxt, "confidence", &pvalue->confidence);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_PrioritizationResponse (OSCTXT *pctxt, 
   const char* name, const PrioritizationResponse* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_StationID (pctxt, "stationID", &pvalue->stationID);

   asn1PrtToStrm_PrioritizationResponseStatus (pctxt, "priorState", &pvalue->priorState);

   asn1PrtToStrm_SignalGroupID (pctxt, "signalGroup", &pvalue->signalGroup);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_PrioritizationResponseList (OSCTXT *pctxt, 
   const char* name, const PrioritizationResponseList* pvalue)
{
   PrioritizationResponse* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((PrioritizationResponse*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_PrioritizationResponse (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_VehicleToLanePosition (OSCTXT *pctxt, 
   const char* name, const VehicleToLanePosition* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_StationID (pctxt, "stationID", &pvalue->stationID);

   asn1PrtToStrm_LaneID (pctxt, "laneID", &pvalue->laneID);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_VehicleToLanePositionList (OSCTXT *pctxt, 
   const char* name, const VehicleToLanePositionList* pvalue)
{
   VehicleToLanePosition* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((VehicleToLanePosition*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_VehicleToLanePosition (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_ConnectionManeuverAssist_addGrpC (OSCTXT *pctxt, 
   const char* name, const ConnectionManeuverAssist_addGrpC* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_VehicleToLanePositionList (pctxt, "vehicleToLanePositions", &pvalue->vehicleToLanePositions);

   if (pvalue->m.rsuDistanceFromAnchorPresent) {
      asn1PrtToStrm_NodeOffsetPointXY (pctxt, "rsuDistanceFromAnchor", &pvalue->rsuDistanceFromAnchor);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_IntersectionState_addGrpC (OSCTXT *pctxt, 
   const char* name, const IntersectionState_addGrpC* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.activePrioritizationsPresent) {
      asn1PrtToStrm_PrioritizationResponseList (pctxt, "activePrioritizations", &pvalue->activePrioritizations);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SignalHeadLocation (OSCTXT *pctxt, 
   const char* name, const SignalHeadLocation* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_NodeOffsetPointXY (pctxt, "node", &pvalue->node);

   asn1PrtToStrm_SignalGroupID (pctxt, "signalGroupID", &pvalue->signalGroupID);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_SignalHeadLocationList (OSCTXT *pctxt, 
   const char* name, const SignalHeadLocationList* pvalue)
{
   SignalHeadLocation* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((SignalHeadLocation*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_SignalHeadLocation (pctxt, namebuf, pdata0);
      xx1++;
   }
   return 0;
}

int asn1PrtToStrm_MapData_addGrpC (OSCTXT *pctxt, 
   const char* name, const MapData_addGrpC* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.signalHeadLocationsPresent) {
      asn1PrtToStrm_SignalHeadLocationList (pctxt, "signalHeadLocations", &pvalue->signalHeadLocations);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_Position3D_addGrpC (OSCTXT *pctxt, 
   const char* name, const Position3D_addGrpC* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_Altitude (pctxt, "altitude", &pvalue->altitude);

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int asn1PrtToStrm_RestrictionUserType_addGrpC (OSCTXT *pctxt, 
   const char* name, const RestrictionUserType_addGrpC* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.emissionPresent) {
      asn1PrtToStrm_EmissionType (pctxt, "emission", &pvalue->emission);
   }

   rtPrintToStreamOpenTypeExtBraceText (pctxt, "extElem1", &pvalue->extElem1);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

