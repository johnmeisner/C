/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.2.4, Date: 06-Mar-2019.
 */
#include "DSRC.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1PD_PartII_Id (OSCTXT* pctxt, PartII_Id* pvalue)
{
   return rtxDecBitsToByte (pctxt, pvalue, 6);
}

EXTERN int asn1PD_Acceleration (OSCTXT* pctxt, Acceleration* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -2000, 2001);
}

EXTERN int asn1PD_AccelerationConfidence (OSCTXT* pctxt, AccelerationConfidence* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 3);
}

EXTERN int asn1PD_AdvisorySpeedType (OSCTXT* pctxt, AdvisorySpeedType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_AdvisorySpeedType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AdvisorySpeedType: end\n");

   return (stat);
}

EXTERN int asn1PD_AllowedManeuvers (OSCTXT* pctxt, AllowedManeuvers* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedManeuvers: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(12), OSUINTCONST(12), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedManeuvers: end\n");

   return (stat);
}

EXTERN int asn1PD_AmbientAirPressure (OSCTXT* pctxt, AmbientAirPressure* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_AmbientAirTemperature (OSCTXT* pctxt, AmbientAirTemperature* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 191) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_Angle (OSCTXT* pctxt, Angle* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 28800) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_AnimalPropelledType (OSCTXT* pctxt, AnimalPropelledType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_AnimalPropelledType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AnimalPropelledType: end\n");

   return (stat);
}

EXTERN int asn1PD_AnimalType (OSCTXT* pctxt, AnimalType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_AnimalType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AnimalType: end\n");

   return (stat);
}

EXTERN int asn1PD_AntiLockBrakeStatus (OSCTXT* pctxt, AntiLockBrakeStatus* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 2);
}

EXTERN int asn1PD_ApproachID (OSCTXT* pctxt, ApproachID* pvalue)
{
   return rtxDecBitsToByte (pctxt, pvalue, 4);
}

EXTERN int asn1PD_Attachment (OSCTXT* pctxt, Attachment* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_Attachment: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Attachment: end\n");

   return (stat);
}

EXTERN int asn1PD_AttachmentRadius (OSCTXT* pctxt, AttachmentRadius* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 200) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_AuxiliaryBrakeStatus (OSCTXT* pctxt, AuxiliaryBrakeStatus* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 2);
}

EXTERN int asn1PD_BasicVehicleClass (OSCTXT* pctxt, BasicVehicleClass* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_BasicVehicleRole (OSCTXT* pctxt, BasicVehicleRole* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_BasicVehicleRole: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(22));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BasicVehicleRole: end\n");

   return (stat);
}

EXTERN int asn1PD_BrakeAppliedPressure (OSCTXT* pctxt, BrakeAppliedPressure* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 4);
}

EXTERN int asn1PD_BrakeAppliedStatus (OSCTXT* pctxt, BrakeAppliedStatus* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_BrakeAppliedStatus: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_BrakeAppliedStatus: end\n");

   return (stat);
}

EXTERN int asn1PD_BrakeBoostApplied (OSCTXT* pctxt, BrakeBoostApplied* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 2);
}

EXTERN int asn1PD_BumperHeight (OSCTXT* pctxt, BumperHeight* pvalue)
{
   return rtxDecBitsToByte (pctxt, pvalue, 7);
}

EXTERN int asn1PD_CoarseHeading (OSCTXT* pctxt, CoarseHeading* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 240) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_CodeWord (OSCTXT* pctxt, CodeWord* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CodeWord: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_CodeWord: end\n");

   return (stat);
}

EXTERN int asn1PD_CoefficientOfFriction (OSCTXT* pctxt, CoefficientOfFriction* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 6);
   if (stat != 0) return stat;

   if (*pvalue > 50) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_Confidence (OSCTXT* pctxt, Confidence* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 200) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_Count (OSCTXT* pctxt, Count* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 6);
   if (stat != 0) return stat;

   if (*pvalue > 32) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_DDay (OSCTXT* pctxt, DDay* pvalue)
{
   return rtxDecBitsToByte (pctxt, pvalue, 5);
}

EXTERN int asn1PD_DeltaAngle (OSCTXT* pctxt, DeltaAngle* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -150, 150);
}

EXTERN int asn1PD_DeltaTime (OSCTXT* pctxt, DeltaTime* pvalue)
{
   return pd_ConsInt8 (pctxt, pvalue, -122, 121);
}

EXTERN int asn1PD_DescriptiveName (OSCTXT* pctxt, DescriptiveName* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DescriptiveName: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(63), 0, 0);

   stat = pd_ConstrainedStringEx (pctxt, pvalue, 0, 8, 7, 7);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_DescriptiveName: end\n");

   return (stat);
}

EXTERN int asn1PD_DHour (OSCTXT* pctxt, DHour* pvalue)
{
   return rtxDecBitsToByte (pctxt, pvalue, 5);
}

EXTERN int asn1PD_DirectionOfUse (OSCTXT* pctxt, DirectionOfUse* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 2);
}

EXTERN int asn1PD_DistanceUnits (OSCTXT* pctxt, DistanceUnits* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 3);
}

EXTERN int asn1PD_DMinute (OSCTXT* pctxt, DMinute* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 6);
   if (stat != 0) return stat;

   if (*pvalue > 60) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_DMonth (OSCTXT* pctxt, DMonth* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 4);
   if (stat != 0) return stat;

   if (*pvalue > 12) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_DOffset (OSCTXT* pctxt, DOffset* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -840, 840);
}

EXTERN int asn1PD_DrivenLineOffsetLg (OSCTXT* pctxt, DrivenLineOffsetLg* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -32767, 32767);
}

EXTERN int asn1PD_DrivenLineOffsetSm (OSCTXT* pctxt, DrivenLineOffsetSm* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -2047, 2047);
}

EXTERN int asn1PD_DrivingWheelAngle (OSCTXT* pctxt, DrivingWheelAngle* pvalue)
{
   return pd_ConsInt8 (pctxt, pvalue, -128, 127);
}

EXTERN int asn1PD_DSecond (OSCTXT* pctxt, DSecond* pvalue)
{
   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   return rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 16);
}

EXTERN int asn1PD_DSRCmsgID (OSCTXT* pctxt, DSRCmsgID* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 32767) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_Duration (OSCTXT* pctxt, Duration* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 12);
   if (stat != 0) return stat;

   if (*pvalue > 3600) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_DYear (OSCTXT* pctxt, DYear* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 12);
   if (stat != 0) return stat;

   if (*pvalue > 4095) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_ElevationConfidence (OSCTXT* pctxt, ElevationConfidence* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 4);
}

EXTERN int asn1PD_Elevation (OSCTXT* pctxt, Elevation* pvalue)
{
   return pd_ConsInteger (pctxt, pvalue, -4096, 61439);
}

EXTERN int asn1PD_Extent (OSCTXT* pctxt, Extent* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 4);
}

EXTERN int asn1PD_ExteriorLights (OSCTXT* pctxt, ExteriorLights* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ExteriorLights: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(9), OSUINTCONST(9), OSUINTCONST(0), OSUINT32_MAX);

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         stat = PD_BYTE_ALIGN (pctxt);
         if (stat != 0) return stat;
      }

      PU_NEWFIELD (pctxt, "BitString");

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_ExteriorLights: end\n");

   return (stat);
}

EXTERN int asn1PD_FuelType (OSCTXT* pctxt, FuelType* pvalue)
{
   return rtxDecBitsToByte (pctxt, pvalue, 4);
}

EXTERN int asn1PD_FurtherInfoID (OSCTXT* pctxt, FurtherInfoID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_FurtherInfoID: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_FurtherInfoID: end\n");

   return (stat);
}

EXTERN int asn1PD_GNSSstatus (OSCTXT* pctxt, GNSSstatus* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GNSSstatus: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_GNSSstatus: end\n");

   return (stat);
}

EXTERN int asn1PD_GrossDistance (OSCTXT* pctxt, GrossDistance* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 10);
   if (stat != 0) return stat;

   if (*pvalue > 1023) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_GrossSpeed (OSCTXT* pctxt, GrossSpeed* pvalue)
{
   return rtxDecBitsToByte (pctxt, pvalue, 5);
}

EXTERN int asn1PD_HeadingConfidence (OSCTXT* pctxt, HeadingConfidence* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 3);
}

EXTERN int asn1PD_Heading (OSCTXT* pctxt, Heading* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 28800) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_HeadingSlice (OSCTXT* pctxt, HeadingSlice* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HeadingSlice: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_HeadingSlice: end\n");

   return (stat);
}

EXTERN int asn1PD_IntersectionID (OSCTXT* pctxt, IntersectionID* pvalue)
{
   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   return rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 16);
}

EXTERN int asn1PD_IntersectionStatusObject (OSCTXT* pctxt, IntersectionStatusObject* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionStatusObject: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionStatusObject: end\n");

   return (stat);
}

EXTERN int asn1PD_IsDolly (OSCTXT* pctxt, IsDolly* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_IsDolly: start\n");

   PU_NEWFIELD (pctxt, "boolean");

   stat = DEC_BIT (pctxt, pvalue);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_IsDolly: end\n");

   return (stat);
}

EXTERN int asn1PD_Iso3833VehicleType (OSCTXT* pctxt, Iso3833VehicleType* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 7);
   if (stat != 0) return stat;

   if (*pvalue > 100) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_ITIStextPhrase (OSCTXT* pctxt, ITIStextPhrase* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ITIStextPhrase: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_ConstrainedStringEx (pctxt, pvalue, 0, 8, 7, 7);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_ITIStextPhrase: end\n");

   return (stat);
}

EXTERN int asn1PD_AxleLocation (OSCTXT* pctxt, AxleLocation* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_AxleWeight (OSCTXT* pctxt, AxleWeight* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 16);
   if (stat != 0) return stat;

   if (*pvalue > 64255) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_CargoWeight (OSCTXT* pctxt, CargoWeight* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 16);
   if (stat != 0) return stat;

   if (*pvalue > 64255) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_DriveAxleLiftAirPressure (OSCTXT* pctxt, DriveAxleLiftAirPressure* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 10);
   if (stat != 0) return stat;

   if (*pvalue > 1000) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_DriveAxleLocation (OSCTXT* pctxt, DriveAxleLocation* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_DriveAxleLubePressure (OSCTXT* pctxt, DriveAxleLubePressure* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 250) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_DriveAxleTemperature (OSCTXT* pctxt, DriveAxleTemperature* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -40, 210);
}

EXTERN int asn1PD_SteeringAxleLubePressure (OSCTXT* pctxt, SteeringAxleLubePressure* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 250) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_SteeringAxleTemperature (OSCTXT* pctxt, SteeringAxleTemperature* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -40, 210);
}

EXTERN int asn1PD_TireLeakageRate (OSCTXT* pctxt, TireLeakageRate* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 16);
   if (stat != 0) return stat;

   if (*pvalue > 64255) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_TireLocation (OSCTXT* pctxt, TireLocation* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_TirePressureThresholdDetection (OSCTXT* pctxt, TirePressureThresholdDetection* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 3);
}

EXTERN int asn1PD_TirePressure (OSCTXT* pctxt, TirePressure* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 250) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_TireTemp (OSCTXT* pctxt, TireTemp* pvalue)
{
   return pd_ConsInteger (pctxt, pvalue, -8736, 55519);
}

EXTERN int asn1PD_TrailerWeight (OSCTXT* pctxt, TrailerWeight* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 16);
   if (stat != 0) return stat;

   if (*pvalue > 64255) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_WheelEndElectFault (OSCTXT* pctxt, WheelEndElectFault* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 2);
}

EXTERN int asn1PD_WheelSensorStatus (OSCTXT* pctxt, WheelSensorStatus* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 2);
}

EXTERN int asn1PD_LaneAttributes_Barrier (OSCTXT* pctxt, LaneAttributes_Barrier* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_Barrier: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_Barrier: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneAttributes_Bike (OSCTXT* pctxt, LaneAttributes_Bike* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_Bike: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_Bike: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneAttributes_Crosswalk (OSCTXT* pctxt, LaneAttributes_Crosswalk* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_Crosswalk: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_Crosswalk: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneAttributes_Parking (OSCTXT* pctxt, LaneAttributes_Parking* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_Parking: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_Parking: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneAttributes_Sidewalk (OSCTXT* pctxt, LaneAttributes_Sidewalk* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_Sidewalk: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_Sidewalk: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneAttributes_Striping (OSCTXT* pctxt, LaneAttributes_Striping* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_Striping: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_Striping: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneAttributes_TrackedVehicle (OSCTXT* pctxt, LaneAttributes_TrackedVehicle* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_TrackedVehicle: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_TrackedVehicle: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneAttributes_Vehicle (OSCTXT* pctxt, LaneAttributes_Vehicle* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_Vehicle: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), OSUINTCONST(0), OSUINT32_MAX);

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         stat = PD_BYTE_ALIGN (pctxt);
         if (stat != 0) return stat;
      }

      PU_NEWFIELD (pctxt, "BitString");

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes_Vehicle: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneConnectionID (OSCTXT* pctxt, LaneConnectionID* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_LaneDirection (OSCTXT* pctxt, LaneDirection* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneDirection: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneDirection: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneID (OSCTXT* pctxt, LaneID* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_LaneSharing (OSCTXT* pctxt, LaneSharing* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneSharing: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(10), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneSharing: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneWidth (OSCTXT* pctxt, LaneWidth* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 32767) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_Latitude (OSCTXT* pctxt, Latitude* pvalue)
{
   return pd_ConsInteger (pctxt, pvalue, -900000000, 900000001);
}

EXTERN int asn1PD_LayerID (OSCTXT* pctxt, LayerID* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 7);
   if (stat != 0) return stat;

   if (*pvalue > 100) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_LayerType (OSCTXT* pctxt, LayerType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_LayerType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LayerType: end\n");

   return (stat);
}

EXTERN int asn1PD_LightbarInUse (OSCTXT* pctxt, LightbarInUse* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 3);
}

EXTERN int asn1PD_Longitude (OSCTXT* pctxt, Longitude* pvalue)
{
   return pd_ConsInteger (pctxt, pvalue, -1799999999, 1800000001);
}

EXTERN int asn1PD_Location_quality (OSCTXT* pctxt, Location_quality* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 3);
}

EXTERN int asn1PD_Location_tech (OSCTXT* pctxt, Location_tech* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_Location_tech: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(9));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Location_tech: end\n");

   return (stat);
}

EXTERN int asn1PD_MergeDivergeNodeAngle (OSCTXT* pctxt, MergeDivergeNodeAngle* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -180, 180);
}

EXTERN int asn1PD_MessageBLOB (OSCTXT* pctxt, MessageBLOB* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MessageBLOB: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(2000), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_MessageBLOB: end\n");

   return (stat);
}

EXTERN int asn1PD_MinuteOfTheYear (OSCTXT* pctxt, MinuteOfTheYear* pvalue)
{
   return pd_ConsUnsigned (pctxt, pvalue, 0, 527040);
}

EXTERN int asn1PD_MinutesDuration (OSCTXT* pctxt, MinutesDuration* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 32000) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_MotorizedPropelledType (OSCTXT* pctxt, MotorizedPropelledType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_MotorizedPropelledType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MotorizedPropelledType: end\n");

   return (stat);
}

EXTERN int asn1PD_MovementPhaseState (OSCTXT* pctxt, MovementPhaseState* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 4);
}

EXTERN int asn1PD_MsgCount (OSCTXT* pctxt, MsgCount* pvalue)
{
   return rtxDecBitsToByte (pctxt, pvalue, 7);
}

EXTERN int asn1PD_MsgCRC (OSCTXT* pctxt, MsgCRC* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MsgCRC: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_MsgCRC: end\n");

   return (stat);
}

EXTERN int asn1PD_MultiVehicleResponse (OSCTXT* pctxt, MultiVehicleResponse* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 2);
}

EXTERN int asn1PD_MUTCDCode (OSCTXT* pctxt, MUTCDCode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_MUTCDCode: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MUTCDCode: end\n");

   return (stat);
}

EXTERN int asn1PD_NMEA_MsgType (OSCTXT* pctxt, NMEA_MsgType* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 32767) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_NMEA_Payload (OSCTXT* pctxt, NMEA_Payload* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NMEA_Payload: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1023), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_NMEA_Payload: end\n");

   return (stat);
}

EXTERN int asn1PD_NMEA_Revision (OSCTXT* pctxt, NMEA_Revision* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_NMEA_Revision: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NMEA_Revision: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeAttributeLL (OSCTXT* pctxt, NodeAttributeLL* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeLL: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(11));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeLL: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeAttributeXY (OSCTXT* pctxt, NodeAttributeXY* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeXY: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(11));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeXY: end\n");

   return (stat);
}

EXTERN int asn1PD_NumberOfParticipantsInCluster (OSCTXT* pctxt, NumberOfParticipantsInCluster* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_NumberOfParticipantsInCluster: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NumberOfParticipantsInCluster: end\n");

   return (stat);
}

EXTERN int asn1PD_ObjectCount (OSCTXT* pctxt, ObjectCount* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 10);
   if (stat != 0) return stat;

   if (*pvalue > 1023) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_ObstacleDirection (OSCTXT* pctxt, ObstacleDirection* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ObstacleDirection: start\n");

   stat = asn1PD_Angle (pctxt, pvalue);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_ObstacleDirection: end\n");

   return (stat);
}

EXTERN int asn1PD_ObstacleDistance (OSCTXT* pctxt, ObstacleDistance* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 32767) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_Offset_B09 (OSCTXT* pctxt, Offset_B09* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -256, 255);
}

EXTERN int asn1PD_Offset_B10 (OSCTXT* pctxt, Offset_B10* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -512, 511);
}

EXTERN int asn1PD_Offset_B11 (OSCTXT* pctxt, Offset_B11* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -1024, 1023);
}

EXTERN int asn1PD_Offset_B12 (OSCTXT* pctxt, Offset_B12* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -2048, 2047);
}

EXTERN int asn1PD_Offset_B13 (OSCTXT* pctxt, Offset_B13* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -4096, 4095);
}

EXTERN int asn1PD_Offset_B14 (OSCTXT* pctxt, Offset_B14* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -8192, 8191);
}

EXTERN int asn1PD_Offset_B16 (OSCTXT* pctxt, Offset_B16* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -32768, 32767);
}

EXTERN int asn1PD_OffsetLL_B12 (OSCTXT* pctxt, OffsetLL_B12* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -2048, 2047);
}

EXTERN int asn1PD_OffsetLL_B14 (OSCTXT* pctxt, OffsetLL_B14* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -8192, 8191);
}

EXTERN int asn1PD_OffsetLL_B16 (OSCTXT* pctxt, OffsetLL_B16* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -32768, 32767);
}

EXTERN int asn1PD_OffsetLL_B18 (OSCTXT* pctxt, OffsetLL_B18* pvalue)
{
   return pd_ConsInteger (pctxt, pvalue, -131072, 131071);
}

EXTERN int asn1PD_OffsetLL_B22 (OSCTXT* pctxt, OffsetLL_B22* pvalue)
{
   return pd_ConsInteger (pctxt, pvalue, -2097152, 2097151);
}

EXTERN int asn1PD_OffsetLL_B24 (OSCTXT* pctxt, OffsetLL_B24* pvalue)
{
   return pd_ConsInteger (pctxt, pvalue, -8388608, 8388607);
}

EXTERN int asn1PD_PayloadData (OSCTXT* pctxt, PayloadData* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PayloadData: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2048), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_PayloadData: end\n");

   return (stat);
}

EXTERN int asn1PD_PedestrianBicycleDetect (OSCTXT* pctxt, PedestrianBicycleDetect* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PedestrianBicycleDetect: start\n");

   PU_NEWFIELD (pctxt, "boolean");

   stat = DEC_BIT (pctxt, pvalue);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PedestrianBicycleDetect: end\n");

   return (stat);
}

EXTERN int asn1PD_HumanPropelledType (OSCTXT* pctxt, HumanPropelledType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_HumanPropelledType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HumanPropelledType: end\n");

   return (stat);
}

EXTERN int asn1PD_PersonalAssistive (OSCTXT* pctxt, PersonalAssistive* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PersonalAssistive: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), OSUINTCONST(0), OSUINT32_MAX);

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         stat = PD_BYTE_ALIGN (pctxt);
         if (stat != 0) return stat;
      }

      PU_NEWFIELD (pctxt, "BitString");

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PersonalAssistive: end\n");

   return (stat);
}

EXTERN int asn1PD_PersonalClusterRadius (OSCTXT* pctxt, PersonalClusterRadius* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 7);
   if (stat != 0) return stat;

   if (*pvalue > 100) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_PersonalCrossingInProgress (OSCTXT* pctxt, PersonalCrossingInProgress* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PersonalCrossingInProgress: start\n");

   PU_NEWFIELD (pctxt, "boolean");

   stat = DEC_BIT (pctxt, pvalue);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PersonalCrossingInProgress: end\n");

   return (stat);
}

EXTERN int asn1PD_PersonalCrossingRequest (OSCTXT* pctxt, PersonalCrossingRequest* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PersonalCrossingRequest: start\n");

   PU_NEWFIELD (pctxt, "boolean");

   stat = DEC_BIT (pctxt, pvalue);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PersonalCrossingRequest: end\n");

   return (stat);
}

EXTERN int asn1PD_PersonalDeviceUsageState (OSCTXT* pctxt, PersonalDeviceUsageState* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PersonalDeviceUsageState: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(9), OSUINTCONST(9), OSUINTCONST(0), OSUINT32_MAX);

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         stat = PD_BYTE_ALIGN (pctxt);
         if (stat != 0) return stat;
      }

      PU_NEWFIELD (pctxt, "BitString");

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PersonalDeviceUsageState: end\n");

   return (stat);
}

EXTERN int asn1PD_PersonalDeviceUserType (OSCTXT* pctxt, PersonalDeviceUserType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_PersonalDeviceUserType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(4));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PersonalDeviceUserType: end\n");

   return (stat);
}

EXTERN int asn1PD_PivotingAllowed (OSCTXT* pctxt, PivotingAllowed* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PivotingAllowed: start\n");

   PU_NEWFIELD (pctxt, "boolean");

   stat = DEC_BIT (pctxt, pvalue);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PivotingAllowed: end\n");

   return (stat);
}

EXTERN int asn1PD_PositionConfidence (OSCTXT* pctxt, PositionConfidence* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 4);
}

EXTERN int asn1PD_PrioritizationResponseStatus (OSCTXT* pctxt, PrioritizationResponseStatus* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrioritizationResponseStatus: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PrioritizationResponseStatus: end\n");

   return (stat);
}

EXTERN int asn1PD_Priority (OSCTXT* pctxt, Priority* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Priority: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_Priority: end\n");

   return (stat);
}

EXTERN int asn1PD_PriorityRequestType (OSCTXT* pctxt, PriorityRequestType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityRequestType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityRequestType: end\n");

   return (stat);
}

EXTERN int asn1PD_PrivilegedEventFlags (OSCTXT* pctxt, PrivilegedEventFlags* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivilegedEventFlags: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivilegedEventFlags: end\n");

   return (stat);
}

EXTERN int asn1PD_ProbeSegmentNumber (OSCTXT* pctxt, ProbeSegmentNumber* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 32767) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_PublicSafetyAndRoadWorkerActivity (OSCTXT* pctxt, PublicSafetyAndRoadWorkerActivity* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PublicSafetyAndRoadWorkerActivity: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), OSUINTCONST(0), OSUINT32_MAX);

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         stat = PD_BYTE_ALIGN (pctxt);
         if (stat != 0) return stat;
      }

      PU_NEWFIELD (pctxt, "BitString");

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PublicSafetyAndRoadWorkerActivity: end\n");

   return (stat);
}

EXTERN int asn1PD_PublicSafetyDirectingTrafficSubType (OSCTXT* pctxt, PublicSafetyDirectingTrafficSubType* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PublicSafetyDirectingTrafficSubType: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(7), OSUINTCONST(7), OSUINTCONST(0), OSUINT32_MAX);

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         stat = PD_BYTE_ALIGN (pctxt);
         if (stat != 0) return stat;
      }

      PU_NEWFIELD (pctxt, "BitString");

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PublicSafetyDirectingTrafficSubType: end\n");

   return (stat);
}

EXTERN int asn1PD_PublicSafetyEventResponderWorkerType (OSCTXT* pctxt, PublicSafetyEventResponderWorkerType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_PublicSafetyEventResponderWorkerType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PublicSafetyEventResponderWorkerType: end\n");

   return (stat);
}

EXTERN int asn1PD_RadiusOfCurvature (OSCTXT* pctxt, RadiusOfCurvature* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -32767, 32767);
}

EXTERN int asn1PD_Radius_B12 (OSCTXT* pctxt, Radius_B12* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 12);
   if (stat != 0) return stat;

   if (*pvalue > 4095) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_RainSensor (OSCTXT* pctxt, RainSensor* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 3);
}

EXTERN int asn1PD_RegionId (OSCTXT* pctxt, RegionId* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_RequestedItem (OSCTXT* pctxt, RequestedItem* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestedItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(16));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestedItem: end\n");

   return (stat);
}

EXTERN int asn1PD_RequestID (OSCTXT* pctxt, RequestID* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_RequestImportanceLevel (OSCTXT* pctxt, RequestImportanceLevel* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 4);
}

EXTERN int asn1PD_RequestSubRole (OSCTXT* pctxt, RequestSubRole* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 4);
}

EXTERN int asn1PD_ResponseType (OSCTXT* pctxt, ResponseType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_ResponseType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ResponseType: end\n");

   return (stat);
}

EXTERN int asn1PD_RestrictionAppliesTo (OSCTXT* pctxt, RestrictionAppliesTo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_RestrictionAppliesTo: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(13));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RestrictionAppliesTo: end\n");

   return (stat);
}

EXTERN int asn1PD_RestrictionClassID (OSCTXT* pctxt, RestrictionClassID* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_RoadRegulatorID (OSCTXT* pctxt, RoadRegulatorID* pvalue)
{
   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   return rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 16);
}

EXTERN int asn1PD_RoadSegmentID (OSCTXT* pctxt, RoadSegmentID* pvalue)
{
   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   return rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 16);
}

EXTERN int asn1PD_RoadwayCrownAngle (OSCTXT* pctxt, RoadwayCrownAngle* pvalue)
{
   return pd_ConsInt8 (pctxt, pvalue, -128, 127);
}

EXTERN int asn1PD_RTCM_Revision (OSCTXT* pctxt, RTCM_Revision* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_RTCM_Revision: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RTCM_Revision: end\n");

   return (stat);
}

EXTERN int asn1PD_RTCMmessage (OSCTXT* pctxt, RTCMmessage* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RTCMmessage: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1023), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_RTCMmessage: end\n");

   return (stat);
}

EXTERN int asn1PD_Scale_B12 (OSCTXT* pctxt, Scale_B12* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -2048, 2047);
}

EXTERN int asn1PD_SecondOfTime (OSCTXT* pctxt, SecondOfTime* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 6);
   if (stat != 0) return stat;

   if (*pvalue > 61) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_SegmentAttributeLL (OSCTXT* pctxt, SegmentAttributeLL* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_SegmentAttributeLL: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(37));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SegmentAttributeLL: end\n");

   return (stat);
}

EXTERN int asn1PD_SegmentAttributeXY (OSCTXT* pctxt, SegmentAttributeXY* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_SegmentAttributeXY: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(37));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SegmentAttributeXY: end\n");

   return (stat);
}

EXTERN int asn1PD_SemiMajorAxisAccuracy (OSCTXT* pctxt, SemiMajorAxisAccuracy* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_SemiMajorAxisOrientation (OSCTXT* pctxt, SemiMajorAxisOrientation* pvalue)
{
   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   return rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 16);
}

EXTERN int asn1PD_SemiMinorAxisAccuracy (OSCTXT* pctxt, SemiMinorAxisAccuracy* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_SignalGroupID (OSCTXT* pctxt, SignalGroupID* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_SignalReqScheme (OSCTXT* pctxt, SignalReqScheme* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalReqScheme: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalReqScheme: end\n");

   return (stat);
}

EXTERN int asn1PD_SignPrority (OSCTXT* pctxt, SignPrority* pvalue)
{
   return rtxDecBitsToByte (pctxt, pvalue, 3);
}

EXTERN int asn1PD_SirenInUse (OSCTXT* pctxt, SirenInUse* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 2);
}

EXTERN int asn1PD_SpeedAdvice (OSCTXT* pctxt, SpeedAdvice* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 9);
   if (stat != 0) return stat;

   if (*pvalue > 500) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_SpeedConfidence (OSCTXT* pctxt, SpeedConfidence* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 3);
}

EXTERN int asn1PD_SpeedLimitType (OSCTXT* pctxt, SpeedLimitType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedLimitType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(12));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedLimitType: end\n");

   return (stat);
}

EXTERN int asn1PD_SpeedProfileMeasurement (OSCTXT* pctxt, SpeedProfileMeasurement* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedProfileMeasurement: start\n");

   stat = asn1PD_GrossSpeed (pctxt, pvalue);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedProfileMeasurement: end\n");

   return (stat);
}

EXTERN int asn1PD_Speed (OSCTXT* pctxt, Speed* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 13);
   if (stat != 0) return stat;

   if (*pvalue > 8191) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_SSPindex (OSCTXT* pctxt, SSPindex* pvalue)
{
   return rtxDecBitsToByte (pctxt, pvalue, 5);
}

EXTERN int asn1PD_StabilityControlStatus (OSCTXT* pctxt, StabilityControlStatus* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 2);
}

EXTERN int asn1PD_StationID (OSCTXT* pctxt, StationID* pvalue)
{
   return pd_ConsUnsigned (pctxt, pvalue, 0, OSUINT32_MAX);
}

EXTERN int asn1PD_SteeringWheelAngleConfidence (OSCTXT* pctxt, SteeringWheelAngleConfidence* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 2);
}

EXTERN int asn1PD_SteeringWheelAngleRateOfChange (OSCTXT* pctxt, SteeringWheelAngleRateOfChange* pvalue)
{
   return pd_ConsInt8 (pctxt, pvalue, -127, 127);
}

EXTERN int asn1PD_SteeringWheelAngle (OSCTXT* pctxt, SteeringWheelAngle* pvalue)
{
   return pd_ConsInt8 (pctxt, pvalue, -126, 127);
}

EXTERN int asn1PD_SunSensor (OSCTXT* pctxt, SunSensor* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 10);
   if (stat != 0) return stat;

   if (*pvalue > 1000) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_TemporaryID (OSCTXT* pctxt, TemporaryID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TemporaryID: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_TemporaryID: end\n");

   return (stat);
}

EXTERN int asn1PD_TermDistance (OSCTXT* pctxt, TermDistance* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 15);
   if (stat != 0) return stat;

   if (*pvalue > 29999) return RTERR_CONSVIO;

   *pvalue += 1;

   return stat;
}

EXTERN int asn1PD_TermTime (OSCTXT* pctxt, TermTime* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 11);
   if (stat != 0) return stat;

   if (*pvalue > 1799) return RTERR_CONSVIO;

   *pvalue += 1;

   return stat;
}

EXTERN int asn1PD_ThrottleConfidence (OSCTXT* pctxt, ThrottleConfidence* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 2);
}

EXTERN int asn1PD_ThrottlePosition (OSCTXT* pctxt, ThrottlePosition* pvalue)
{
   int stat;

   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   if (*pvalue > 200) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_TimeConfidence (OSCTXT* pctxt, TimeConfidence* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 6);
}

EXTERN int asn1PD_TimeIntervalConfidence (OSCTXT* pctxt, TimeIntervalConfidence* pvalue)
{
   return rtxDecBitsToByte (pctxt, pvalue, 4);
}

EXTERN int asn1PD_TimeMark (OSCTXT* pctxt, TimeMark* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 16);
   if (stat != 0) return stat;

   if (*pvalue > 36001) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_TimeOffset (OSCTXT* pctxt, TimeOffset* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 16);
   if (stat != 0) return stat;

   if (*pvalue > 65534) return RTERR_CONSVIO;

   *pvalue += 1;

   return stat;
}

EXTERN int asn1PD_TractionControlStatus (OSCTXT* pctxt, TractionControlStatus* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 2);
}

EXTERN int asn1PD_TrailerMass (OSCTXT* pctxt, TrailerMass* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_TransitStatus (OSCTXT* pctxt, TransitStatus* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransitStatus: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(6), OSUINTCONST(6), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransitStatus: end\n");

   return (stat);
}

EXTERN int asn1PD_TransitVehicleOccupancy (OSCTXT* pctxt, TransitVehicleOccupancy* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 3);
}

EXTERN int asn1PD_TransitVehicleStatus (OSCTXT* pctxt, TransitVehicleStatus* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransitVehicleStatus: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransitVehicleStatus: end\n");

   return (stat);
}

EXTERN int asn1PD_TransmissionState (OSCTXT* pctxt, TransmissionState* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 3);
}

EXTERN int asn1PD_TravelerInfoType (OSCTXT* pctxt, TravelerInfoType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerInfoType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerInfoType: end\n");

   return (stat);
}

EXTERN int asn1PD_UniqueMSGID (OSCTXT* pctxt, UniqueMSGID* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UniqueMSGID: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(9), OSUINTCONST(9), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_UniqueMSGID: end\n");

   return (stat);
}

EXTERN int asn1PD_URL_Base (OSCTXT* pctxt, URL_Base* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_URL_Base: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(45), 0, 0);

   stat = pd_ConstrainedStringEx (pctxt, pvalue, 0, 8, 7, 7);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_URL_Base: end\n");

   return (stat);
}

EXTERN int asn1PD_URL_Link (OSCTXT* pctxt, URL_Link* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_URL_Link: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pd_ConstrainedStringEx (pctxt, pvalue, 0, 8, 7, 7);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_URL_Link: end\n");

   return (stat);
}

EXTERN int asn1PD_URL_Short (OSCTXT* pctxt, URL_Short* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_URL_Short: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(15), 0, 0);

   stat = pd_ConstrainedStringEx (pctxt, pvalue, 0, 8, 7, 7);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_URL_Short: end\n");

   return (stat);
}

EXTERN int asn1PD_UserSizeAndBehaviour (OSCTXT* pctxt, UserSizeAndBehaviour* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UserSizeAndBehaviour: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), OSUINTCONST(0), OSUINT32_MAX);

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         stat = PD_BYTE_ALIGN (pctxt);
         if (stat != 0) return stat;
      }

      PU_NEWFIELD (pctxt, "BitString");

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UserSizeAndBehaviour: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleEventFlags (OSCTXT* pctxt, VehicleEventFlags* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleEventFlags: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(13), OSUINTCONST(13), OSUINTCONST(0), OSUINT32_MAX);

   {
      OSSIZE numbits;
      Asn1SizeCnst sizeCnst = ACINFO(pctxt)->sizeConstraint;

      if (0 != pvalue->extdata) {
         rtxMemFreePtr (pctxt, pvalue->extdata);
         pvalue->extdata = 0;
      }
      stat = pd_Length64 (pctxt, &numbits);
      if (stat != 0) return stat;

      if (pctxt->buffer.aligned && 
         pu_BitAndOctetStringAlignmentTest (&sizeCnst, numbits, TRUE)) {
         stat = PD_BYTE_ALIGN (pctxt);
         if (stat != 0) return stat;
      }

      PU_NEWFIELD (pctxt, "BitString");

      if (numbits > sizeof(pvalue->data)*8) {
         OSSIZE rembits = numbits - sizeof(pvalue->data)*8;
         OSSIZE rembytes = rembits/8 + 1;

         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), sizeof(pvalue->data)*8);
         if (stat != 0) return stat;

         pvalue->extdata = (OSOCTET*)rtxMemAllocZ (pctxt, rembytes);
         if (0 == pvalue->extdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pvalue->
            extdata, rembytes, rembits);
         if (stat != 0) return stat;
      }
      else {
         stat = rtxDecBitsToByteArray (pctxt, pvalue->data, sizeof(pvalue->
            data), numbits);
         if (stat != 0) return stat;
      }
      pvalue->numbits = (OSUINT32) numbits;
   }

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleEventFlags: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleHeight (OSCTXT* pctxt, VehicleHeight* pvalue)
{
   return rtxDecBitsToByte (pctxt, pvalue, 7);
}

EXTERN int asn1PD_VehicleLength (OSCTXT* pctxt, VehicleLength* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 12);
   if (stat != 0) return stat;

   if (*pvalue > 4095) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_VehicleMass (OSCTXT* pctxt, VehicleMass* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return stat;

   return stat;
}

EXTERN int asn1PD_VehicleStatusDeviceTypeTag (OSCTXT* pctxt, VehicleStatusDeviceTypeTag* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatusDeviceTypeTag: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(28));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatusDeviceTypeTag: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleType (OSCTXT* pctxt, VehicleType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(15));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleType: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleWidth (OSCTXT* pctxt, VehicleWidth* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 10);
   if (stat != 0) return stat;

   if (*pvalue > 1023) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_Velocity (OSCTXT* pctxt, Velocity* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 13);
   if (stat != 0) return stat;

   if (*pvalue > 8191) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_VerticalAccelerationThreshold (OSCTXT* pctxt, VerticalAccelerationThreshold* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VerticalAccelerationThreshold: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(5), OSUINTCONST(5), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_VerticalAccelerationThreshold: end\n");

   return (stat);
}

EXTERN int asn1PD_VerticalAcceleration (OSCTXT* pctxt, VerticalAcceleration* pvalue)
{
   return pd_ConsInt8 (pctxt, pvalue, -127, 127);
}

EXTERN int asn1PD_VertOffset_B07 (OSCTXT* pctxt, VertOffset_B07* pvalue)
{
   return pd_ConsInt8 (pctxt, pvalue, -64, 63);
}

EXTERN int asn1PD_VertOffset_B08 (OSCTXT* pctxt, VertOffset_B08* pvalue)
{
   return pd_ConsInt8 (pctxt, pvalue, -128, 127);
}

EXTERN int asn1PD_VertOffset_B09 (OSCTXT* pctxt, VertOffset_B09* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -256, 255);
}

EXTERN int asn1PD_VertOffset_B10 (OSCTXT* pctxt, VertOffset_B10* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -512, 511);
}

EXTERN int asn1PD_VertOffset_B11 (OSCTXT* pctxt, VertOffset_B11* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -1024, 1023);
}

EXTERN int asn1PD_VertOffset_B12 (OSCTXT* pctxt, VertOffset_B12* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -2048, 2047);
}

EXTERN int asn1PD_VINstring (OSCTXT* pctxt, VINstring* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VINstring: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(17), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_VINstring: end\n");

   return (stat);
}

EXTERN int asn1PD_WaitOnStopline (OSCTXT* pctxt, WaitOnStopline* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_WaitOnStopline: start\n");

   PU_NEWFIELD (pctxt, "boolean");

   stat = DEC_BIT (pctxt, pvalue);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_WaitOnStopline: end\n");

   return (stat);
}

EXTERN int asn1PD_WiperRate (OSCTXT* pctxt, WiperRate* pvalue)
{
   return rtxDecBitsToByte (pctxt, pvalue, 7);
}

EXTERN int asn1PD_WiperStatus (OSCTXT* pctxt, WiperStatus* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_WiperStatus: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
      if (stat != 0) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_WiperStatus: end\n");

   return (stat);
}

EXTERN int asn1PD_YawRateConfidence (OSCTXT* pctxt, YawRateConfidence* pvalue)
{
   return rtxDecBits (pctxt, pvalue, 3);
}

EXTERN int asn1PD_YawRate (OSCTXT* pctxt, YawRate* pvalue)
{
   return pd_ConsInt16 (pctxt, pvalue, -32767, 32767);
}

EXTERN int asn1PD_ZoneLength (OSCTXT* pctxt, ZoneLength* pvalue)
{
   int stat;

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 14);
   if (stat != 0) return stat;

   if (*pvalue > 10000) return RTERR_CONSVIO;

   return stat;
}

EXTERN int asn1PD_Zoom (OSCTXT* pctxt, Zoom* pvalue)
{
   return rtxDecBitsToByte (pctxt, pvalue, 4);
}

EXTERN int asn1PD_MessageFrame (OSCTXT* pctxt, MessageFrame* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_MessageFrame: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode messageId */
   stat = asn1PD_DSRCmsgID (pctxt, &pvalue->messageId);
   if (stat != 0) return stat;

   /* decode value */
   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MessageFrame: end\n");

   return (stat);
}

EXTERN int asn1PD_PositionalAccuracy (OSCTXT* pctxt, PositionalAccuracy* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PositionalAccuracy: start\n");

   /* decode root elements */
   /* decode semiMajor */
   stat = asn1PD_SemiMajorAxisAccuracy (pctxt, &pvalue->semiMajor);
   if (stat != 0) return stat;

   /* decode semiMinor */
   stat = asn1PD_SemiMinorAxisAccuracy (pctxt, &pvalue->semiMinor);
   if (stat != 0) return stat;

   /* decode orientation */
   stat = asn1PD_SemiMajorAxisOrientation (pctxt, &pvalue->orientation);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_PositionalAccuracy: end\n");

   return (stat);
}

EXTERN int asn1PD_AccelerationSet4Way (OSCTXT* pctxt, AccelerationSet4Way* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AccelerationSet4Way: start\n");

   /* decode root elements */
   /* decode long_ */
   stat = asn1PD_Acceleration (pctxt, &pvalue->long_);
   if (stat != 0) return stat;

   /* decode lat */
   stat = asn1PD_Acceleration (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   /* decode vert */
   stat = asn1PD_VerticalAcceleration (pctxt, &pvalue->vert);
   if (stat != 0) return stat;

   /* decode yaw */
   stat = asn1PD_YawRate (pctxt, &pvalue->yaw);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_AccelerationSet4Way: end\n");

   return (stat);
}

EXTERN int asn1PD_BrakeSystemStatus (OSCTXT* pctxt, BrakeSystemStatus* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_BrakeSystemStatus: start\n");

   /* decode root elements */
   /* decode wheelBrakes */
   stat = asn1PD_BrakeAppliedStatus (pctxt, &pvalue->wheelBrakes);
   if (stat != 0) return stat;

   /* decode traction */
   stat = asn1PD_TractionControlStatus (pctxt, &pvalue->traction);
   if (stat != 0) return stat;

   /* decode abs_ */
   stat = asn1PD_AntiLockBrakeStatus (pctxt, &pvalue->abs_);
   if (stat != 0) return stat;

   /* decode scs */
   stat = asn1PD_StabilityControlStatus (pctxt, &pvalue->scs);
   if (stat != 0) return stat;

   /* decode brakeBoost */
   stat = asn1PD_BrakeBoostApplied (pctxt, &pvalue->brakeBoost);
   if (stat != 0) return stat;

   /* decode auxBrakes */
   stat = asn1PD_AuxiliaryBrakeStatus (pctxt, &pvalue->auxBrakes);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_BrakeSystemStatus: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleSize (OSCTXT* pctxt, VehicleSize* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleSize: start\n");

   /* decode root elements */
   /* decode width */
   stat = asn1PD_VehicleWidth (pctxt, &pvalue->width);
   if (stat != 0) return stat;

   /* decode length */
   stat = asn1PD_VehicleLength (pctxt, &pvalue->length);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleSize: end\n");

   return (stat);
}

EXTERN int asn1PD_BSMcoreData (OSCTXT* pctxt, BSMcoreData* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_BSMcoreData: start\n");

   /* decode root elements */
   /* decode msgCnt */
   stat = asn1PD_MsgCount (pctxt, &pvalue->msgCnt);
   if (stat != 0) return stat;

   /* decode id */
   stat = asn1PD_TemporaryID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* decode secMark */
   stat = asn1PD_DSecond (pctxt, &pvalue->secMark);
   if (stat != 0) return stat;

   /* decode lat */
   stat = asn1PD_Latitude (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   /* decode long_ */
   stat = asn1PD_Longitude (pctxt, &pvalue->long_);
   if (stat != 0) return stat;

   /* decode elev */
   stat = asn1PD_Elevation (pctxt, &pvalue->elev);
   if (stat != 0) return stat;

   /* decode accuracy */
   stat = asn1PD_PositionalAccuracy (pctxt, &pvalue->accuracy);
   if (stat != 0) return stat;

   /* decode transmission */
   stat = asn1PD_TransmissionState (pctxt, &pvalue->transmission);
   if (stat != 0) return stat;

   /* decode speed */
   stat = asn1PD_Speed (pctxt, &pvalue->speed);
   if (stat != 0) return stat;

   /* decode heading */
   stat = asn1PD_Heading (pctxt, &pvalue->heading);
   if (stat != 0) return stat;

   /* decode angle */
   stat = asn1PD_SteeringWheelAngle (pctxt, &pvalue->angle);
   if (stat != 0) return stat;

   /* decode accelSet */
   stat = asn1PD_AccelerationSet4Way (pctxt, &pvalue->accelSet);
   if (stat != 0) return stat;

   /* decode brakes */
   stat = asn1PD_BrakeSystemStatus (pctxt, &pvalue->brakes);
   if (stat != 0) return stat;

   /* decode size */
   stat = asn1PD_VehicleSize (pctxt, &pvalue->size);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_BSMcoreData: end\n");

   return (stat);
}

EXTERN int asn1PD_PartIIcontent (OSCTXT* pctxt, PartIIcontent* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PartIIcontent: start\n");

   /* decode root elements */
   /* decode partII_Id */
   stat = asn1PD_PartII_Id (pctxt, &pvalue->partII_Id);
   if (stat != 0) return stat;

   /* decode partII_Value */
   stat = pd_OpenType (pctxt, &pvalue->partII_Value.data, &pvalue->partII_Value.numocts);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_PartIIcontent: end\n");

   return (stat);
}

EXTERN int asn1PD_BasicSafetyMessage_partII (OSCTXT* pctxt, BasicSafetyMessage_partII* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_BasicSafetyMessage_partII: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PartIIcontent* pdata;
      rtxDListAllocNodeAndData (pctxt, PartIIcontent, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_PartIIcontent (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PartIIcontent (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BasicSafetyMessage_partII: end\n");

   return (stat);
}

EXTERN int asn1PD_RegionalExtension (OSCTXT* pctxt, RegionalExtension* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RegionalExtension: start\n");

   /* decode root elements */
   /* decode regionId */
   stat = asn1PD_RegionId (pctxt, &pvalue->regionId);
   if (stat != 0) return stat;

   /* decode regExtValue */
   stat = pd_OpenType (pctxt, &pvalue->regExtValue.data, &pvalue->regExtValue.numocts);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_RegionalExtension: end\n");

   return (stat);
}

EXTERN int asn1PD_BasicSafetyMessage_regional (OSCTXT* pctxt, BasicSafetyMessage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_BasicSafetyMessage_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BasicSafetyMessage_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_BasicSafetyMessage (OSCTXT* pctxt, BasicSafetyMessage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_BasicSafetyMessage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode coreData */
   stat = asn1PD_BSMcoreData (pctxt, &pvalue->coreData);
   if (stat != 0) return stat;

   /* decode partII */
   if (optbits[0]) {
      pvalue->m.partIIPresent = 1;

      stat = asn1PD_BasicSafetyMessage_partII (pctxt, &pvalue->partII);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_BasicSafetyMessage_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BasicSafetyMessage: end\n");

   return (stat);
}

EXTERN int asn1PD_RequestedItemList (OSCTXT* pctxt, RequestedItemList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestedItemList: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 5);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 32){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_RequestedItem (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestedItemList: end\n");

   return (stat);
}

EXTERN int asn1PD_CommonSafetyRequest_regional (OSCTXT* pctxt, CommonSafetyRequest_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonSafetyRequest_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonSafetyRequest_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_CommonSafetyRequest (OSCTXT* pctxt, CommonSafetyRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonSafetyRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->timeStamp);

         }
         break;

         case 1:
         /* decode msgCnt */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.msgCntPresent = 1;

            stat = asn1PD_MsgCount (pctxt, &pvalue->msgCnt);

         }
         break;

         case 2:
         /* decode id */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.idPresent = 1;

            stat = asn1PD_TemporaryID (pctxt, &pvalue->id);

         }
         break;

         case 3:
         /* decode requests */
         stat = asn1PD_RequestedItemList (pctxt, &pvalue->requests);

         break;

         case 4:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_CommonSafetyRequest_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonSafetyRequest: end\n");

   return (stat);
}

EXTERN int asn1PD_RoadSideAlert_description (OSCTXT* pctxt, RoadSideAlert_description* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSideAlert_description: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 8){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_ITIScodes (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSideAlert_description: end\n");

   return (stat);
}

EXTERN int asn1PD_DDateTime (OSCTXT* pctxt, DDateTime* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[7];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DDateTime: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode year */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.yearPresent = 1;

            stat = asn1PD_DYear (pctxt, &pvalue->year);

         }
         break;

         case 1:
         /* decode month */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.monthPresent = 1;

            stat = asn1PD_DMonth (pctxt, &pvalue->month);

         }
         break;

         case 2:
         /* decode day */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.dayPresent = 1;

            stat = asn1PD_DDay (pctxt, &pvalue->day);

         }
         break;

         case 3:
         /* decode hour */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.hourPresent = 1;

            stat = asn1PD_DHour (pctxt, &pvalue->hour);

         }
         break;

         case 4:
         /* decode minute */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.minutePresent = 1;

            stat = asn1PD_DMinute (pctxt, &pvalue->minute);

         }
         break;

         case 5:
         /* decode second */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.secondPresent = 1;

            stat = asn1PD_DSecond (pctxt, &pvalue->second);

         }
         break;

         case 6:
         /* decode offset */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.offsetPresent = 1;

            stat = asn1PD_DOffset (pctxt, &pvalue->offset);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DDateTime: end\n");

   return (stat);
}

EXTERN int asn1PD_TransmissionAndSpeed (OSCTXT* pctxt, TransmissionAndSpeed* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmissionAndSpeed: start\n");

   /* decode root elements */
   /* decode transmisson */
   stat = asn1PD_TransmissionState (pctxt, &pvalue->transmisson);
   if (stat != 0) return stat;

   /* decode speed */
   stat = asn1PD_Velocity (pctxt, &pvalue->speed);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_TransmissionAndSpeed: end\n");

   return (stat);
}

EXTERN int asn1PD_PositionConfidenceSet (OSCTXT* pctxt, PositionConfidenceSet* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PositionConfidenceSet: start\n");

   /* decode root elements */
   /* decode pos */
   stat = asn1PD_PositionConfidence (pctxt, &pvalue->pos);
   if (stat != 0) return stat;

   /* decode elevation */
   stat = asn1PD_ElevationConfidence (pctxt, &pvalue->elevation);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_PositionConfidenceSet: end\n");

   return (stat);
}

EXTERN int asn1PD_SpeedandHeadingandThrottleConfidence (OSCTXT* pctxt, SpeedandHeadingandThrottleConfidence* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedandHeadingandThrottleConfidence: start\n");

   /* decode root elements */
   /* decode heading */
   stat = asn1PD_HeadingConfidence (pctxt, &pvalue->heading);
   if (stat != 0) return stat;

   /* decode speed */
   stat = asn1PD_SpeedConfidence (pctxt, &pvalue->speed);
   if (stat != 0) return stat;

   /* decode throttle */
   stat = asn1PD_ThrottleConfidence (pctxt, &pvalue->throttle);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedandHeadingandThrottleConfidence: end\n");

   return (stat);
}

EXTERN int asn1PD_FullPositionVector (OSCTXT* pctxt, FullPositionVector* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[8];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_FullPositionVector: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 8; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 10; i_++) {
      switch (i_) {
         case 0:
         /* decode utcTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.utcTimePresent = 1;

            stat = asn1PD_DDateTime (pctxt, &pvalue->utcTime);

         }
         break;

         case 1:
         /* decode long_ */
         stat = asn1PD_Longitude (pctxt, &pvalue->long_);

         break;

         case 2:
         /* decode lat */
         stat = asn1PD_Latitude (pctxt, &pvalue->lat);

         break;

         case 3:
         /* decode elevation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.elevationPresent = 1;

            stat = asn1PD_Elevation (pctxt, &pvalue->elevation);

         }
         break;

         case 4:
         /* decode heading */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.headingPresent = 1;

            stat = asn1PD_Heading (pctxt, &pvalue->heading);

         }
         break;

         case 5:
         /* decode speed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.speedPresent = 1;

            stat = asn1PD_TransmissionAndSpeed (pctxt, &pvalue->speed);

         }
         break;

         case 6:
         /* decode posAccuracy */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.posAccuracyPresent = 1;

            stat = asn1PD_PositionalAccuracy (pctxt, &pvalue->posAccuracy);

         }
         break;

         case 7:
         /* decode timeConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeConfidencePresent = 1;

            stat = asn1PD_TimeConfidence (pctxt, &pvalue->timeConfidence);

         }
         break;

         case 8:
         /* decode posConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.posConfidencePresent = 1;

            stat = asn1PD_PositionConfidenceSet (pctxt, &pvalue->posConfidence);

         }
         break;

         case 9:
         /* decode speedConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.speedConfidencePresent = 1;

            stat = asn1PD_SpeedandHeadingandThrottleConfidence (pctxt, &pvalue->speedConfidence);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FullPositionVector: end\n");

   return (stat);
}

EXTERN int asn1PD_RoadSideAlert_regional (OSCTXT* pctxt, RoadSideAlert_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSideAlert_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSideAlert_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_RoadSideAlert (OSCTXT* pctxt, RoadSideAlert* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[8];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSideAlert: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 8; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 10; i_++) {
      switch (i_) {
         case 0:
         /* decode msgCnt */
         stat = asn1PD_MsgCount (pctxt, &pvalue->msgCnt);

         break;

         case 1:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->timeStamp);

         }
         break;

         case 2:
         /* decode typeEvent */
         stat = asn1PD_ITIScodes (pctxt, &pvalue->typeEvent);

         break;

         case 3:
         /* decode description */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.descriptionPresent = 1;

            stat = asn1PD_RoadSideAlert_description (pctxt, &pvalue->description);

         }
         break;

         case 4:
         /* decode priority */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.priorityPresent = 1;

            stat = asn1PD_Priority (pctxt, &pvalue->priority);

         }
         break;

         case 5:
         /* decode heading */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.headingPresent = 1;

            stat = asn1PD_HeadingSlice (pctxt, &pvalue->heading);

         }
         break;

         case 6:
         /* decode extent */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.extentPresent = 1;

            stat = asn1PD_Extent (pctxt, &pvalue->extent);

         }
         break;

         case 7:
         /* decode position */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.positionPresent = 1;

            stat = asn1PD_FullPositionVector (pctxt, &pvalue->position);

         }
         break;

         case 8:
         /* decode furtherInfoID */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.furtherInfoIDPresent = 1;

            stat = asn1PD_FurtherInfoID (pctxt, &pvalue->furtherInfoID);

         }
         break;

         case 9:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_RoadSideAlert_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSideAlert: end\n");

   return (stat);
}

EXTERN int asn1PD_PrivilegedEvents (OSCTXT* pctxt, PrivilegedEvents* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivilegedEvents: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode sspRights */
   stat = asn1PD_SSPindex (pctxt, &pvalue->sspRights);
   if (stat != 0) return stat;

   /* decode event */
   stat = asn1PD_PrivilegedEventFlags (pctxt, &pvalue->event);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivilegedEvents: end\n");

   return (stat);
}

EXTERN int asn1PD_EmergencyDetails (OSCTXT* pctxt, EmergencyDetails* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyDetails: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode sspRights */
   stat = asn1PD_SSPindex (pctxt, &pvalue->sspRights);
   if (stat != 0) return stat;

   /* decode sirenUse */
   stat = asn1PD_SirenInUse (pctxt, &pvalue->sirenUse);
   if (stat != 0) return stat;

   /* decode lightsUse */
   stat = asn1PD_LightbarInUse (pctxt, &pvalue->lightsUse);
   if (stat != 0) return stat;

   /* decode multi */
   stat = asn1PD_MultiVehicleResponse (pctxt, &pvalue->multi);
   if (stat != 0) return stat;

   /* decode events */
   if (optbits[0]) {
      pvalue->m.eventsPresent = 1;

      stat = asn1PD_PrivilegedEvents (pctxt, &pvalue->events);
      if (stat != 0) return stat;

   }

   /* decode responseType */
   if (optbits[1]) {
      pvalue->m.responseTypePresent = 1;

      stat = asn1PD_ResponseType (pctxt, &pvalue->responseType);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyDetails: end\n");

   return (stat);
}

EXTERN int asn1PD_EmergencyVehicleAlert_regional (OSCTXT* pctxt, EmergencyVehicleAlert_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyVehicleAlert_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyVehicleAlert_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_EmergencyVehicleAlert (OSCTXT* pctxt, EmergencyVehicleAlert* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[10];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyVehicleAlert: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 10; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 11; i_++) {
      switch (i_) {
         case 0:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->timeStamp);

         }
         break;

         case 1:
         /* decode id */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.idPresent = 1;

            stat = asn1PD_TemporaryID (pctxt, &pvalue->id);

         }
         break;

         case 2:
         /* decode rsaMsg */
         stat = asn1PD_RoadSideAlert (pctxt, &pvalue->rsaMsg);

         break;

         case 3:
         /* decode responseType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.responseTypePresent = 1;

            stat = asn1PD_ResponseType (pctxt, &pvalue->responseType);

         }
         break;

         case 4:
         /* decode details */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.detailsPresent = 1;

            stat = asn1PD_EmergencyDetails (pctxt, &pvalue->details);

         }
         break;

         case 5:
         /* decode mass */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.massPresent = 1;

            stat = asn1PD_VehicleMass (pctxt, &pvalue->mass);

         }
         break;

         case 6:
         /* decode basicType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.basicTypePresent = 1;

            stat = asn1PD_VehicleType (pctxt, &pvalue->basicType);

         }
         break;

         case 7:
         /* decode vehicleType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.vehicleTypePresent = 1;

            stat = asn1PD_VehicleGroupAffected (pctxt, &pvalue->vehicleType);

         }
         break;

         case 8:
         /* decode responseEquip */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.responseEquipPresent = 1;

            stat = asn1PD_IncidentResponseEquipment (pctxt, &pvalue->responseEquip);

         }
         break;

         case 9:
         /* decode responderType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.responderTypePresent = 1;

            stat = asn1PD_ResponderGroupAffected (pctxt, &pvalue->responderType);

         }
         break;

         case 10:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_EmergencyVehicleAlert_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyVehicleAlert: end\n");

   return (stat);
}

EXTERN int asn1PD_PathHistoryPoint (OSCTXT* pctxt, PathHistoryPoint* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathHistoryPoint: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode latOffset */
         stat = asn1PD_OffsetLL_B18 (pctxt, &pvalue->latOffset);

         break;

         case 1:
         /* decode lonOffset */
         stat = asn1PD_OffsetLL_B18 (pctxt, &pvalue->lonOffset);

         break;

         case 2:
         /* decode elevationOffset */
         stat = asn1PD_VertOffset_B12 (pctxt, &pvalue->elevationOffset);

         break;

         case 3:
         /* decode timeOffset */
         stat = asn1PD_TimeOffset (pctxt, &pvalue->timeOffset);

         break;

         case 4:
         /* decode speed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.speedPresent = 1;

            stat = asn1PD_Speed (pctxt, &pvalue->speed);

         }
         break;

         case 5:
         /* decode posAccuracy */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.posAccuracyPresent = 1;

            stat = asn1PD_PositionalAccuracy (pctxt, &pvalue->posAccuracy);

         }
         break;

         case 6:
         /* decode heading */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.headingPresent = 1;

            stat = asn1PD_CoarseHeading (pctxt, &pvalue->heading);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathHistoryPoint: end\n");

   return (stat);
}

EXTERN int asn1PD_PathHistoryPointList (OSCTXT* pctxt, PathHistoryPointList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathHistoryPointList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(23), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PathHistoryPoint* pdata;
      rtxDListAllocNodeAndData (pctxt, PathHistoryPoint, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_PathHistoryPoint (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PathHistoryPoint (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathHistoryPointList: end\n");

   return (stat);
}

EXTERN int asn1PD_PathHistory (OSCTXT* pctxt, PathHistory* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_PathHistory: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode initialPosition */
   if (optbits[0]) {
      pvalue->m.initialPositionPresent = 1;

      stat = asn1PD_FullPositionVector (pctxt, &pvalue->initialPosition);
      if (stat != 0) return stat;

   }

   /* decode currGNSSstatus */
   if (optbits[1]) {
      pvalue->m.currGNSSstatusPresent = 1;

      stat = asn1PD_GNSSstatus (pctxt, &pvalue->currGNSSstatus);
      if (stat != 0) return stat;

   }

   /* decode crumbData */
   stat = asn1PD_PathHistoryPointList (pctxt, &pvalue->crumbData);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathHistory: end\n");

   return (stat);
}

EXTERN int asn1PD_PathPrediction (OSCTXT* pctxt, PathPrediction* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathPrediction: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode radiusOfCurve */
   stat = asn1PD_RadiusOfCurvature (pctxt, &pvalue->radiusOfCurve);
   if (stat != 0) return stat;

   /* decode confidence */
   stat = asn1PD_Confidence (pctxt, &pvalue->confidence);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathPrediction: end\n");

   return (stat);
}

EXTERN int asn1PD_IntersectionReferenceID (OSCTXT* pctxt, IntersectionReferenceID* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionReferenceID: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode region */
   if (optbits[0]) {
      pvalue->m.regionPresent = 1;

      stat = asn1PD_RoadRegulatorID (pctxt, &pvalue->region);
      if (stat != 0) return stat;

   }

   /* decode id */
   stat = asn1PD_IntersectionID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionReferenceID: end\n");

   return (stat);
}

EXTERN int asn1PD_ApproachOrLane (OSCTXT* pctxt, ApproachOrLane* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_ApproachOrLane: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* approach */
      case 0:
         stat = asn1PD_ApproachID (pctxt, &pvalue->u.approach);
         if (stat != 0) return stat;

         break;

      /* lane */
      case 1:
         stat = asn1PD_LaneID (pctxt, &pvalue->u.lane);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ApproachOrLane: end\n");

   return (stat);
}

EXTERN int asn1PD_IntersectionCollision_regional (OSCTXT* pctxt, IntersectionCollision_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionCollision_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionCollision_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_IntersectionCollision (OSCTXT* pctxt, IntersectionCollision* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionCollision: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 10; i_++) {
      switch (i_) {
         case 0:
         /* decode msgCnt */
         stat = asn1PD_MsgCount (pctxt, &pvalue->msgCnt);

         break;

         case 1:
         /* decode id */
         stat = asn1PD_TemporaryID (pctxt, &pvalue->id);

         break;

         case 2:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->timeStamp);

         }
         break;

         case 3:
         /* decode partOne */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.partOnePresent = 1;

            stat = asn1PD_BSMcoreData (pctxt, &pvalue->partOne);

         }
         break;

         case 4:
         /* decode path */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.pathPresent = 1;

            stat = asn1PD_PathHistory (pctxt, &pvalue->path);

         }
         break;

         case 5:
         /* decode pathPrediction */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.pathPredictionPresent = 1;

            stat = asn1PD_PathPrediction (pctxt, &pvalue->pathPrediction);

         }
         break;

         case 6:
         /* decode intersectionID */
         stat = asn1PD_IntersectionReferenceID (pctxt, &pvalue->intersectionID);

         break;

         case 7:
         /* decode laneNumber */
         stat = asn1PD_ApproachOrLane (pctxt, &pvalue->laneNumber);

         break;

         case 8:
         /* decode eventFlag */
         stat = asn1PD_VehicleEventFlags (pctxt, &pvalue->eventFlag);

         break;

         case 9:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_IntersectionCollision_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionCollision: end\n");

   return (stat);
}

EXTERN int asn1PD_Position3D_regional (OSCTXT* pctxt, Position3D_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Position3D_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Position3D_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_Position3D (OSCTXT* pctxt, Position3D* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_Position3D: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode lat */
   stat = asn1PD_Latitude (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   /* decode long_ */
   stat = asn1PD_Longitude (pctxt, &pvalue->long_);
   if (stat != 0) return stat;

   /* decode elevation */
   if (optbits[0]) {
      pvalue->m.elevationPresent = 1;

      stat = asn1PD_Elevation (pctxt, &pvalue->elevation);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_Position3D_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Position3D: end\n");

   return (stat);
}

EXTERN int asn1PD_RegulatorySpeedLimit (OSCTXT* pctxt, RegulatorySpeedLimit* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RegulatorySpeedLimit: start\n");

   /* decode root elements */
   /* decode type */
   stat = asn1PD_SpeedLimitType (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   /* decode speed */
   stat = asn1PD_Velocity (pctxt, &pvalue->speed);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_RegulatorySpeedLimit: end\n");

   return (stat);
}

EXTERN int asn1PD_SpeedLimitList (OSCTXT* pctxt, SpeedLimitList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedLimitList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(9), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegulatorySpeedLimit* pdata;
      rtxDListAllocNodeAndData (pctxt, RegulatorySpeedLimit, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegulatorySpeedLimit (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedLimitList: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneTypeAttributes (OSCTXT* pctxt, LaneTypeAttributes* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneTypeAttributes: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = rtxDecBits (pctxt, &ui, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      RTXCTXTPOPELEMNAME (pctxt);

      switch (ui) {
         /* vehicle */
         case 0:
            pvalue->u.vehicle = rtxMemAllocType (pctxt, 
               LaneAttributes_Vehicle);

            if (pvalue->u.vehicle == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_Vehicle (pvalue->u.vehicle);

            stat = asn1PD_LaneAttributes_Vehicle (pctxt, pvalue->u.vehicle);
            if (stat != 0) return stat;

            break;

         /* crosswalk */
         case 1:
            pvalue->u.crosswalk = rtxMemAllocType (pctxt, 
               LaneAttributes_Crosswalk);

            if (pvalue->u.crosswalk == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_Crosswalk (pvalue->u.crosswalk);

            stat = asn1PD_LaneAttributes_Crosswalk (pctxt, pvalue->u.crosswalk);
            if (stat != 0) return stat;

            break;

         /* bikeLane */
         case 2:
            pvalue->u.bikeLane = rtxMemAllocType (pctxt, LaneAttributes_Bike);

            if (pvalue->u.bikeLane == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_Bike (pvalue->u.bikeLane);

            stat = asn1PD_LaneAttributes_Bike (pctxt, pvalue->u.bikeLane);
            if (stat != 0) return stat;

            break;

         /* sidewalk */
         case 3:
            pvalue->u.sidewalk = rtxMemAllocType (pctxt, 
               LaneAttributes_Sidewalk);

            if (pvalue->u.sidewalk == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_Sidewalk (pvalue->u.sidewalk);

            stat = asn1PD_LaneAttributes_Sidewalk (pctxt, pvalue->u.sidewalk);
            if (stat != 0) return stat;

            break;

         /* median */
         case 4:
            pvalue->u.median = rtxMemAllocType (pctxt, 
               LaneAttributes_Barrier);

            if (pvalue->u.median == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_Barrier (pvalue->u.median);

            stat = asn1PD_LaneAttributes_Barrier (pctxt, pvalue->u.median);
            if (stat != 0) return stat;

            break;

         /* striping */
         case 5:
            pvalue->u.striping = rtxMemAllocType (pctxt, 
               LaneAttributes_Striping);

            if (pvalue->u.striping == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_Striping (pvalue->u.striping);

            stat = asn1PD_LaneAttributes_Striping (pctxt, pvalue->u.striping);
            if (stat != 0) return stat;

            break;

         /* trackedVehicle */
         case 6:
            pvalue->u.trackedVehicle = rtxMemAllocType (pctxt, 
               LaneAttributes_TrackedVehicle);

            if (pvalue->u.trackedVehicle == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_TrackedVehicle (pvalue->u.trackedVehicle);

            stat = asn1PD_LaneAttributes_TrackedVehicle (pctxt, pvalue->u.trackedVehicle);
            if (stat != 0) return stat;

            break;

         /* parking */
         case 7:
            pvalue->u.parking = rtxMemAllocType (pctxt, 
               LaneAttributes_Parking);

            if (pvalue->u.parking == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneAttributes_Parking (pvalue->u.parking);

            stat = asn1PD_LaneAttributes_Parking (pctxt, pvalue->u.parking);
            if (stat != 0) return stat;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 9;

      if (pvalue->t < 9) return RTERR_INVOPT;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return stat;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneTypeAttributes: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneAttributes (OSCTXT* pctxt, LaneAttributes* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode directionalUse */
   stat = asn1PD_LaneDirection (pctxt, &pvalue->directionalUse);
   if (stat != 0) return stat;

   /* decode sharedWith */
   stat = asn1PD_LaneSharing (pctxt, &pvalue->sharedWith);
   if (stat != 0) return stat;

   /* decode laneType */
   stat = asn1PD_LaneTypeAttributes (pctxt, &pvalue->laneType);
   if (stat != 0) return stat;

   /* decode regional */
   if (optbits[0]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneAttributes: end\n");

   return (stat);
}

EXTERN int asn1PD_Node_XY_20b (OSCTXT* pctxt, Node_XY_20b* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_XY_20b: start\n");

   /* decode root elements */
   /* decode x */
   stat = asn1PD_Offset_B10 (pctxt, &pvalue->x);
   if (stat != 0) return stat;

   /* decode y */
   stat = asn1PD_Offset_B10 (pctxt, &pvalue->y);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_XY_20b: end\n");

   return (stat);
}

EXTERN int asn1PD_Node_XY_22b (OSCTXT* pctxt, Node_XY_22b* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_XY_22b: start\n");

   /* decode root elements */
   /* decode x */
   stat = asn1PD_Offset_B11 (pctxt, &pvalue->x);
   if (stat != 0) return stat;

   /* decode y */
   stat = asn1PD_Offset_B11 (pctxt, &pvalue->y);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_XY_22b: end\n");

   return (stat);
}

EXTERN int asn1PD_Node_XY_24b (OSCTXT* pctxt, Node_XY_24b* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_XY_24b: start\n");

   /* decode root elements */
   /* decode x */
   stat = asn1PD_Offset_B12 (pctxt, &pvalue->x);
   if (stat != 0) return stat;

   /* decode y */
   stat = asn1PD_Offset_B12 (pctxt, &pvalue->y);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_XY_24b: end\n");

   return (stat);
}

EXTERN int asn1PD_Node_XY_26b (OSCTXT* pctxt, Node_XY_26b* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_XY_26b: start\n");

   /* decode root elements */
   /* decode x */
   stat = asn1PD_Offset_B13 (pctxt, &pvalue->x);
   if (stat != 0) return stat;

   /* decode y */
   stat = asn1PD_Offset_B13 (pctxt, &pvalue->y);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_XY_26b: end\n");

   return (stat);
}

EXTERN int asn1PD_Node_XY_28b (OSCTXT* pctxt, Node_XY_28b* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_XY_28b: start\n");

   /* decode root elements */
   /* decode x */
   stat = asn1PD_Offset_B14 (pctxt, &pvalue->x);
   if (stat != 0) return stat;

   /* decode y */
   stat = asn1PD_Offset_B14 (pctxt, &pvalue->y);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_XY_28b: end\n");

   return (stat);
}

EXTERN int asn1PD_Node_XY_32b (OSCTXT* pctxt, Node_XY_32b* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_XY_32b: start\n");

   /* decode root elements */
   /* decode x */
   stat = asn1PD_Offset_B16 (pctxt, &pvalue->x);
   if (stat != 0) return stat;

   /* decode y */
   stat = asn1PD_Offset_B16 (pctxt, &pvalue->y);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_XY_32b: end\n");

   return (stat);
}

EXTERN int asn1PD_Node_LLmD_64b (OSCTXT* pctxt, Node_LLmD_64b* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_LLmD_64b: start\n");

   /* decode root elements */
   /* decode lon */
   stat = asn1PD_Longitude (pctxt, &pvalue->lon);
   if (stat != 0) return stat;

   /* decode lat */
   stat = asn1PD_Latitude (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_LLmD_64b: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeOffsetPointXY (OSCTXT* pctxt, NodeOffsetPointXY* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeOffsetPointXY: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   stat = rtxDecBits (pctxt, &ui, 3);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* node_XY1 */
      case 0:
         pvalue->u.node_XY1 = rtxMemAllocTypeZ (pctxt, Node_XY_20b);

         if (pvalue->u.node_XY1 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_XY_20b (pctxt, pvalue->u.node_XY1);
         if (stat != 0) return stat;

         break;

      /* node_XY2 */
      case 1:
         pvalue->u.node_XY2 = rtxMemAllocTypeZ (pctxt, Node_XY_22b);

         if (pvalue->u.node_XY2 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_XY_22b (pctxt, pvalue->u.node_XY2);
         if (stat != 0) return stat;

         break;

      /* node_XY3 */
      case 2:
         pvalue->u.node_XY3 = rtxMemAllocTypeZ (pctxt, Node_XY_24b);

         if (pvalue->u.node_XY3 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_XY_24b (pctxt, pvalue->u.node_XY3);
         if (stat != 0) return stat;

         break;

      /* node_XY4 */
      case 3:
         pvalue->u.node_XY4 = rtxMemAllocTypeZ (pctxt, Node_XY_26b);

         if (pvalue->u.node_XY4 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_XY_26b (pctxt, pvalue->u.node_XY4);
         if (stat != 0) return stat;

         break;

      /* node_XY5 */
      case 4:
         pvalue->u.node_XY5 = rtxMemAllocTypeZ (pctxt, Node_XY_28b);

         if (pvalue->u.node_XY5 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_XY_28b (pctxt, pvalue->u.node_XY5);
         if (stat != 0) return stat;

         break;

      /* node_XY6 */
      case 5:
         pvalue->u.node_XY6 = rtxMemAllocTypeZ (pctxt, Node_XY_32b);

         if (pvalue->u.node_XY6 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_XY_32b (pctxt, pvalue->u.node_XY6);
         if (stat != 0) return stat;

         break;

      /* node_LatLon */
      case 6:
         pvalue->u.node_LatLon = rtxMemAllocTypeZ (pctxt, Node_LLmD_64b);

         if (pvalue->u.node_LatLon == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LLmD_64b (pctxt, pvalue->u.node_LatLon);
         if (stat != 0) return stat;

         break;

      /* regional */
      case 7:
         pvalue->u.regional = rtxMemAllocType (pctxt, RegionalExtension);

         if (pvalue->u.regional == NULL)
            return RTERR_NOMEM;

         asn1Init_RegionalExtension (pvalue->u.regional);

         stat = asn1PD_RegionalExtension (pctxt, pvalue->u.regional);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeOffsetPointXY: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeAttributeXYList (OSCTXT* pctxt, NodeAttributeXYList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeXYList: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 8){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_NodeAttributeXY (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeXYList: end\n");

   return (stat);
}

EXTERN int asn1PD_SegmentAttributeXYList (OSCTXT* pctxt, SegmentAttributeXYList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SegmentAttributeXYList: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 8){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_SegmentAttributeXY (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SegmentAttributeXYList: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneDataAttribute_regional (OSCTXT* pctxt, LaneDataAttribute_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneDataAttribute_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneDataAttribute_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneDataAttribute (OSCTXT* pctxt, LaneDataAttribute* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneDataAttribute: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = rtxDecBits (pctxt, &ui, 3);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      RTXCTXTPOPELEMNAME (pctxt);

      switch (ui) {
         /* pathEndPointAngle */
         case 0:
            stat = asn1PD_DeltaAngle (pctxt, &pvalue->u.pathEndPointAngle);
            if (stat != 0) return stat;

            break;

         /* laneCrownPointCenter */
         case 1:
            stat = asn1PD_RoadwayCrownAngle (pctxt, &pvalue->u.laneCrownPointCenter);
            if (stat != 0) return stat;

            break;

         /* laneCrownPointLeft */
         case 2:
            stat = asn1PD_RoadwayCrownAngle (pctxt, &pvalue->u.laneCrownPointLeft);
            if (stat != 0) return stat;

            break;

         /* laneCrownPointRight */
         case 3:
            stat = asn1PD_RoadwayCrownAngle (pctxt, &pvalue->u.laneCrownPointRight);
            if (stat != 0) return stat;

            break;

         /* laneAngle */
         case 4:
            stat = asn1PD_MergeDivergeNodeAngle (pctxt, &pvalue->u.laneAngle);
            if (stat != 0) return stat;

            break;

         /* speedLimits */
         case 5:
            pvalue->u.speedLimits = rtxMemAllocType (pctxt, SpeedLimitList);

            if (pvalue->u.speedLimits == NULL)
               return RTERR_NOMEM;

            asn1Init_SpeedLimitList (pvalue->u.speedLimits);

            stat = asn1PD_SpeedLimitList (pctxt, pvalue->u.speedLimits);
            if (stat != 0) return stat;

            break;

         /* regional */
         case 6:
            pvalue->u.regional = rtxMemAllocType (pctxt, 
               LaneDataAttribute_regional);

            if (pvalue->u.regional == NULL)
               return RTERR_NOMEM;

            asn1Init_LaneDataAttribute_regional (pvalue->u.regional);

            stat = asn1PD_LaneDataAttribute_regional (pctxt, pvalue->u.regional);
            if (stat != 0) return stat;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 8;

      if (pvalue->t < 8) return RTERR_INVOPT;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return stat;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneDataAttribute: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneDataAttributeList (OSCTXT* pctxt, LaneDataAttributeList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneDataAttributeList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      LaneDataAttribute* pdata;
      rtxDListAllocNodeAndData (pctxt, LaneDataAttribute, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_LaneDataAttribute (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_LaneDataAttribute (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneDataAttributeList: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeAttributeSetXY_regional (OSCTXT* pctxt, NodeAttributeSetXY_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeSetXY_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeSetXY_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeAttributeSetXY (OSCTXT* pctxt, NodeAttributeSetXY* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[7];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeSetXY: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode localNode */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.localNodePresent = 1;

            stat = asn1PD_NodeAttributeXYList (pctxt, &pvalue->localNode);

         }
         break;

         case 1:
         /* decode disabled */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.disabledPresent = 1;

            stat = asn1PD_SegmentAttributeXYList (pctxt, &pvalue->disabled);

         }
         break;

         case 2:
         /* decode enabled */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.enabledPresent = 1;

            stat = asn1PD_SegmentAttributeXYList (pctxt, &pvalue->enabled);

         }
         break;

         case 3:
         /* decode data */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.dataPresent = 1;

            stat = asn1PD_LaneDataAttributeList (pctxt, &pvalue->data);

         }
         break;

         case 4:
         /* decode dWidth */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.dWidthPresent = 1;

            stat = asn1PD_Offset_B10 (pctxt, &pvalue->dWidth);

         }
         break;

         case 5:
         /* decode dElevation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.dElevationPresent = 1;

            stat = asn1PD_Offset_B10 (pctxt, &pvalue->dElevation);

         }
         break;

         case 6:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_NodeAttributeSetXY_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeSetXY: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeXY (OSCTXT* pctxt, NodeXY* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeXY: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode delta */
   stat = asn1PD_NodeOffsetPointXY (pctxt, &pvalue->delta);
   if (stat != 0) return stat;

   /* decode attributes */
   if (optbits[0]) {
      pvalue->m.attributesPresent = 1;

      stat = asn1PD_NodeAttributeSetXY (pctxt, &pvalue->attributes);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeXY: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeSetXY (OSCTXT* pctxt, NodeSetXY* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeSetXY: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(63), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NodeXY* pdata;
      rtxDListAllocNodeAndData (pctxt, NodeXY, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_NodeXY (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NodeXY (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeSetXY: end\n");

   return (stat);
}

EXTERN int asn1PD_ComputedLane_offsetXaxis (OSCTXT* pctxt, ComputedLane_offsetXaxis* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_ComputedLane_offsetXaxis: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* small_ */
      case 0:
         stat = asn1PD_DrivenLineOffsetSm (pctxt, &pvalue->u.small_);
         if (stat != 0) return stat;

         break;

      /* large_ */
      case 1:
         stat = asn1PD_DrivenLineOffsetLg (pctxt, &pvalue->u.large_);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ComputedLane_offsetXaxis: end\n");

   return (stat);
}

EXTERN int asn1PD_ComputedLane_offsetYaxis (OSCTXT* pctxt, ComputedLane_offsetYaxis* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_ComputedLane_offsetYaxis: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* small_ */
      case 0:
         stat = asn1PD_DrivenLineOffsetSm (pctxt, &pvalue->u.small_);
         if (stat != 0) return stat;

         break;

      /* large_ */
      case 1:
         stat = asn1PD_DrivenLineOffsetLg (pctxt, &pvalue->u.large_);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ComputedLane_offsetYaxis: end\n");

   return (stat);
}

EXTERN int asn1PD_ComputedLane_regional (OSCTXT* pctxt, ComputedLane_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ComputedLane_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ComputedLane_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_ComputedLane (OSCTXT* pctxt, ComputedLane* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ComputedLane: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode referenceLaneId */
         stat = asn1PD_LaneID (pctxt, &pvalue->referenceLaneId);

         break;

         case 1:
         /* decode offsetXaxis */
         stat = asn1PD_ComputedLane_offsetXaxis (pctxt, &pvalue->offsetXaxis);

         break;

         case 2:
         /* decode offsetYaxis */
         stat = asn1PD_ComputedLane_offsetYaxis (pctxt, &pvalue->offsetYaxis);

         break;

         case 3:
         /* decode rotateXY */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.rotateXYPresent = 1;

            stat = asn1PD_Angle (pctxt, &pvalue->rotateXY);

         }
         break;

         case 4:
         /* decode scaleXaxis */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.scaleXaxisPresent = 1;

            stat = asn1PD_Scale_B12 (pctxt, &pvalue->scaleXaxis);

         }
         break;

         case 5:
         /* decode scaleYaxis */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.scaleYaxisPresent = 1;

            stat = asn1PD_Scale_B12 (pctxt, &pvalue->scaleYaxis);

         }
         break;

         case 6:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_ComputedLane_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ComputedLane: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeListXY (OSCTXT* pctxt, NodeListXY* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeListXY: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      RTXCTXTPUSHELEMNAME (pctxt, "t");

      {
         OSBOOL b = 0;
         DEC_BIT (pctxt, &b);
         ui = b;
      }
      pvalue->t = ui + 1;

      RTXCTXTPOPELEMNAME (pctxt);

      switch (ui) {
         /* nodes */
         case 0:
            pvalue->u.nodes = rtxMemAllocType (pctxt, NodeSetXY);

            if (pvalue->u.nodes == NULL)
               return RTERR_NOMEM;

            asn1Init_NodeSetXY (pvalue->u.nodes);

            stat = asn1PD_NodeSetXY (pctxt, pvalue->u.nodes);
            if (stat != 0) return stat;

            break;

         /* computed */
         case 1:
            pvalue->u.computed = rtxMemAllocType (pctxt, ComputedLane);

            if (pvalue->u.computed == NULL)
               return RTERR_NOMEM;

            asn1Init_ComputedLane (pvalue->u.computed);

            stat = asn1PD_ComputedLane (pctxt, pvalue->u.computed);
            if (stat != 0) return stat;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return RTERR_INVOPT;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return stat;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeListXY: end\n");

   return (stat);
}

EXTERN int asn1PD_ConnectingLane (OSCTXT* pctxt, ConnectingLane* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTDIAGSTRM2 (pctxt,"asn1PD_ConnectingLane: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode lane */
   stat = asn1PD_LaneID (pctxt, &pvalue->lane);
   if (stat != 0) return stat;

   /* decode maneuver */
   if (optbits[0]) {
      pvalue->m.maneuverPresent = 1;

      stat = asn1PD_AllowedManeuvers (pctxt, &pvalue->maneuver);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ConnectingLane: end\n");

   return (stat);
}

EXTERN int asn1PD_Connection (OSCTXT* pctxt, Connection* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Connection: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode connectingLane */
         stat = asn1PD_ConnectingLane (pctxt, &pvalue->connectingLane);

         break;

         case 1:
         /* decode remoteIntersection */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.remoteIntersectionPresent = 1;

            stat = asn1PD_IntersectionReferenceID (pctxt, &pvalue->remoteIntersection);

         }
         break;

         case 2:
         /* decode signalGroup */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.signalGroupPresent = 1;

            stat = asn1PD_SignalGroupID (pctxt, &pvalue->signalGroup);

         }
         break;

         case 3:
         /* decode userClass */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.userClassPresent = 1;

            stat = asn1PD_RestrictionClassID (pctxt, &pvalue->userClass);

         }
         break;

         case 4:
         /* decode connectionID */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.connectionIDPresent = 1;

            stat = asn1PD_LaneConnectionID (pctxt, &pvalue->connectionID);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Connection: end\n");

   return (stat);
}

EXTERN int asn1PD_ConnectsToList (OSCTXT* pctxt, ConnectsToList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ConnectsToList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      Connection* pdata;
      rtxDListAllocNodeAndData (pctxt, Connection, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_Connection (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_Connection (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ConnectsToList: end\n");

   return (stat);
}

EXTERN int asn1PD_OverlayLaneList (OSCTXT* pctxt, OverlayLaneList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_OverlayLaneList: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 5){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_LaneID (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_OverlayLaneList: end\n");

   return (stat);
}

EXTERN int asn1PD_GenericLane_regional (OSCTXT* pctxt, GenericLane_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GenericLane_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GenericLane_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_GenericLane (OSCTXT* pctxt, GenericLane* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[7];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GenericLane: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 10; i_++) {
      switch (i_) {
         case 0:
         /* decode laneID */
         stat = asn1PD_LaneID (pctxt, &pvalue->laneID);

         break;

         case 1:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, &pvalue->name);

         }
         break;

         case 2:
         /* decode ingressApproach */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.ingressApproachPresent = 1;

            stat = asn1PD_ApproachID (pctxt, &pvalue->ingressApproach);

         }
         break;

         case 3:
         /* decode egressApproach */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.egressApproachPresent = 1;

            stat = asn1PD_ApproachID (pctxt, &pvalue->egressApproach);

         }
         break;

         case 4:
         /* decode laneAttributes */
         stat = asn1PD_LaneAttributes (pctxt, &pvalue->laneAttributes);

         break;

         case 5:
         /* decode maneuvers */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.maneuversPresent = 1;

            stat = asn1PD_AllowedManeuvers (pctxt, &pvalue->maneuvers);

         }
         break;

         case 6:
         /* decode nodeList */
         stat = asn1PD_NodeListXY (pctxt, &pvalue->nodeList);

         break;

         case 7:
         /* decode connectsTo */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.connectsToPresent = 1;

            stat = asn1PD_ConnectsToList (pctxt, &pvalue->connectsTo);

         }
         break;

         case 8:
         /* decode overlays */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.overlaysPresent = 1;

            stat = asn1PD_OverlayLaneList (pctxt, &pvalue->overlays);

         }
         break;

         case 9:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_GenericLane_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GenericLane: end\n");

   return (stat);
}

EXTERN int asn1PD_LaneList (OSCTXT* pctxt, LaneList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      GenericLane* pdata;
      rtxDListAllocNodeAndData (pctxt, GenericLane, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_GenericLane (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_GenericLane (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LaneList: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalControlZone (OSCTXT* pctxt, SignalControlZone* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalControlZone: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode zone */
   stat = asn1PD_RegionalExtension (pctxt, &pvalue->zone);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalControlZone: end\n");

   return (stat);
}

EXTERN int asn1PD_PreemptPriorityList (OSCTXT* pctxt, PreemptPriorityList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PreemptPriorityList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SignalControlZone* pdata;
      rtxDListAllocNodeAndData (pctxt, SignalControlZone, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_SignalControlZone (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SignalControlZone (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PreemptPriorityList: end\n");

   return (stat);
}

EXTERN int asn1PD_IntersectionGeometry_regional (OSCTXT* pctxt, IntersectionGeometry_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionGeometry_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionGeometry_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_IntersectionGeometry (OSCTXT* pctxt, IntersectionGeometry* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionGeometry: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 9; i_++) {
      switch (i_) {
         case 0:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, &pvalue->name);

         }
         break;

         case 1:
         /* decode id */
         stat = asn1PD_IntersectionReferenceID (pctxt, &pvalue->id);

         break;

         case 2:
         /* decode revision */
         stat = asn1PD_MsgCount (pctxt, &pvalue->revision);

         break;

         case 3:
         /* decode refPoint */
         stat = asn1PD_Position3D (pctxt, &pvalue->refPoint);

         break;

         case 4:
         /* decode laneWidth */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.laneWidthPresent = 1;

            stat = asn1PD_LaneWidth (pctxt, &pvalue->laneWidth);

         }
         break;

         case 5:
         /* decode speedLimits */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.speedLimitsPresent = 1;

            stat = asn1PD_SpeedLimitList (pctxt, &pvalue->speedLimits);

         }
         break;

         case 6:
         /* decode laneSet */
         stat = asn1PD_LaneList (pctxt, &pvalue->laneSet);

         break;

         case 7:
         /* decode preemptPriorityData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.preemptPriorityDataPresent = 1;

            stat = asn1PD_PreemptPriorityList (pctxt, &pvalue->preemptPriorityData);

         }
         break;

         case 8:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_IntersectionGeometry_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionGeometry: end\n");

   return (stat);
}

EXTERN int asn1PD_IntersectionGeometryList (OSCTXT* pctxt, IntersectionGeometryList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionGeometryList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      IntersectionGeometry* pdata;
      rtxDListAllocNodeAndData (pctxt, IntersectionGeometry, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_IntersectionGeometry (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_IntersectionGeometry (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionGeometryList: end\n");

   return (stat);
}

EXTERN int asn1PD_RoadSegmentReferenceID (OSCTXT* pctxt, RoadSegmentReferenceID* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSegmentReferenceID: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode region */
   if (optbits[0]) {
      pvalue->m.regionPresent = 1;

      stat = asn1PD_RoadRegulatorID (pctxt, &pvalue->region);
      if (stat != 0) return stat;

   }

   /* decode id */
   stat = asn1PD_RoadSegmentID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSegmentReferenceID: end\n");

   return (stat);
}

EXTERN int asn1PD_RoadLaneSetList (OSCTXT* pctxt, RoadLaneSetList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadLaneSetList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      GenericLane* pdata;
      rtxDListAllocNodeAndData (pctxt, GenericLane, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_GenericLane (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_GenericLane (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadLaneSetList: end\n");

   return (stat);
}

EXTERN int asn1PD_RoadSegment_regional (OSCTXT* pctxt, RoadSegment_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSegment_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSegment_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_RoadSegment (OSCTXT* pctxt, RoadSegment* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSegment: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 8; i_++) {
      switch (i_) {
         case 0:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, &pvalue->name);

         }
         break;

         case 1:
         /* decode id */
         stat = asn1PD_RoadSegmentReferenceID (pctxt, &pvalue->id);

         break;

         case 2:
         /* decode revision */
         stat = asn1PD_MsgCount (pctxt, &pvalue->revision);

         break;

         case 3:
         /* decode refPoint */
         stat = asn1PD_Position3D (pctxt, &pvalue->refPoint);

         break;

         case 4:
         /* decode laneWidth */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.laneWidthPresent = 1;

            stat = asn1PD_LaneWidth (pctxt, &pvalue->laneWidth);

         }
         break;

         case 5:
         /* decode speedLimits */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.speedLimitsPresent = 1;

            stat = asn1PD_SpeedLimitList (pctxt, &pvalue->speedLimits);

         }
         break;

         case 6:
         /* decode roadLaneSet */
         stat = asn1PD_RoadLaneSetList (pctxt, &pvalue->roadLaneSet);

         break;

         case 7:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_RoadSegment_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSegment: end\n");

   return (stat);
}

EXTERN int asn1PD_RoadSegmentList (OSCTXT* pctxt, RoadSegmentList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSegmentList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RoadSegment* pdata;
      rtxDListAllocNodeAndData (pctxt, RoadSegment, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RoadSegment (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RoadSegment (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSegmentList: end\n");

   return (stat);
}

EXTERN int asn1PD_DataParameters (OSCTXT* pctxt, DataParameters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DataParameters: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode processMethod */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.processMethodPresent = 1;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

            stat = pd_ConstrainedStringEx (pctxt, &pvalue->processMethod, 0, 8, 7, 7);
         }
         break;

         case 1:
         /* decode processAgency */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.processAgencyPresent = 1;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

            stat = pd_ConstrainedStringEx (pctxt, &pvalue->processAgency, 0, 8, 7, 7);
         }
         break;

         case 2:
         /* decode lastCheckedDate */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.lastCheckedDatePresent = 1;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

            stat = pd_ConstrainedStringEx (pctxt, &pvalue->lastCheckedDate, 0, 8, 7, 7);
         }
         break;

         case 3:
         /* decode geoidUsed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.geoidUsedPresent = 1;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

            stat = pd_ConstrainedStringEx (pctxt, &pvalue->geoidUsed, 0, 8, 7, 7);
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DataParameters: end\n");

   return (stat);
}

EXTERN int asn1PD_RestrictionUserType_regional (OSCTXT* pctxt, RestrictionUserType_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RestrictionUserType_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RestrictionUserType_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_RestrictionUserType (OSCTXT* pctxt, RestrictionUserType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTDIAGSTRM2 (pctxt,"asn1PD_RestrictionUserType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      RTXCTXTPUSHELEMNAME (pctxt, "t");

      {
         OSBOOL b = 0;
         DEC_BIT (pctxt, &b);
         ui = b;
      }
      pvalue->t = ui + 1;

      RTXCTXTPOPELEMNAME (pctxt);

      switch (ui) {
         /* basicType */
         case 0:
            stat = asn1PD_RestrictionAppliesTo (pctxt, &pvalue->u.basicType);
            if (stat != 0) return stat;

            break;

         /* regional */
         case 1:
            pvalue->u.regional = rtxMemAllocType (pctxt, 
               RestrictionUserType_regional);

            if (pvalue->u.regional == NULL)
               return RTERR_NOMEM;

            asn1Init_RestrictionUserType_regional (pvalue->u.regional);

            stat = asn1PD_RestrictionUserType_regional (pctxt, pvalue->u.regional);
            if (stat != 0) return stat;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return RTERR_INVOPT;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return stat;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RestrictionUserType: end\n");

   return (stat);
}

EXTERN int asn1PD_RestrictionUserTypeList (OSCTXT* pctxt, RestrictionUserTypeList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RestrictionUserTypeList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RestrictionUserType* pdata;
      rtxDListAllocNodeAndData (pctxt, RestrictionUserType, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RestrictionUserType (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RestrictionUserType (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RestrictionUserTypeList: end\n");

   return (stat);
}

EXTERN int asn1PD_RestrictionClassAssignment (OSCTXT* pctxt, RestrictionClassAssignment* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RestrictionClassAssignment: start\n");

   /* decode root elements */
   /* decode id */
   stat = asn1PD_RestrictionClassID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* decode users */
   stat = asn1PD_RestrictionUserTypeList (pctxt, &pvalue->users);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_RestrictionClassAssignment: end\n");

   return (stat);
}

EXTERN int asn1PD_RestrictionClassList (OSCTXT* pctxt, RestrictionClassList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RestrictionClassList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(254), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RestrictionClassAssignment* pdata;
      rtxDListAllocNodeAndData (pctxt, RestrictionClassAssignment, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RestrictionClassAssignment (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RestrictionClassAssignment (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RestrictionClassList: end\n");

   return (stat);
}

EXTERN int asn1PD_MapData_regional (OSCTXT* pctxt, MapData_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MapData_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MapData_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_MapData (OSCTXT* pctxt, MapData* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[8];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MapData: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 8; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 9; i_++) {
      switch (i_) {
         case 0:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->timeStamp);

         }
         break;

         case 1:
         /* decode msgIssueRevision */
         stat = asn1PD_MsgCount (pctxt, &pvalue->msgIssueRevision);

         break;

         case 2:
         /* decode layerType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.layerTypePresent = 1;

            stat = asn1PD_LayerType (pctxt, &pvalue->layerType);

         }
         break;

         case 3:
         /* decode layerID */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.layerIDPresent = 1;

            stat = asn1PD_LayerID (pctxt, &pvalue->layerID);

         }
         break;

         case 4:
         /* decode intersections */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.intersectionsPresent = 1;

            stat = asn1PD_IntersectionGeometryList (pctxt, &pvalue->intersections);

         }
         break;

         case 5:
         /* decode roadSegments */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.roadSegmentsPresent = 1;

            stat = asn1PD_RoadSegmentList (pctxt, &pvalue->roadSegments);

         }
         break;

         case 6:
         /* decode dataParameters */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.dataParametersPresent = 1;

            stat = asn1PD_DataParameters (pctxt, &pvalue->dataParameters);

         }
         break;

         case 7:
         /* decode restrictionList */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.restrictionListPresent = 1;

            stat = asn1PD_RestrictionClassList (pctxt, &pvalue->restrictionList);

         }
         break;

         case 8:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_MapData_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MapData: end\n");

   return (stat);
}

EXTERN int asn1PD_NMEAcorrections_regional (OSCTXT* pctxt, NMEAcorrections_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NMEAcorrections_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NMEAcorrections_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_NMEAcorrections (OSCTXT* pctxt, NMEAcorrections* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NMEAcorrections: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->timeStamp);

         }
         break;

         case 1:
         /* decode rev */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.revPresent = 1;

            stat = asn1PD_NMEA_Revision (pctxt, &pvalue->rev);

         }
         break;

         case 2:
         /* decode msg */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.msgPresent = 1;

            stat = asn1PD_NMEA_MsgType (pctxt, &pvalue->msg);

         }
         break;

         case 3:
         /* decode wdCount */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.wdCountPresent = 1;

            stat = asn1PD_ObjectCount (pctxt, &pvalue->wdCount);

         }
         break;

         case 4:
         /* decode payload */
         stat = asn1PD_NMEA_Payload (pctxt, &pvalue->payload);

         break;

         case 5:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_NMEAcorrections_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NMEAcorrections: end\n");

   return (stat);
}

EXTERN int asn1PD_PropelledInformation (OSCTXT* pctxt, PropelledInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTDIAGSTRM2 (pctxt,"asn1PD_PropelledInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = rtxDecBits (pctxt, &ui, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      RTXCTXTPOPELEMNAME (pctxt);

      switch (ui) {
         /* human */
         case 0:
            stat = asn1PD_HumanPropelledType (pctxt, &pvalue->u.human);
            if (stat != 0) return stat;

            break;

         /* animal */
         case 1:
            stat = asn1PD_AnimalPropelledType (pctxt, &pvalue->u.animal);
            if (stat != 0) return stat;

            break;

         /* motor */
         case 2:
            stat = asn1PD_MotorizedPropelledType (pctxt, &pvalue->u.motor);
            if (stat != 0) return stat;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return RTERR_INVOPT;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return stat;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PropelledInformation: end\n");

   return (stat);
}

EXTERN int asn1PD_PersonalSafetyMessage_regional (OSCTXT* pctxt, PersonalSafetyMessage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PersonalSafetyMessage_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PersonalSafetyMessage_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_PersonalSafetyMessage (OSCTXT* pctxt, PersonalSafetyMessage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[18];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PersonalSafetyMessage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 18; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 26; i_++) {
      switch (i_) {
         case 0:
         /* decode basicType */
         stat = asn1PD_PersonalDeviceUserType (pctxt, &pvalue->basicType);

         break;

         case 1:
         /* decode secMark */
         stat = asn1PD_DSecond (pctxt, &pvalue->secMark);

         break;

         case 2:
         /* decode msgCnt */
         stat = asn1PD_MsgCount (pctxt, &pvalue->msgCnt);

         break;

         case 3:
         /* decode id */
         stat = asn1PD_TemporaryID (pctxt, &pvalue->id);

         break;

         case 4:
         /* decode position */
         stat = asn1PD_Position3D (pctxt, &pvalue->position);

         break;

         case 5:
         /* decode accuracy */
         stat = asn1PD_PositionalAccuracy (pctxt, &pvalue->accuracy);

         break;

         case 6:
         /* decode speed */
         stat = asn1PD_Velocity (pctxt, &pvalue->speed);

         break;

         case 7:
         /* decode heading */
         stat = asn1PD_Heading (pctxt, &pvalue->heading);

         break;

         case 8:
         /* decode accelSet */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.accelSetPresent = 1;

            stat = asn1PD_AccelerationSet4Way (pctxt, &pvalue->accelSet);

         }
         break;

         case 9:
         /* decode pathHistory */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.pathHistoryPresent = 1;

            stat = asn1PD_PathHistory (pctxt, &pvalue->pathHistory);

         }
         break;

         case 10:
         /* decode pathPrediction */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.pathPredictionPresent = 1;

            stat = asn1PD_PathPrediction (pctxt, &pvalue->pathPrediction);

         }
         break;

         case 11:
         /* decode propulsion */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.propulsionPresent = 1;

            stat = asn1PD_PropelledInformation (pctxt, &pvalue->propulsion);

         }
         break;

         case 12:
         /* decode useState */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.useStatePresent = 1;

            stat = asn1PD_PersonalDeviceUsageState (pctxt, &pvalue->useState);

         }
         break;

         case 13:
         /* decode crossRequest */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.crossRequestPresent = 1;

            stat = asn1PD_PersonalCrossingRequest (pctxt, &pvalue->crossRequest);

         }
         break;

         case 14:
         /* decode crossState */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.crossStatePresent = 1;

            stat = asn1PD_PersonalCrossingInProgress (pctxt, &pvalue->crossState);

         }
         break;

         case 15:
         /* decode clusterSize */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.clusterSizePresent = 1;

            stat = asn1PD_NumberOfParticipantsInCluster (pctxt, &pvalue->clusterSize);

         }
         break;

         case 16:
         /* decode clusterRadius */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.clusterRadiusPresent = 1;

            stat = asn1PD_PersonalClusterRadius (pctxt, &pvalue->clusterRadius);

         }
         break;

         case 17:
         /* decode eventResponderType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.eventResponderTypePresent = 1;

            stat = asn1PD_PublicSafetyEventResponderWorkerType (pctxt, &pvalue->eventResponderType);

         }
         break;

         case 18:
         /* decode activityType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.activityTypePresent = 1;

            stat = asn1PD_PublicSafetyAndRoadWorkerActivity (pctxt, &pvalue->activityType);

         }
         break;

         case 19:
         /* decode activitySubType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.activitySubTypePresent = 1;

            stat = asn1PD_PublicSafetyDirectingTrafficSubType (pctxt, &pvalue->activitySubType);

         }
         break;

         case 20:
         /* decode assistType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.assistTypePresent = 1;

            stat = asn1PD_PersonalAssistive (pctxt, &pvalue->assistType);

         }
         break;

         case 21:
         /* decode sizing */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.sizingPresent = 1;

            stat = asn1PD_UserSizeAndBehaviour (pctxt, &pvalue->sizing);

         }
         break;

         case 22:
         /* decode attachment */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.attachmentPresent = 1;

            stat = asn1PD_Attachment (pctxt, &pvalue->attachment);

         }
         break;

         case 23:
         /* decode attachmentRadius */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.attachmentRadiusPresent = 1;

            stat = asn1PD_AttachmentRadius (pctxt, &pvalue->attachmentRadius);

         }
         break;

         case 24:
         /* decode animalType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.animalTypePresent = 1;

            stat = asn1PD_AnimalType (pctxt, &pvalue->animalType);

         }
         break;

         case 25:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_PersonalSafetyMessage_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PersonalSafetyMessage: end\n");

   return (stat);
}

EXTERN int asn1PD_Sample (OSCTXT* pctxt, Sample* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Sample: start\n");

   /* decode root elements */
   /* decode sampleStart */
   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToByte (pctxt, &pvalue->sampleStart, 8);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   /* decode sampleEnd */
   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToByte (pctxt, &pvalue->sampleEnd, 8);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_Sample: end\n");

   return (stat);
}

EXTERN int asn1PD_ProbeDataManagement_term (OSCTXT* pctxt, ProbeDataManagement_term* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_ProbeDataManagement_term: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* termtime */
      case 0:
         stat = asn1PD_TermTime (pctxt, &pvalue->u.termtime);
         if (stat != 0) return stat;

         break;

      /* termDistance */
      case 1:
         stat = asn1PD_TermDistance (pctxt, &pvalue->u.termDistance);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ProbeDataManagement_term: end\n");

   return (stat);
}

EXTERN int asn1PD_SnapshotTime (OSCTXT* pctxt, SnapshotTime* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SnapshotTime: start\n");

   /* decode root elements */
   /* decode speed1 */
   stat = asn1PD_GrossSpeed (pctxt, &pvalue->speed1);
   if (stat != 0) return stat;

   /* decode time1 */
   stat = asn1PD_SecondOfTime (pctxt, &pvalue->time1);
   if (stat != 0) return stat;

   /* decode speed2 */
   stat = asn1PD_GrossSpeed (pctxt, &pvalue->speed2);
   if (stat != 0) return stat;

   /* decode time2 */
   stat = asn1PD_SecondOfTime (pctxt, &pvalue->time2);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_SnapshotTime: end\n");

   return (stat);
}

EXTERN int asn1PD_SnapshotDistance (OSCTXT* pctxt, SnapshotDistance* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SnapshotDistance: start\n");

   /* decode root elements */
   /* decode distance1 */
   stat = asn1PD_GrossDistance (pctxt, &pvalue->distance1);
   if (stat != 0) return stat;

   /* decode speed1 */
   stat = asn1PD_GrossSpeed (pctxt, &pvalue->speed1);
   if (stat != 0) return stat;

   /* decode distance2 */
   stat = asn1PD_GrossDistance (pctxt, &pvalue->distance2);
   if (stat != 0) return stat;

   /* decode speed2 */
   stat = asn1PD_GrossSpeed (pctxt, &pvalue->speed2);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_SnapshotDistance: end\n");

   return (stat);
}

EXTERN int asn1PD_ProbeDataManagement_snapshot (OSCTXT* pctxt, ProbeDataManagement_snapshot* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_ProbeDataManagement_snapshot: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* snapshotTime */
      case 0:
         pvalue->u.snapshotTime = rtxMemAllocTypeZ (pctxt, SnapshotTime);

         if (pvalue->u.snapshotTime == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_SnapshotTime (pctxt, pvalue->u.snapshotTime);
         if (stat != 0) return stat;

         break;

      /* snapshotDistance */
      case 1:
         pvalue->u.snapshotDistance = rtxMemAllocTypeZ (pctxt, 
            SnapshotDistance);

         if (pvalue->u.snapshotDistance == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_SnapshotDistance (pctxt, pvalue->u.snapshotDistance);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ProbeDataManagement_snapshot: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleStatusRequest (OSCTXT* pctxt, VehicleStatusRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatusRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode dataType */
         stat = asn1PD_VehicleStatusDeviceTypeTag (pctxt, &pvalue->dataType);

         break;

         case 1:
         /* decode subType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.subTypePresent = 1;

            PU_NEWFIELD (pctxt, "constrainted int");

            stat = rtxDecBitsToByte (pctxt, &pvalue->subType, 4);

            if (pvalue->subType > 14){
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddUIntParm (pctxt, 15);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            pvalue->subType += 1;

            PU_SETBITCOUNT (pctxt);

         }
         break;

         case 2:
         /* decode sendOnLessThenValue */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.sendOnLessThenValuePresent = 1;

            stat = pd_ConsInt16 (pctxt, &pvalue->sendOnLessThenValue, -32767, 32767);
         }
         break;

         case 3:
         /* decode sendOnMoreThenValue */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.sendOnMoreThenValuePresent = 1;

            stat = pd_ConsInt16 (pctxt, &pvalue->sendOnMoreThenValue, -32767, 32767);
         }
         break;

         case 4:
         /* decode sendAll */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.sendAllPresent = 1;

            PU_NEWFIELD (pctxt, "boolean");

            stat = DEC_BIT (pctxt, &pvalue->sendAll);

            PU_SETBITCOUNT (pctxt);
         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatusRequest: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleStatusRequestList (OSCTXT* pctxt, VehicleStatusRequestList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatusRequestList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      VehicleStatusRequest* pdata;
      rtxDListAllocNodeAndData (pctxt, VehicleStatusRequest, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_VehicleStatusRequest (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_VehicleStatusRequest (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatusRequestList: end\n");

   return (stat);
}

EXTERN int asn1PD_ProbeDataManagement_regional (OSCTXT* pctxt, ProbeDataManagement_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ProbeDataManagement_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ProbeDataManagement_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_ProbeDataManagement (OSCTXT* pctxt, ProbeDataManagement* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ProbeDataManagement: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 8; i_++) {
      switch (i_) {
         case 0:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->timeStamp);

         }
         break;

         case 1:
         /* decode sample */
         stat = asn1PD_Sample (pctxt, &pvalue->sample);

         break;

         case 2:
         /* decode directions */
         stat = asn1PD_HeadingSlice (pctxt, &pvalue->directions);

         break;

         case 3:
         /* decode term */
         stat = asn1PD_ProbeDataManagement_term (pctxt, &pvalue->term);

         break;

         case 4:
         /* decode snapshot */
         stat = asn1PD_ProbeDataManagement_snapshot (pctxt, &pvalue->snapshot);

         break;

         case 5:
         /* decode txInterval */
         stat = asn1PD_SecondOfTime (pctxt, &pvalue->txInterval);

         break;

         case 6:
         /* decode dataElements */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.dataElementsPresent = 1;

            stat = asn1PD_VehicleStatusRequestList (pctxt, &pvalue->dataElements);

         }
         break;

         case 7:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_ProbeDataManagement_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ProbeDataManagement: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleID (OSCTXT* pctxt, VehicleID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleID: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* entityID */
      case 0:
         pvalue->u.entityID = rtxMemAllocType (pctxt, TemporaryID);

         if (pvalue->u.entityID == NULL)
            return RTERR_NOMEM;

         asn1Init_TemporaryID (pvalue->u.entityID);

         stat = asn1PD_TemporaryID (pctxt, pvalue->u.entityID);
         if (stat != 0) return stat;

         break;

      /* stationID */
      case 1:
         stat = asn1PD_StationID (pctxt, &pvalue->u.stationID);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleID: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleIdent_vehicleClass (OSCTXT* pctxt, VehicleIdent_vehicleClass* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleIdent_vehicleClass: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* vGroup */
      case 0:
         stat = asn1PD_VehicleGroupAffected (pctxt, &pvalue->u.vGroup);
         if (stat != 0) return stat;

         break;

      /* rGroup */
      case 1:
         stat = asn1PD_ResponderGroupAffected (pctxt, &pvalue->u.rGroup);
         if (stat != 0) return stat;

         break;

      /* rEquip */
      case 2:
         stat = asn1PD_IncidentResponseEquipment (pctxt, &pvalue->u.rEquip);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleIdent_vehicleClass: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleIdent (OSCTXT* pctxt, VehicleIdent* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[6];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleIdent: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, &pvalue->name);

         }
         break;

         case 1:
         /* decode vin */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.vinPresent = 1;

            stat = asn1PD_VINstring (pctxt, &pvalue->vin);

         }
         break;

         case 2:
         /* decode ownerCode */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.ownerCodePresent = 1;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

            stat = pd_ConstrainedStringEx (pctxt, &pvalue->ownerCode, 0, 8, 7, 7);
         }
         break;

         case 3:
         /* decode id */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.idPresent = 1;

            stat = asn1PD_VehicleID (pctxt, &pvalue->id);

         }
         break;

         case 4:
         /* decode vehicleType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.vehicleTypePresent = 1;

            stat = asn1PD_VehicleType (pctxt, &pvalue->vehicleType);

         }
         break;

         case 5:
         /* decode vehicleClass */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.vehicleClassPresent = 1;

            stat = asn1PD_VehicleIdent_vehicleClass (pctxt, &pvalue->vehicleClass);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleIdent: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleClassification_regional (OSCTXT* pctxt, VehicleClassification_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleClassification_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleClassification_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleClassification (OSCTXT* pctxt, VehicleClassification* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[9];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleClassification: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 9; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 9; i_++) {
      switch (i_) {
         case 0:
         /* decode keyType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.keyTypePresent = 1;

            stat = asn1PD_BasicVehicleClass (pctxt, &pvalue->keyType);

         }
         break;

         case 1:
         /* decode role */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.rolePresent = 1;

            stat = asn1PD_BasicVehicleRole (pctxt, &pvalue->role);

         }
         break;

         case 2:
         /* decode iso3883 */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.iso3883Present = 1;

            stat = asn1PD_Iso3833VehicleType (pctxt, &pvalue->iso3883);

         }
         break;

         case 3:
         /* decode hpmsType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.hpmsTypePresent = 1;

            stat = asn1PD_VehicleType (pctxt, &pvalue->hpmsType);

         }
         break;

         case 4:
         /* decode vehicleType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.vehicleTypePresent = 1;

            stat = asn1PD_VehicleGroupAffected (pctxt, &pvalue->vehicleType);

         }
         break;

         case 5:
         /* decode responseEquip */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.responseEquipPresent = 1;

            stat = asn1PD_IncidentResponseEquipment (pctxt, &pvalue->responseEquip);

         }
         break;

         case 6:
         /* decode responderType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.responderTypePresent = 1;

            stat = asn1PD_ResponderGroupAffected (pctxt, &pvalue->responderType);

         }
         break;

         case 7:
         /* decode fuelType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.fuelTypePresent = 1;

            stat = asn1PD_FuelType (pctxt, &pvalue->fuelType);

         }
         break;

         case 8:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_VehicleClassification_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleClassification: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleSafetyExtensions (OSCTXT* pctxt, VehicleSafetyExtensions* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleSafetyExtensions: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode events */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.eventsPresent = 1;

            stat = asn1PD_VehicleEventFlags (pctxt, &pvalue->events);

         }
         break;

         case 1:
         /* decode pathHistory */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.pathHistoryPresent = 1;

            stat = asn1PD_PathHistory (pctxt, &pvalue->pathHistory);

         }
         break;

         case 2:
         /* decode pathPrediction */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.pathPredictionPresent = 1;

            stat = asn1PD_PathPrediction (pctxt, &pvalue->pathPrediction);

         }
         break;

         case 3:
         /* decode lights */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.lightsPresent = 1;

            stat = asn1PD_ExteriorLights (pctxt, &pvalue->lights);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleSafetyExtensions: end\n");

   return (stat);
}

EXTERN int asn1PD_WiperSet (OSCTXT* pctxt, WiperSet* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_WiperSet: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode statusFront */
   stat = asn1PD_WiperStatus (pctxt, &pvalue->statusFront);
   if (stat != 0) return stat;

   /* decode rateFront */
   stat = asn1PD_WiperRate (pctxt, &pvalue->rateFront);
   if (stat != 0) return stat;

   /* decode statusRear */
   if (optbits[0]) {
      pvalue->m.statusRearPresent = 1;

      stat = asn1PD_WiperStatus (pctxt, &pvalue->statusRear);
      if (stat != 0) return stat;

   }

   /* decode rateRear */
   if (optbits[1]) {
      pvalue->m.rateRearPresent = 1;

      stat = asn1PD_WiperRate (pctxt, &pvalue->rateRear);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_WiperSet: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleStatus_steering (OSCTXT* pctxt, VehicleStatus_steering* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatus_steering: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode angle */
         stat = asn1PD_SteeringWheelAngle (pctxt, &pvalue->angle);

         break;

         case 1:
         /* decode confidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.confidencePresent = 1;

            stat = asn1PD_SteeringWheelAngleConfidence (pctxt, &pvalue->confidence);

         }
         break;

         case 2:
         /* decode rate */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.ratePresent = 1;

            stat = asn1PD_SteeringWheelAngleRateOfChange (pctxt, &pvalue->rate);

         }
         break;

         case 3:
         /* decode wheels */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.wheelsPresent = 1;

            stat = asn1PD_DrivingWheelAngle (pctxt, &pvalue->wheels);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatus_steering: end\n");

   return (stat);
}

EXTERN int asn1PD_AccelSteerYawRateConfidence (OSCTXT* pctxt, AccelSteerYawRateConfidence* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AccelSteerYawRateConfidence: start\n");

   /* decode root elements */
   /* decode yawRate */
   stat = asn1PD_YawRateConfidence (pctxt, &pvalue->yawRate);
   if (stat != 0) return stat;

   /* decode acceleration */
   stat = asn1PD_AccelerationConfidence (pctxt, &pvalue->acceleration);
   if (stat != 0) return stat;

   /* decode steeringWheelAngle */
   stat = asn1PD_SteeringWheelAngleConfidence (pctxt, &pvalue->steeringWheelAngle);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_AccelSteerYawRateConfidence: end\n");

   return (stat);
}

EXTERN int asn1PD_ConfidenceSet (OSCTXT* pctxt, ConfidenceSet* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[7];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ConfidenceSet: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode accelConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.accelConfidencePresent = 1;

            stat = asn1PD_AccelSteerYawRateConfidence (pctxt, &pvalue->accelConfidence);

         }
         break;

         case 1:
         /* decode speedConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.speedConfidencePresent = 1;

            stat = asn1PD_SpeedandHeadingandThrottleConfidence (pctxt, &pvalue->speedConfidence);

         }
         break;

         case 2:
         /* decode timeConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeConfidencePresent = 1;

            stat = asn1PD_TimeConfidence (pctxt, &pvalue->timeConfidence);

         }
         break;

         case 3:
         /* decode posConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.posConfidencePresent = 1;

            stat = asn1PD_PositionConfidenceSet (pctxt, &pvalue->posConfidence);

         }
         break;

         case 4:
         /* decode steerConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.steerConfidencePresent = 1;

            stat = asn1PD_SteeringWheelAngleConfidence (pctxt, &pvalue->steerConfidence);

         }
         break;

         case 5:
         /* decode headingConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.headingConfidencePresent = 1;

            stat = asn1PD_HeadingConfidence (pctxt, &pvalue->headingConfidence);

         }
         break;

         case 6:
         /* decode throttleConfidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.throttleConfidencePresent = 1;

            stat = asn1PD_ThrottleConfidence (pctxt, &pvalue->throttleConfidence);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ConfidenceSet: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleStatus_accelSets (OSCTXT* pctxt, VehicleStatus_accelSets* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatus_accelSets: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode accel4way */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.accel4wayPresent = 1;

            stat = asn1PD_AccelerationSet4Way (pctxt, &pvalue->accel4way);

         }
         break;

         case 1:
         /* decode vertAccelThres */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.vertAccelThresPresent = 1;

            stat = asn1PD_VerticalAccelerationThreshold (pctxt, &pvalue->vertAccelThres);

         }
         break;

         case 2:
         /* decode yawRateCon */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.yawRateConPresent = 1;

            stat = asn1PD_YawRateConfidence (pctxt, &pvalue->yawRateCon);

         }
         break;

         case 3:
         /* decode hozAccelCon */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.hozAccelConPresent = 1;

            stat = asn1PD_AccelerationConfidence (pctxt, &pvalue->hozAccelCon);

         }
         break;

         case 4:
         /* decode confidenceSet */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.confidenceSetPresent = 1;

            stat = asn1PD_ConfidenceSet (pctxt, &pvalue->confidenceSet);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatus_accelSets: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleStatus_object (OSCTXT* pctxt, VehicleStatus_object* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatus_object: start\n");

   /* decode root elements */
   /* decode obDist */
   stat = asn1PD_ObstacleDistance (pctxt, &pvalue->obDist);
   if (stat != 0) return stat;

   /* decode obDirect */
   stat = asn1PD_Angle (pctxt, &pvalue->obDirect);
   if (stat != 0) return stat;

   /* decode dateTime */
   stat = asn1PD_DDateTime (pctxt, &pvalue->dateTime);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatus_object: end\n");

   return (stat);
}

EXTERN int asn1PD_BumperHeights (OSCTXT* pctxt, BumperHeights* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_BumperHeights: start\n");

   /* decode root elements */
   /* decode front */
   stat = asn1PD_BumperHeight (pctxt, &pvalue->front);
   if (stat != 0) return stat;

   /* decode rear */
   stat = asn1PD_BumperHeight (pctxt, &pvalue->rear);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_BumperHeights: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleStatus_vehicleData (OSCTXT* pctxt, VehicleStatus_vehicleData* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatus_vehicleData: start\n");

   /* decode root elements */
   /* decode height */
   stat = asn1PD_VehicleHeight (pctxt, &pvalue->height);
   if (stat != 0) return stat;

   /* decode bumpers */
   stat = asn1PD_BumperHeights (pctxt, &pvalue->bumpers);
   if (stat != 0) return stat;

   /* decode mass */
   stat = asn1PD_VehicleMass (pctxt, &pvalue->mass);
   if (stat != 0) return stat;

   /* decode trailerWeight */
   stat = asn1PD_TrailerWeight (pctxt, &pvalue->trailerWeight);
   if (stat != 0) return stat;

   /* decode type */
   stat = asn1PD_VehicleType (pctxt, &pvalue->type);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatus_vehicleData: end\n");

   return (stat);
}

EXTERN int asn1PD_TireData (OSCTXT* pctxt, TireData* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[7];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TireData: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode location */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.locationPresent = 1;

            stat = asn1PD_TireLocation (pctxt, &pvalue->location);

         }
         break;

         case 1:
         /* decode pressure */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.pressurePresent = 1;

            stat = asn1PD_TirePressure (pctxt, &pvalue->pressure);

         }
         break;

         case 2:
         /* decode temp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.tempPresent = 1;

            stat = asn1PD_TireTemp (pctxt, &pvalue->temp);

         }
         break;

         case 3:
         /* decode wheelSensorStatus */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.wheelSensorStatusPresent = 1;

            stat = asn1PD_WheelSensorStatus (pctxt, &pvalue->wheelSensorStatus);

         }
         break;

         case 4:
         /* decode wheelEndElectFault */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.wheelEndElectFaultPresent = 1;

            stat = asn1PD_WheelEndElectFault (pctxt, &pvalue->wheelEndElectFault);

         }
         break;

         case 5:
         /* decode leakageRate */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.leakageRatePresent = 1;

            stat = asn1PD_TireLeakageRate (pctxt, &pvalue->leakageRate);

         }
         break;

         case 6:
         /* decode detection */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.detectionPresent = 1;

            stat = asn1PD_TirePressureThresholdDetection (pctxt, &pvalue->detection);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TireData: end\n");

   return (stat);
}

EXTERN int asn1PD_TireDataList (OSCTXT* pctxt, TireDataList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TireDataList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TireData* pdata;
      rtxDListAllocNodeAndData (pctxt, TireData, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_TireData (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TireData (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TireDataList: end\n");

   return (stat);
}

EXTERN int asn1PD_AxleWeightSet (OSCTXT* pctxt, AxleWeightSet* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_AxleWeightSet: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode location */
   if (optbits[0]) {
      pvalue->m.locationPresent = 1;

      stat = asn1PD_AxleLocation (pctxt, &pvalue->location);
      if (stat != 0) return stat;

   }

   /* decode weight */
   if (optbits[1]) {
      pvalue->m.weightPresent = 1;

      stat = asn1PD_AxleWeight (pctxt, &pvalue->weight);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AxleWeightSet: end\n");

   return (stat);
}

EXTERN int asn1PD_AxleWeightList (OSCTXT* pctxt, AxleWeightList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AxleWeightList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AxleWeightSet* pdata;
      rtxDListAllocNodeAndData (pctxt, AxleWeightSet, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_AxleWeightSet (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AxleWeightSet (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AxleWeightList: end\n");

   return (stat);
}

EXTERN int asn1PD_J1939data (OSCTXT* pctxt, J1939data* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[10];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_J1939data: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 10; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 10; i_++) {
      switch (i_) {
         case 0:
         /* decode tires */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.tiresPresent = 1;

            stat = asn1PD_TireDataList (pctxt, &pvalue->tires);

         }
         break;

         case 1:
         /* decode axles */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.axlesPresent = 1;

            stat = asn1PD_AxleWeightList (pctxt, &pvalue->axles);

         }
         break;

         case 2:
         /* decode trailerWeight */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.trailerWeightPresent = 1;

            stat = asn1PD_TrailerWeight (pctxt, &pvalue->trailerWeight);

         }
         break;

         case 3:
         /* decode cargoWeight */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.cargoWeightPresent = 1;

            stat = asn1PD_CargoWeight (pctxt, &pvalue->cargoWeight);

         }
         break;

         case 4:
         /* decode steeringAxleTemperature */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.steeringAxleTemperaturePresent = 1;

            stat = asn1PD_SteeringAxleTemperature (pctxt, &pvalue->steeringAxleTemperature);

         }
         break;

         case 5:
         /* decode driveAxleLocation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.driveAxleLocationPresent = 1;

            stat = asn1PD_DriveAxleLocation (pctxt, &pvalue->driveAxleLocation);

         }
         break;

         case 6:
         /* decode driveAxleLiftAirPressure */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.driveAxleLiftAirPressurePresent = 1;

            stat = asn1PD_DriveAxleLiftAirPressure (pctxt, &pvalue->driveAxleLiftAirPressure);

         }
         break;

         case 7:
         /* decode driveAxleTemperature */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.driveAxleTemperaturePresent = 1;

            stat = asn1PD_DriveAxleTemperature (pctxt, &pvalue->driveAxleTemperature);

         }
         break;

         case 8:
         /* decode driveAxleLubePressure */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.driveAxleLubePressurePresent = 1;

            stat = asn1PD_DriveAxleLubePressure (pctxt, &pvalue->driveAxleLubePressure);

         }
         break;

         case 9:
         /* decode steeringAxleLubePressure */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.steeringAxleLubePressurePresent = 1;

            stat = asn1PD_SteeringAxleLubePressure (pctxt, &pvalue->steeringAxleLubePressure);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_J1939data: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleStatus_weatherReport (OSCTXT* pctxt, VehicleStatus_weatherReport* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatus_weatherReport: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode isRaining */
         stat = asn1PD_EssPrecipYesNo (pctxt, &pvalue->isRaining);

         break;

         case 1:
         /* decode rainRate */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.rainRatePresent = 1;

            stat = asn1PD_EssPrecipRate (pctxt, &pvalue->rainRate);

         }
         break;

         case 2:
         /* decode precipSituation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.precipSituationPresent = 1;

            stat = asn1PD_EssPrecipSituation (pctxt, &pvalue->precipSituation);

         }
         break;

         case 3:
         /* decode solarRadiation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.solarRadiationPresent = 1;

            stat = asn1PD_EssSolarRadiation (pctxt, &pvalue->solarRadiation);

         }
         break;

         case 4:
         /* decode friction */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.frictionPresent = 1;

            stat = asn1PD_EssMobileFriction (pctxt, &pvalue->friction);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatus_weatherReport: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleStatus (OSCTXT* pctxt, VehicleStatus* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[22];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatus: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 22; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 22; i_++) {
      switch (i_) {
         case 0:
         /* decode lights */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.lightsPresent = 1;

            stat = asn1PD_ExteriorLights (pctxt, &pvalue->lights);

         }
         break;

         case 1:
         /* decode lightBar */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.lightBarPresent = 1;

            stat = asn1PD_LightbarInUse (pctxt, &pvalue->lightBar);

         }
         break;

         case 2:
         /* decode wipers */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.wipersPresent = 1;

            stat = asn1PD_WiperSet (pctxt, &pvalue->wipers);

         }
         break;

         case 3:
         /* decode brakeStatus */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.brakeStatusPresent = 1;

            stat = asn1PD_BrakeSystemStatus (pctxt, &pvalue->brakeStatus);

         }
         break;

         case 4:
         /* decode brakePressure */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.brakePressurePresent = 1;

            stat = asn1PD_BrakeAppliedPressure (pctxt, &pvalue->brakePressure);

         }
         break;

         case 5:
         /* decode roadFriction */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.roadFrictionPresent = 1;

            stat = asn1PD_CoefficientOfFriction (pctxt, &pvalue->roadFriction);

         }
         break;

         case 6:
         /* decode sunData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.sunDataPresent = 1;

            stat = asn1PD_SunSensor (pctxt, &pvalue->sunData);

         }
         break;

         case 7:
         /* decode rainData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.rainDataPresent = 1;

            stat = asn1PD_RainSensor (pctxt, &pvalue->rainData);

         }
         break;

         case 8:
         /* decode airTemp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.airTempPresent = 1;

            stat = asn1PD_AmbientAirTemperature (pctxt, &pvalue->airTemp);

         }
         break;

         case 9:
         /* decode airPres */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.airPresPresent = 1;

            stat = asn1PD_AmbientAirPressure (pctxt, &pvalue->airPres);

         }
         break;

         case 10:
         /* decode steering */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.steeringPresent = 1;

            stat = asn1PD_VehicleStatus_steering (pctxt, &pvalue->steering);

         }
         break;

         case 11:
         /* decode accelSets */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.accelSetsPresent = 1;

            stat = asn1PD_VehicleStatus_accelSets (pctxt, &pvalue->accelSets);

         }
         break;

         case 12:
         /* decode object */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.objectPresent = 1;

            stat = asn1PD_VehicleStatus_object (pctxt, &pvalue->object);

         }
         break;

         case 13:
         /* decode fullPos */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.fullPosPresent = 1;

            stat = asn1PD_FullPositionVector (pctxt, &pvalue->fullPos);

         }
         break;

         case 14:
         /* decode throttlePos */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.throttlePosPresent = 1;

            stat = asn1PD_ThrottlePosition (pctxt, &pvalue->throttlePos);

         }
         break;

         case 15:
         /* decode speedHeadC */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.speedHeadCPresent = 1;

            stat = asn1PD_SpeedandHeadingandThrottleConfidence (pctxt, &pvalue->speedHeadC);

         }
         break;

         case 16:
         /* decode speedC */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.speedCPresent = 1;

            stat = asn1PD_SpeedConfidence (pctxt, &pvalue->speedC);

         }
         break;

         case 17:
         /* decode vehicleData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.vehicleDataPresent = 1;

            stat = asn1PD_VehicleStatus_vehicleData (pctxt, &pvalue->vehicleData);

         }
         break;

         case 18:
         /* decode vehicleIdent */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.vehicleIdentPresent = 1;

            stat = asn1PD_VehicleIdent (pctxt, &pvalue->vehicleIdent);

         }
         break;

         case 19:
         /* decode j1939data */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.j1939dataPresent = 1;

            stat = asn1PD_J1939data (pctxt, &pvalue->j1939data);

         }
         break;

         case 20:
         /* decode weatherReport */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.weatherReportPresent = 1;

            stat = asn1PD_VehicleStatus_weatherReport (pctxt, &pvalue->weatherReport);

         }
         break;

         case 21:
         /* decode gnssStatus */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.gnssStatusPresent = 1;

            stat = asn1PD_GNSSstatus (pctxt, &pvalue->gnssStatus);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleStatus: end\n");

   return (stat);
}

EXTERN int asn1PD_Snapshot (OSCTXT* pctxt, Snapshot* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_Snapshot: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode thePosition */
   stat = asn1PD_FullPositionVector (pctxt, &pvalue->thePosition);
   if (stat != 0) return stat;

   /* decode safetyExt */
   if (optbits[0]) {
      pvalue->m.safetyExtPresent = 1;

      stat = asn1PD_VehicleSafetyExtensions (pctxt, &pvalue->safetyExt);
      if (stat != 0) return stat;

   }

   /* decode dataSet */
   if (optbits[1]) {
      pvalue->m.dataSetPresent = 1;

      stat = asn1PD_VehicleStatus (pctxt, &pvalue->dataSet);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Snapshot: end\n");

   return (stat);
}

EXTERN int asn1PD_ProbeVehicleData_snapshots (OSCTXT* pctxt, ProbeVehicleData_snapshots* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ProbeVehicleData_snapshots: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      Snapshot* pdata;
      rtxDListAllocNodeAndData (pctxt, Snapshot, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_Snapshot (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_Snapshot (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ProbeVehicleData_snapshots: end\n");

   return (stat);
}

EXTERN int asn1PD_ProbeVehicleData_regional (OSCTXT* pctxt, ProbeVehicleData_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ProbeVehicleData_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ProbeVehicleData_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_ProbeVehicleData (OSCTXT* pctxt, ProbeVehicleData* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ProbeVehicleData: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->timeStamp);

         }
         break;

         case 1:
         /* decode segNum */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.segNumPresent = 1;

            stat = asn1PD_ProbeSegmentNumber (pctxt, &pvalue->segNum);

         }
         break;

         case 2:
         /* decode probeID */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.probeIDPresent = 1;

            stat = asn1PD_VehicleIdent (pctxt, &pvalue->probeID);

         }
         break;

         case 3:
         /* decode startVector */
         stat = asn1PD_FullPositionVector (pctxt, &pvalue->startVector);

         break;

         case 4:
         /* decode vehicleType */
         stat = asn1PD_VehicleClassification (pctxt, &pvalue->vehicleType);

         break;

         case 5:
         /* decode snapshots */
         stat = asn1PD_ProbeVehicleData_snapshots (pctxt, &pvalue->snapshots);

         break;

         case 6:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_ProbeVehicleData_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ProbeVehicleData: end\n");

   return (stat);
}

EXTERN int asn1PD_AntennaOffsetSet (OSCTXT* pctxt, AntennaOffsetSet* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AntennaOffsetSet: start\n");

   /* decode root elements */
   /* decode antOffsetX */
   stat = asn1PD_Offset_B12 (pctxt, &pvalue->antOffsetX);
   if (stat != 0) return stat;

   /* decode antOffsetY */
   stat = asn1PD_Offset_B09 (pctxt, &pvalue->antOffsetY);
   if (stat != 0) return stat;

   /* decode antOffsetZ */
   stat = asn1PD_Offset_B10 (pctxt, &pvalue->antOffsetZ);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_AntennaOffsetSet: end\n");

   return (stat);
}

EXTERN int asn1PD_RTCMheader (OSCTXT* pctxt, RTCMheader* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RTCMheader: start\n");

   /* decode root elements */
   /* decode status */
   stat = asn1PD_GNSSstatus (pctxt, &pvalue->status);
   if (stat != 0) return stat;

   /* decode offsetSet */
   stat = asn1PD_AntennaOffsetSet (pctxt, &pvalue->offsetSet);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_RTCMheader: end\n");

   return (stat);
}

EXTERN int asn1PD_RTCMmessageList (OSCTXT* pctxt, RTCMmessageList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RTCMmessageList: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 5){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      asn1Init_RTCMmessage (&pvalue->elem[xx1]);

      stat = asn1PD_RTCMmessage (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RTCMmessageList: end\n");

   return (stat);
}

EXTERN int asn1PD_RTCMcorrections_regional (OSCTXT* pctxt, RTCMcorrections_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RTCMcorrections_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RTCMcorrections_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_RTCMcorrections (OSCTXT* pctxt, RTCMcorrections* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RTCMcorrections: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode msgCnt */
         stat = asn1PD_MsgCount (pctxt, &pvalue->msgCnt);

         break;

         case 1:
         /* decode rev */
         stat = asn1PD_RTCM_Revision (pctxt, &pvalue->rev);

         break;

         case 2:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->timeStamp);

         }
         break;

         case 3:
         /* decode anchorPoint */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.anchorPointPresent = 1;

            stat = asn1PD_FullPositionVector (pctxt, &pvalue->anchorPoint);

         }
         break;

         case 4:
         /* decode rtcmHeader */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.rtcmHeaderPresent = 1;

            stat = asn1PD_RTCMheader (pctxt, &pvalue->rtcmHeader);

         }
         break;

         case 5:
         /* decode msgs */
         stat = asn1PD_RTCMmessageList (pctxt, &pvalue->msgs);

         break;

         case 6:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_RTCMcorrections_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RTCMcorrections: end\n");

   return (stat);
}

EXTERN int asn1PD_EnabledLaneList (OSCTXT* pctxt, EnabledLaneList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EnabledLaneList: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 4);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 16){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_LaneID (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EnabledLaneList: end\n");

   return (stat);
}

EXTERN int asn1PD_TimeChangeDetails (OSCTXT* pctxt, TimeChangeDetails* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeChangeDetails: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode startTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.startTimePresent = 1;

            stat = asn1PD_TimeMark (pctxt, &pvalue->startTime);

         }
         break;

         case 1:
         /* decode minEndTime */
         stat = asn1PD_TimeMark (pctxt, &pvalue->minEndTime);

         break;

         case 2:
         /* decode maxEndTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.maxEndTimePresent = 1;

            stat = asn1PD_TimeMark (pctxt, &pvalue->maxEndTime);

         }
         break;

         case 3:
         /* decode likelyTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.likelyTimePresent = 1;

            stat = asn1PD_TimeMark (pctxt, &pvalue->likelyTime);

         }
         break;

         case 4:
         /* decode confidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.confidencePresent = 1;

            stat = asn1PD_TimeIntervalConfidence (pctxt, &pvalue->confidence);

         }
         break;

         case 5:
         /* decode nextTime */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.nextTimePresent = 1;

            stat = asn1PD_TimeMark (pctxt, &pvalue->nextTime);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeChangeDetails: end\n");

   return (stat);
}

EXTERN int asn1PD_AdvisorySpeed_regional (OSCTXT* pctxt, AdvisorySpeed_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AdvisorySpeed_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AdvisorySpeed_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_AdvisorySpeed (OSCTXT* pctxt, AdvisorySpeed* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AdvisorySpeed: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode type */
         stat = asn1PD_AdvisorySpeedType (pctxt, &pvalue->type);

         break;

         case 1:
         /* decode speed */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.speedPresent = 1;

            stat = asn1PD_SpeedAdvice (pctxt, &pvalue->speed);

         }
         break;

         case 2:
         /* decode confidence */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.confidencePresent = 1;

            stat = asn1PD_SpeedConfidence (pctxt, &pvalue->confidence);

         }
         break;

         case 3:
         /* decode distance */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.distancePresent = 1;

            stat = asn1PD_ZoneLength (pctxt, &pvalue->distance);

         }
         break;

         case 4:
         /* decode class_ */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.class_Present = 1;

            stat = asn1PD_RestrictionClassID (pctxt, &pvalue->class_);

         }
         break;

         case 5:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_AdvisorySpeed_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AdvisorySpeed: end\n");

   return (stat);
}

EXTERN int asn1PD_AdvisorySpeedList (OSCTXT* pctxt, AdvisorySpeedList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AdvisorySpeedList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AdvisorySpeed* pdata;
      rtxDListAllocNodeAndData (pctxt, AdvisorySpeed, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_AdvisorySpeed (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AdvisorySpeed (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AdvisorySpeedList: end\n");

   return (stat);
}

EXTERN int asn1PD_MovementEvent_regional (OSCTXT* pctxt, MovementEvent_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MovementEvent_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MovementEvent_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_MovementEvent (OSCTXT* pctxt, MovementEvent* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MovementEvent: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode eventState */
         stat = asn1PD_MovementPhaseState (pctxt, &pvalue->eventState);

         break;

         case 1:
         /* decode timing */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timingPresent = 1;

            stat = asn1PD_TimeChangeDetails (pctxt, &pvalue->timing);

         }
         break;

         case 2:
         /* decode speeds */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.speedsPresent = 1;

            stat = asn1PD_AdvisorySpeedList (pctxt, &pvalue->speeds);

         }
         break;

         case 3:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_MovementEvent_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MovementEvent: end\n");

   return (stat);
}

EXTERN int asn1PD_MovementEventList (OSCTXT* pctxt, MovementEventList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MovementEventList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MovementEvent* pdata;
      rtxDListAllocNodeAndData (pctxt, MovementEvent, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_MovementEvent (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_MovementEvent (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MovementEventList: end\n");

   return (stat);
}

EXTERN int asn1PD_ConnectionManeuverAssist_regional (OSCTXT* pctxt, ConnectionManeuverAssist_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ConnectionManeuverAssist_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ConnectionManeuverAssist_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_ConnectionManeuverAssist (OSCTXT* pctxt, ConnectionManeuverAssist* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ConnectionManeuverAssist: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode connectionID */
         stat = asn1PD_LaneConnectionID (pctxt, &pvalue->connectionID);

         break;

         case 1:
         /* decode queueLength */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.queueLengthPresent = 1;

            stat = asn1PD_ZoneLength (pctxt, &pvalue->queueLength);

         }
         break;

         case 2:
         /* decode availableStorageLength */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.availableStorageLengthPresent = 1;

            stat = asn1PD_ZoneLength (pctxt, &pvalue->availableStorageLength);

         }
         break;

         case 3:
         /* decode waitOnStop */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.waitOnStopPresent = 1;

            stat = asn1PD_WaitOnStopline (pctxt, &pvalue->waitOnStop);

         }
         break;

         case 4:
         /* decode pedBicycleDetect */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.pedBicycleDetectPresent = 1;

            stat = asn1PD_PedestrianBicycleDetect (pctxt, &pvalue->pedBicycleDetect);

         }
         break;

         case 5:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_ConnectionManeuverAssist_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ConnectionManeuverAssist: end\n");

   return (stat);
}

EXTERN int asn1PD_ManeuverAssistList (OSCTXT* pctxt, ManeuverAssistList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ManeuverAssistList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ConnectionManeuverAssist* pdata;
      rtxDListAllocNodeAndData (pctxt, ConnectionManeuverAssist, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_ConnectionManeuverAssist (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ConnectionManeuverAssist (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ManeuverAssistList: end\n");

   return (stat);
}

EXTERN int asn1PD_MovementState_regional (OSCTXT* pctxt, MovementState_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MovementState_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MovementState_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_MovementState (OSCTXT* pctxt, MovementState* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MovementState: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode movementName */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.movementNamePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, &pvalue->movementName);

         }
         break;

         case 1:
         /* decode signalGroup */
         stat = asn1PD_SignalGroupID (pctxt, &pvalue->signalGroup);

         break;

         case 2:
         /* decode state_time_speed */
         stat = asn1PD_MovementEventList (pctxt, &pvalue->state_time_speed);

         break;

         case 3:
         /* decode maneuverAssistList */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.maneuverAssistListPresent = 1;

            stat = asn1PD_ManeuverAssistList (pctxt, &pvalue->maneuverAssistList);

         }
         break;

         case 4:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_MovementState_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MovementState: end\n");

   return (stat);
}

EXTERN int asn1PD_MovementList (OSCTXT* pctxt, MovementList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MovementList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MovementState* pdata;
      rtxDListAllocNodeAndData (pctxt, MovementState, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_MovementState (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_MovementState (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MovementList: end\n");

   return (stat);
}

EXTERN int asn1PD_IntersectionState_regional (OSCTXT* pctxt, IntersectionState_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionState_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionState_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_IntersectionState (OSCTXT* pctxt, IntersectionState* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[6];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionState: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 10; i_++) {
      switch (i_) {
         case 0:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, &pvalue->name);

         }
         break;

         case 1:
         /* decode id */
         stat = asn1PD_IntersectionReferenceID (pctxt, &pvalue->id);

         break;

         case 2:
         /* decode revision */
         stat = asn1PD_MsgCount (pctxt, &pvalue->revision);

         break;

         case 3:
         /* decode status */
         stat = asn1PD_IntersectionStatusObject (pctxt, &pvalue->status);

         break;

         case 4:
         /* decode moy */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.moyPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->moy);

         }
         break;

         case 5:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_DSecond (pctxt, &pvalue->timeStamp);

         }
         break;

         case 6:
         /* decode enabledLanes */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.enabledLanesPresent = 1;

            stat = asn1PD_EnabledLaneList (pctxt, &pvalue->enabledLanes);

         }
         break;

         case 7:
         /* decode states */
         stat = asn1PD_MovementList (pctxt, &pvalue->states);

         break;

         case 8:
         /* decode maneuverAssistList */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.maneuverAssistListPresent = 1;

            stat = asn1PD_ManeuverAssistList (pctxt, &pvalue->maneuverAssistList);

         }
         break;

         case 9:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_IntersectionState_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionState: end\n");

   return (stat);
}

EXTERN int asn1PD_IntersectionStateList (OSCTXT* pctxt, IntersectionStateList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionStateList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      IntersectionState* pdata;
      rtxDListAllocNodeAndData (pctxt, IntersectionState, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_IntersectionState (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_IntersectionState (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionStateList: end\n");

   return (stat);
}

EXTERN int asn1PD_SPAT_regional (OSCTXT* pctxt, SPAT_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SPAT_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SPAT_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_SPAT (OSCTXT* pctxt, SPAT* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SPAT: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->timeStamp);

         }
         break;

         case 1:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, &pvalue->name);

         }
         break;

         case 2:
         /* decode intersections */
         stat = asn1PD_IntersectionStateList (pctxt, &pvalue->intersections);

         break;

         case 3:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_SPAT_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SPAT: end\n");

   return (stat);
}

EXTERN int asn1PD_IntersectionAccessPoint (OSCTXT* pctxt, IntersectionAccessPoint* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionAccessPoint: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = rtxDecBits (pctxt, &ui, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      RTXCTXTPOPELEMNAME (pctxt);

      switch (ui) {
         /* lane */
         case 0:
            stat = asn1PD_LaneID (pctxt, &pvalue->u.lane);
            if (stat != 0) return stat;

            break;

         /* approach */
         case 1:
            stat = asn1PD_ApproachID (pctxt, &pvalue->u.approach);
            if (stat != 0) return stat;

            break;

         /* connection */
         case 2:
            stat = asn1PD_LaneConnectionID (pctxt, &pvalue->u.connection);
            if (stat != 0) return stat;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return RTERR_INVOPT;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return stat;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IntersectionAccessPoint: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalRequest_regional (OSCTXT* pctxt, SignalRequest_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequest_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequest_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalRequest (OSCTXT* pctxt, SignalRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode id */
   stat = asn1PD_IntersectionReferenceID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* decode requestID */
   stat = asn1PD_RequestID (pctxt, &pvalue->requestID);
   if (stat != 0) return stat;

   /* decode requestType */
   stat = asn1PD_PriorityRequestType (pctxt, &pvalue->requestType);
   if (stat != 0) return stat;

   /* decode inBoundLane */
   stat = asn1PD_IntersectionAccessPoint (pctxt, &pvalue->inBoundLane);
   if (stat != 0) return stat;

   /* decode outBoundLane */
   if (optbits[0]) {
      pvalue->m.outBoundLanePresent = 1;

      stat = asn1PD_IntersectionAccessPoint (pctxt, &pvalue->outBoundLane);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_SignalRequest_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequest: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalRequestPackage_regional (OSCTXT* pctxt, SignalRequestPackage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequestPackage_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequestPackage_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalRequestPackage (OSCTXT* pctxt, SignalRequestPackage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequestPackage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode request */
         stat = asn1PD_SignalRequest (pctxt, &pvalue->request);

         break;

         case 1:
         /* decode minute */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.minutePresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->minute);

         }
         break;

         case 2:
         /* decode second */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.secondPresent = 1;

            stat = asn1PD_DSecond (pctxt, &pvalue->second);

         }
         break;

         case 3:
         /* decode duration */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.durationPresent = 1;

            stat = asn1PD_DSecond (pctxt, &pvalue->duration);

         }
         break;

         case 4:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_SignalRequestPackage_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequestPackage: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalRequestList (OSCTXT* pctxt, SignalRequestList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequestList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SignalRequestPackage* pdata;
      rtxDListAllocNodeAndData (pctxt, SignalRequestPackage, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_SignalRequestPackage (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SignalRequestPackage (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequestList: end\n");

   return (stat);
}

EXTERN int asn1PD_RequestorType (OSCTXT* pctxt, RequestorType* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestorType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode role */
         stat = asn1PD_BasicVehicleRole (pctxt, &pvalue->role);

         break;

         case 1:
         /* decode subrole */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.subrolePresent = 1;

            stat = asn1PD_RequestSubRole (pctxt, &pvalue->subrole);

         }
         break;

         case 2:
         /* decode request */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.requestPresent = 1;

            stat = asn1PD_RequestImportanceLevel (pctxt, &pvalue->request);

         }
         break;

         case 3:
         /* decode iso3883 */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.iso3883Present = 1;

            stat = asn1PD_Iso3833VehicleType (pctxt, &pvalue->iso3883);

         }
         break;

         case 4:
         /* decode hpmsType */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.hpmsTypePresent = 1;

            stat = asn1PD_VehicleType (pctxt, &pvalue->hpmsType);

         }
         break;

         case 5:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestorType: end\n");

   return (stat);
}

EXTERN int asn1PD_RequestorPositionVector (OSCTXT* pctxt, RequestorPositionVector* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestorPositionVector: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode position */
   stat = asn1PD_Position3D (pctxt, &pvalue->position);
   if (stat != 0) return stat;

   /* decode heading */
   if (optbits[0]) {
      pvalue->m.headingPresent = 1;

      stat = asn1PD_Angle (pctxt, &pvalue->heading);
      if (stat != 0) return stat;

   }

   /* decode speed */
   if (optbits[1]) {
      pvalue->m.speedPresent = 1;

      stat = asn1PD_TransmissionAndSpeed (pctxt, &pvalue->speed);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestorPositionVector: end\n");

   return (stat);
}

EXTERN int asn1PD_RequestorDescription_regional (OSCTXT* pctxt, RequestorDescription_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestorDescription_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestorDescription_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_RequestorDescription (OSCTXT* pctxt, RequestorDescription* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[8];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestorDescription: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 8; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 9; i_++) {
      switch (i_) {
         case 0:
         /* decode id */
         stat = asn1PD_VehicleID (pctxt, &pvalue->id);

         break;

         case 1:
         /* decode type */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.typePresent = 1;

            stat = asn1PD_RequestorType (pctxt, &pvalue->type);

         }
         break;

         case 2:
         /* decode position */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.positionPresent = 1;

            stat = asn1PD_RequestorPositionVector (pctxt, &pvalue->position);

         }
         break;

         case 3:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, &pvalue->name);

         }
         break;

         case 4:
         /* decode routeName */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.routeNamePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, &pvalue->routeName);

         }
         break;

         case 5:
         /* decode transitStatus */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.transitStatusPresent = 1;

            stat = asn1PD_TransitVehicleStatus (pctxt, &pvalue->transitStatus);

         }
         break;

         case 6:
         /* decode transitOccupancy */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.transitOccupancyPresent = 1;

            stat = asn1PD_TransitVehicleOccupancy (pctxt, &pvalue->transitOccupancy);

         }
         break;

         case 7:
         /* decode transitSchedule */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.transitSchedulePresent = 1;

            stat = asn1PD_DeltaTime (pctxt, &pvalue->transitSchedule);

         }
         break;

         case 8:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_RequestorDescription_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RequestorDescription: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalRequestMessage_regional (OSCTXT* pctxt, SignalRequestMessage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequestMessage_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequestMessage_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalRequestMessage (OSCTXT* pctxt, SignalRequestMessage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequestMessage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->timeStamp);

         }
         break;

         case 1:
         /* decode second */
         stat = asn1PD_DSecond (pctxt, &pvalue->second);

         break;

         case 2:
         /* decode sequenceNumber */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.sequenceNumberPresent = 1;

            stat = asn1PD_MsgCount (pctxt, &pvalue->sequenceNumber);

         }
         break;

         case 3:
         /* decode requests */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.requestsPresent = 1;

            stat = asn1PD_SignalRequestList (pctxt, &pvalue->requests);

         }
         break;

         case 4:
         /* decode requestor */
         stat = asn1PD_RequestorDescription (pctxt, &pvalue->requestor);

         break;

         case 5:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_SignalRequestMessage_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequestMessage: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalRequesterInfo (OSCTXT* pctxt, SignalRequesterInfo* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequesterInfo: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode id */
   stat = asn1PD_VehicleID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* decode request */
   stat = asn1PD_RequestID (pctxt, &pvalue->request);
   if (stat != 0) return stat;

   /* decode sequenceNumber */
   stat = asn1PD_MsgCount (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   /* decode role */
   if (optbits[0]) {
      pvalue->m.rolePresent = 1;

      stat = asn1PD_BasicVehicleRole (pctxt, &pvalue->role);
      if (stat != 0) return stat;

   }

   /* decode typeData */
   if (optbits[1]) {
      pvalue->m.typeDataPresent = 1;

      stat = asn1PD_RequestorType (pctxt, &pvalue->typeData);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalRequesterInfo: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalStatusPackage_regional (OSCTXT* pctxt, SignalStatusPackage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatusPackage_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatusPackage_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalStatusPackage (OSCTXT* pctxt, SignalStatusPackage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[6];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatusPackage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 8; i_++) {
      switch (i_) {
         case 0:
         /* decode requester */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.requesterPresent = 1;

            stat = asn1PD_SignalRequesterInfo (pctxt, &pvalue->requester);

         }
         break;

         case 1:
         /* decode inboundOn */
         stat = asn1PD_IntersectionAccessPoint (pctxt, &pvalue->inboundOn);

         break;

         case 2:
         /* decode outboundOn */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.outboundOnPresent = 1;

            stat = asn1PD_IntersectionAccessPoint (pctxt, &pvalue->outboundOn);

         }
         break;

         case 3:
         /* decode minute */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.minutePresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->minute);

         }
         break;

         case 4:
         /* decode second */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.secondPresent = 1;

            stat = asn1PD_DSecond (pctxt, &pvalue->second);

         }
         break;

         case 5:
         /* decode duration */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.durationPresent = 1;

            stat = asn1PD_DSecond (pctxt, &pvalue->duration);

         }
         break;

         case 6:
         /* decode status */
         stat = asn1PD_PrioritizationResponseStatus (pctxt, &pvalue->status);

         break;

         case 7:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_SignalStatusPackage_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatusPackage: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalStatusPackageList (OSCTXT* pctxt, SignalStatusPackageList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatusPackageList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SignalStatusPackage* pdata;
      rtxDListAllocNodeAndData (pctxt, SignalStatusPackage, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_SignalStatusPackage (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SignalStatusPackage (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatusPackageList: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalStatus_regional (OSCTXT* pctxt, SignalStatus_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatus_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatus_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalStatus (OSCTXT* pctxt, SignalStatus* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatus: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode sequenceNumber */
   stat = asn1PD_MsgCount (pctxt, &pvalue->sequenceNumber);
   if (stat != 0) return stat;

   /* decode id */
   stat = asn1PD_IntersectionReferenceID (pctxt, &pvalue->id);
   if (stat != 0) return stat;

   /* decode sigStatus */
   stat = asn1PD_SignalStatusPackageList (pctxt, &pvalue->sigStatus);
   if (stat != 0) return stat;

   /* decode regional */
   if (optbits[0]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_SignalStatus_regional (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatus: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalStatusList (OSCTXT* pctxt, SignalStatusList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatusList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SignalStatus* pdata;
      rtxDListAllocNodeAndData (pctxt, SignalStatus, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_SignalStatus (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SignalStatus (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatusList: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalStatusMessage_regional (OSCTXT* pctxt, SignalStatusMessage_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatusMessage_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatusMessage_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_SignalStatusMessage (OSCTXT* pctxt, SignalStatusMessage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatusMessage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->timeStamp);

         }
         break;

         case 1:
         /* decode second */
         stat = asn1PD_DSecond (pctxt, &pvalue->second);

         break;

         case 2:
         /* decode sequenceNumber */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.sequenceNumberPresent = 1;

            stat = asn1PD_MsgCount (pctxt, &pvalue->sequenceNumber);

         }
         break;

         case 3:
         /* decode status */
         stat = asn1PD_SignalStatusList (pctxt, &pvalue->status);

         break;

         case 4:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_SignalStatusMessage_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SignalStatusMessage: end\n");

   return (stat);
}

EXTERN int asn1PD_RoadSignID (OSCTXT* pctxt, RoadSignID* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSignID: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode position */
   stat = asn1PD_Position3D (pctxt, &pvalue->position);
   if (stat != 0) return stat;

   /* decode viewAngle */
   stat = asn1PD_HeadingSlice (pctxt, &pvalue->viewAngle);
   if (stat != 0) return stat;

   /* decode mutcdCode */
   if (optbits[0]) {
      pvalue->m.mutcdCodePresent = 1;

      stat = asn1PD_MUTCDCode (pctxt, &pvalue->mutcdCode);
      if (stat != 0) return stat;

   }

   /* decode crc */
   if (optbits[1]) {
      pvalue->m.crcPresent = 1;

      stat = asn1PD_MsgCRC (pctxt, &pvalue->crc);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RoadSignID: end\n");

   return (stat);
}

EXTERN int asn1PD_TravelerDataFrame_msgId (OSCTXT* pctxt, TravelerDataFrame_msgId* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerDataFrame_msgId: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* furtherInfoID */
      case 0:
         pvalue->u.furtherInfoID = rtxMemAllocType (pctxt, FurtherInfoID);

         if (pvalue->u.furtherInfoID == NULL)
            return RTERR_NOMEM;

         asn1Init_FurtherInfoID (pvalue->u.furtherInfoID);

         stat = asn1PD_FurtherInfoID (pctxt, pvalue->u.furtherInfoID);
         if (stat != 0) return stat;

         break;

      /* roadSignID */
      case 1:
         pvalue->u.roadSignID = rtxMemAllocType (pctxt, RoadSignID);

         if (pvalue->u.roadSignID == NULL)
            return RTERR_NOMEM;

         asn1Init_RoadSignID (pvalue->u.roadSignID);

         stat = asn1PD_RoadSignID (pctxt, pvalue->u.roadSignID);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerDataFrame_msgId: end\n");

   return (stat);
}

EXTERN int asn1PD_Node_LL_24B (OSCTXT* pctxt, Node_LL_24B* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_LL_24B: start\n");

   /* decode root elements */
   /* decode lon */
   stat = asn1PD_OffsetLL_B12 (pctxt, &pvalue->lon);
   if (stat != 0) return stat;

   /* decode lat */
   stat = asn1PD_OffsetLL_B12 (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_LL_24B: end\n");

   return (stat);
}

EXTERN int asn1PD_Node_LL_28B (OSCTXT* pctxt, Node_LL_28B* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_LL_28B: start\n");

   /* decode root elements */
   /* decode lon */
   stat = asn1PD_OffsetLL_B14 (pctxt, &pvalue->lon);
   if (stat != 0) return stat;

   /* decode lat */
   stat = asn1PD_OffsetLL_B14 (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_LL_28B: end\n");

   return (stat);
}

EXTERN int asn1PD_Node_LL_32B (OSCTXT* pctxt, Node_LL_32B* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_LL_32B: start\n");

   /* decode root elements */
   /* decode lon */
   stat = asn1PD_OffsetLL_B16 (pctxt, &pvalue->lon);
   if (stat != 0) return stat;

   /* decode lat */
   stat = asn1PD_OffsetLL_B16 (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_LL_32B: end\n");

   return (stat);
}

EXTERN int asn1PD_Node_LL_36B (OSCTXT* pctxt, Node_LL_36B* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_LL_36B: start\n");

   /* decode root elements */
   /* decode lon */
   stat = asn1PD_OffsetLL_B18 (pctxt, &pvalue->lon);
   if (stat != 0) return stat;

   /* decode lat */
   stat = asn1PD_OffsetLL_B18 (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_LL_36B: end\n");

   return (stat);
}

EXTERN int asn1PD_Node_LL_44B (OSCTXT* pctxt, Node_LL_44B* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_LL_44B: start\n");

   /* decode root elements */
   /* decode lon */
   stat = asn1PD_OffsetLL_B22 (pctxt, &pvalue->lon);
   if (stat != 0) return stat;

   /* decode lat */
   stat = asn1PD_OffsetLL_B22 (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_LL_44B: end\n");

   return (stat);
}

EXTERN int asn1PD_Node_LL_48B (OSCTXT* pctxt, Node_LL_48B* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_LL_48B: start\n");

   /* decode root elements */
   /* decode lon */
   stat = asn1PD_OffsetLL_B24 (pctxt, &pvalue->lon);
   if (stat != 0) return stat;

   /* decode lat */
   stat = asn1PD_OffsetLL_B24 (pctxt, &pvalue->lat);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_Node_LL_48B: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeOffsetPointLL (OSCTXT* pctxt, NodeOffsetPointLL* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeOffsetPointLL: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   stat = rtxDecBits (pctxt, &ui, 3);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* node_LL1 */
      case 0:
         pvalue->u.node_LL1 = rtxMemAllocTypeZ (pctxt, Node_LL_24B);

         if (pvalue->u.node_LL1 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LL_24B (pctxt, pvalue->u.node_LL1);
         if (stat != 0) return stat;

         break;

      /* node_LL2 */
      case 1:
         pvalue->u.node_LL2 = rtxMemAllocTypeZ (pctxt, Node_LL_28B);

         if (pvalue->u.node_LL2 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LL_28B (pctxt, pvalue->u.node_LL2);
         if (stat != 0) return stat;

         break;

      /* node_LL3 */
      case 2:
         pvalue->u.node_LL3 = rtxMemAllocTypeZ (pctxt, Node_LL_32B);

         if (pvalue->u.node_LL3 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LL_32B (pctxt, pvalue->u.node_LL3);
         if (stat != 0) return stat;

         break;

      /* node_LL4 */
      case 3:
         pvalue->u.node_LL4 = rtxMemAllocTypeZ (pctxt, Node_LL_36B);

         if (pvalue->u.node_LL4 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LL_36B (pctxt, pvalue->u.node_LL4);
         if (stat != 0) return stat;

         break;

      /* node_LL5 */
      case 4:
         pvalue->u.node_LL5 = rtxMemAllocTypeZ (pctxt, Node_LL_44B);

         if (pvalue->u.node_LL5 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LL_44B (pctxt, pvalue->u.node_LL5);
         if (stat != 0) return stat;

         break;

      /* node_LL6 */
      case 5:
         pvalue->u.node_LL6 = rtxMemAllocTypeZ (pctxt, Node_LL_48B);

         if (pvalue->u.node_LL6 == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LL_48B (pctxt, pvalue->u.node_LL6);
         if (stat != 0) return stat;

         break;

      /* node_LatLon */
      case 6:
         pvalue->u.node_LatLon = rtxMemAllocTypeZ (pctxt, Node_LLmD_64b);

         if (pvalue->u.node_LatLon == NULL)
            return RTERR_NOMEM;

         stat = asn1PD_Node_LLmD_64b (pctxt, pvalue->u.node_LatLon);
         if (stat != 0) return stat;

         break;

      /* regional */
      case 7:
         pvalue->u.regional = rtxMemAllocType (pctxt, RegionalExtension);

         if (pvalue->u.regional == NULL)
            return RTERR_NOMEM;

         asn1Init_RegionalExtension (pvalue->u.regional);

         stat = asn1PD_RegionalExtension (pctxt, pvalue->u.regional);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeOffsetPointLL: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeAttributeLLList (OSCTXT* pctxt, NodeAttributeLLList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeLLList: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 8){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_NodeAttributeLL (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeLLList: end\n");

   return (stat);
}

EXTERN int asn1PD_SegmentAttributeLLList (OSCTXT* pctxt, SegmentAttributeLLList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SegmentAttributeLLList: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 8){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_SegmentAttributeLL (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SegmentAttributeLLList: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeAttributeSetLL_regional (OSCTXT* pctxt, NodeAttributeSetLL_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeSetLL_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeSetLL_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeAttributeSetLL (OSCTXT* pctxt, NodeAttributeSetLL* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[7];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeSetLL: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 7; i_++) {
      switch (i_) {
         case 0:
         /* decode localNode */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.localNodePresent = 1;

            stat = asn1PD_NodeAttributeLLList (pctxt, &pvalue->localNode);

         }
         break;

         case 1:
         /* decode disabled */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.disabledPresent = 1;

            stat = asn1PD_SegmentAttributeLLList (pctxt, &pvalue->disabled);

         }
         break;

         case 2:
         /* decode enabled */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.enabledPresent = 1;

            stat = asn1PD_SegmentAttributeLLList (pctxt, &pvalue->enabled);

         }
         break;

         case 3:
         /* decode data */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.dataPresent = 1;

            stat = asn1PD_LaneDataAttributeList (pctxt, &pvalue->data);

         }
         break;

         case 4:
         /* decode dWidth */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.dWidthPresent = 1;

            stat = asn1PD_Offset_B10 (pctxt, &pvalue->dWidth);

         }
         break;

         case 5:
         /* decode dElevation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.dElevationPresent = 1;

            stat = asn1PD_Offset_B10 (pctxt, &pvalue->dElevation);

         }
         break;

         case 6:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_NodeAttributeSetLL_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeAttributeSetLL: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeLL (OSCTXT* pctxt, NodeLL* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeLL: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode delta */
   stat = asn1PD_NodeOffsetPointLL (pctxt, &pvalue->delta);
   if (stat != 0) return stat;

   /* decode attributes */
   if (optbits[0]) {
      pvalue->m.attributesPresent = 1;

      stat = asn1PD_NodeAttributeSetLL (pctxt, &pvalue->attributes);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeLL: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeSetLL (OSCTXT* pctxt, NodeSetLL* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeSetLL: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(63), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NodeLL* pdata;
      rtxDListAllocNodeAndData (pctxt, NodeLL, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_NodeLL (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NodeLL (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeSetLL: end\n");

   return (stat);
}

EXTERN int asn1PD_NodeListLL (OSCTXT* pctxt, NodeListLL* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeListLL: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      RTXCTXTPUSHELEMNAME (pctxt, "t");

      ui = 0;
      pvalue->t = ui + 1;

      RTXCTXTPOPELEMNAME (pctxt);

      switch (ui) {
         /* nodes */
         case 0:
            pvalue->u.nodes = rtxMemAllocType (pctxt, NodeSetLL);

            if (pvalue->u.nodes == NULL)
               return RTERR_NOMEM;

            asn1Init_NodeSetLL (pvalue->u.nodes);

            stat = asn1PD_NodeSetLL (pctxt, pvalue->u.nodes);
            if (stat != 0) return stat;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return RTERR_INVOPT;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return stat;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NodeListLL: end\n");

   return (stat);
}

EXTERN int asn1PD_OffsetSystem_offset (OSCTXT* pctxt, OffsetSystem_offset* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_OffsetSystem_offset: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* xy */
      case 0:
         pvalue->u.xy = rtxMemAllocType (pctxt, NodeListXY);

         if (pvalue->u.xy == NULL)
            return RTERR_NOMEM;

         asn1Init_NodeListXY (pvalue->u.xy);

         stat = asn1PD_NodeListXY (pctxt, pvalue->u.xy);
         if (stat != 0) return stat;

         break;

      /* ll */
      case 1:
         pvalue->u.ll = rtxMemAllocType (pctxt, NodeListLL);

         if (pvalue->u.ll == NULL)
            return RTERR_NOMEM;

         asn1Init_NodeListLL (pvalue->u.ll);

         stat = asn1PD_NodeListLL (pctxt, pvalue->u.ll);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_OffsetSystem_offset: end\n");

   return (stat);
}

EXTERN int asn1PD_OffsetSystem (OSCTXT* pctxt, OffsetSystem* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTDIAGSTRM2 (pctxt,"asn1PD_OffsetSystem: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode scale */
   if (optbits[0]) {
      pvalue->m.scalePresent = 1;

      stat = asn1PD_Zoom (pctxt, &pvalue->scale);
      if (stat != 0) return stat;

   }

   /* decode offset */
   stat = asn1PD_OffsetSystem_offset (pctxt, &pvalue->offset);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_OffsetSystem: end\n");

   return (stat);
}

EXTERN int asn1PD_Circle (OSCTXT* pctxt, Circle* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Circle: start\n");

   /* decode root elements */
   /* decode center */
   stat = asn1PD_Position3D (pctxt, &pvalue->center);
   if (stat != 0) return stat;

   /* decode radius */
   stat = asn1PD_Radius_B12 (pctxt, &pvalue->radius);
   if (stat != 0) return stat;

   /* decode units */
   stat = asn1PD_DistanceUnits (pctxt, &pvalue->units);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_Circle: end\n");

   return (stat);
}

EXTERN int asn1PD_GeometricProjection_regional (OSCTXT* pctxt, GeometricProjection_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GeometricProjection_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GeometricProjection_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_GeometricProjection (OSCTXT* pctxt, GeometricProjection* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GeometricProjection: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 5; i_++) {
      switch (i_) {
         case 0:
         /* decode direction */
         stat = asn1PD_HeadingSlice (pctxt, &pvalue->direction);

         break;

         case 1:
         /* decode extent */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.extentPresent = 1;

            stat = asn1PD_Extent (pctxt, &pvalue->extent);

         }
         break;

         case 2:
         /* decode laneWidth */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.laneWidthPresent = 1;

            stat = asn1PD_LaneWidth (pctxt, &pvalue->laneWidth);

         }
         break;

         case 3:
         /* decode circle */
         stat = asn1PD_Circle (pctxt, &pvalue->circle);

         break;

         case 4:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_GeometricProjection_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GeometricProjection: end\n");

   return (stat);
}

EXTERN int asn1PD_ShapePointSet (OSCTXT* pctxt, ShapePointSet* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ShapePointSet: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode anchor */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.anchorPresent = 1;

            stat = asn1PD_Position3D (pctxt, &pvalue->anchor);

         }
         break;

         case 1:
         /* decode laneWidth */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.laneWidthPresent = 1;

            stat = asn1PD_LaneWidth (pctxt, &pvalue->laneWidth);

         }
         break;

         case 2:
         /* decode directionality */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.directionalityPresent = 1;

            stat = asn1PD_DirectionOfUse (pctxt, &pvalue->directionality);

         }
         break;

         case 3:
         /* decode nodeList */
         stat = asn1PD_NodeListXY (pctxt, &pvalue->nodeList);

         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ShapePointSet: end\n");

   return (stat);
}

EXTERN int asn1PD_RegionOffsets (OSCTXT* pctxt, RegionOffsets* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTDIAGSTRM2 (pctxt,"asn1PD_RegionOffsets: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode xOffset */
   stat = asn1PD_OffsetLL_B16 (pctxt, &pvalue->xOffset);
   if (stat != 0) return stat;

   /* decode yOffset */
   stat = asn1PD_OffsetLL_B16 (pctxt, &pvalue->yOffset);
   if (stat != 0) return stat;

   /* decode zOffset */
   if (optbits[0]) {
      pvalue->m.zOffsetPresent = 1;

      stat = asn1PD_OffsetLL_B16 (pctxt, &pvalue->zOffset);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RegionOffsets: end\n");

   return (stat);
}

EXTERN int asn1PD_RegionList (OSCTXT* pctxt, RegionList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RegionList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionOffsets* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionOffsets, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionOffsets (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionOffsets (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RegionList: end\n");

   return (stat);
}

EXTERN int asn1PD_RegionPointSet (OSCTXT* pctxt, RegionPointSet* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_RegionPointSet: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode anchor */
   if (optbits[0]) {
      pvalue->m.anchorPresent = 1;

      stat = asn1PD_Position3D (pctxt, &pvalue->anchor);
      if (stat != 0) return stat;

   }

   /* decode scale */
   if (optbits[1]) {
      pvalue->m.scalePresent = 1;

      stat = asn1PD_Zoom (pctxt, &pvalue->scale);
      if (stat != 0) return stat;

   }

   /* decode nodeList */
   stat = asn1PD_RegionList (pctxt, &pvalue->nodeList);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RegionPointSet: end\n");

   return (stat);
}

EXTERN int asn1PD_ValidRegion_area (OSCTXT* pctxt, ValidRegion_area* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_ValidRegion_area: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* shapePointSet */
      case 0:
         pvalue->u.shapePointSet = rtxMemAllocType (pctxt, ShapePointSet);

         if (pvalue->u.shapePointSet == NULL)
            return RTERR_NOMEM;

         asn1Init_ShapePointSet (pvalue->u.shapePointSet);

         stat = asn1PD_ShapePointSet (pctxt, pvalue->u.shapePointSet);
         if (stat != 0) return stat;

         break;

      /* circle */
      case 1:
         pvalue->u.circle = rtxMemAllocType (pctxt, Circle);

         if (pvalue->u.circle == NULL)
            return RTERR_NOMEM;

         asn1Init_Circle (pvalue->u.circle);

         stat = asn1PD_Circle (pctxt, pvalue->u.circle);
         if (stat != 0) return stat;

         break;

      /* regionPointSet */
      case 2:
         pvalue->u.regionPointSet = rtxMemAllocType (pctxt, RegionPointSet);

         if (pvalue->u.regionPointSet == NULL)
            return RTERR_NOMEM;

         asn1Init_RegionPointSet (pvalue->u.regionPointSet);

         stat = asn1PD_RegionPointSet (pctxt, pvalue->u.regionPointSet);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ValidRegion_area: end\n");

   return (stat);
}

EXTERN int asn1PD_ValidRegion (OSCTXT* pctxt, ValidRegion* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTDIAGSTRM2 (pctxt,"asn1PD_ValidRegion: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode direction */
   stat = asn1PD_HeadingSlice (pctxt, &pvalue->direction);
   if (stat != 0) return stat;

   /* decode extent */
   if (optbits[0]) {
      pvalue->m.extentPresent = 1;

      stat = asn1PD_Extent (pctxt, &pvalue->extent);
      if (stat != 0) return stat;

   }

   /* decode area */
   stat = asn1PD_ValidRegion_area (pctxt, &pvalue->area);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_ValidRegion: end\n");

   return (stat);
}

EXTERN int asn1PD_GeographicalPath_description (OSCTXT* pctxt, GeographicalPath_description* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTDIAGSTRM2 (pctxt,"asn1PD_GeographicalPath_description: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   if (!extbit) {
      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = rtxDecBits (pctxt, &ui, 2);
      if (stat != 0) return stat;
      else pvalue->t = ui + 1;

      RTXCTXTPOPELEMNAME (pctxt);

      switch (ui) {
         /* path */
         case 0:
            pvalue->u.path = rtxMemAllocType (pctxt, OffsetSystem);

            if (pvalue->u.path == NULL)
               return RTERR_NOMEM;

            asn1Init_OffsetSystem (pvalue->u.path);

            stat = asn1PD_OffsetSystem (pctxt, pvalue->u.path);
            if (stat != 0) return stat;

            break;

         /* geometry */
         case 1:
            pvalue->u.geometry = rtxMemAllocType (pctxt, GeometricProjection);

            if (pvalue->u.geometry == NULL)
               return RTERR_NOMEM;

            asn1Init_GeometricProjection (pvalue->u.geometry);

            stat = asn1PD_GeometricProjection (pctxt, pvalue->u.geometry);
            if (stat != 0) return stat;

            break;

         /* oldRegion */
         case 2:
            pvalue->u.oldRegion = rtxMemAllocType (pctxt, ValidRegion);

            if (pvalue->u.oldRegion == NULL)
               return RTERR_NOMEM;

            asn1Init_ValidRegion (pvalue->u.oldRegion);

            stat = asn1PD_ValidRegion (pctxt, pvalue->u.oldRegion);
            if (stat != 0) return stat;

            break;

         default:
            return RTERR_INVOPT;
      }
   }
   else {
      PU_NEWFIELD (pctxt, "choice index");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return stat;
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return RTERR_INVOPT;

      PU_SETBITCOUNT (pctxt);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return stat;

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return stat;

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return RTERR_NOMEM;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GeographicalPath_description: end\n");

   return (stat);
}

EXTERN int asn1PD_GeographicalPath_regional (OSCTXT* pctxt, GeographicalPath_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GeographicalPath_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GeographicalPath_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_GeographicalPath (OSCTXT* pctxt, GeographicalPath* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[9];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GeographicalPath: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 9; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 9; i_++) {
      switch (i_) {
         case 0:
         /* decode name */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.namePresent = 1;

            stat = asn1PD_DescriptiveName (pctxt, &pvalue->name);

         }
         break;

         case 1:
         /* decode id */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.idPresent = 1;

            stat = asn1PD_RoadSegmentReferenceID (pctxt, &pvalue->id);

         }
         break;

         case 2:
         /* decode anchor */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.anchorPresent = 1;

            stat = asn1PD_Position3D (pctxt, &pvalue->anchor);

         }
         break;

         case 3:
         /* decode laneWidth */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.laneWidthPresent = 1;

            stat = asn1PD_LaneWidth (pctxt, &pvalue->laneWidth);

         }
         break;

         case 4:
         /* decode directionality */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.directionalityPresent = 1;

            stat = asn1PD_DirectionOfUse (pctxt, &pvalue->directionality);

         }
         break;

         case 5:
         /* decode closedPath */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.closedPathPresent = 1;

            PU_NEWFIELD (pctxt, "boolean");

            stat = DEC_BIT (pctxt, &pvalue->closedPath);

            PU_SETBITCOUNT (pctxt);
         }
         break;

         case 6:
         /* decode direction */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.directionPresent = 1;

            stat = asn1PD_HeadingSlice (pctxt, &pvalue->direction);

         }
         break;

         case 7:
         /* decode description */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.descriptionPresent = 1;

            stat = asn1PD_GeographicalPath_description (pctxt, &pvalue->description);

         }
         break;

         case 8:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_GeographicalPath_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GeographicalPath: end\n");

   return (stat);
}

EXTERN int asn1PD_TravelerDataFrame_regions (OSCTXT* pctxt, TravelerDataFrame_regions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerDataFrame_regions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      GeographicalPath* pdata;
      rtxDListAllocNodeAndData (pctxt, GeographicalPath, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_GeographicalPath (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_GeographicalPath (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerDataFrame_regions: end\n");

   return (stat);
}

EXTERN int asn1PD_WorkZone_element_item (OSCTXT* pctxt, WorkZone_element_item* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_WorkZone_element_item: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* itis */
      case 0:
         stat = asn1PD_ITIScodes (pctxt, &pvalue->u.itis);
         if (stat != 0) return stat;

         break;

      /* text */
      case 1:
         stat = asn1PD_ITIStextPhrase (pctxt, &pvalue->u.text);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_WorkZone_element_item: end\n");

   return (stat);
}

EXTERN int asn1PD_WorkZone_element (OSCTXT* pctxt, WorkZone_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_WorkZone_element: start\n");

   /* decode root elements */
   /* decode item */
   stat = asn1PD_WorkZone_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_WorkZone_element: end\n");

   return (stat);
}

EXTERN int asn1PD_WorkZone (OSCTXT* pctxt, WorkZone* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_WorkZone: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      WorkZone_element* pdata;
      rtxDListAllocNodeAndData (pctxt, WorkZone_element, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_WorkZone_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_WorkZone_element (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_WorkZone: end\n");

   return (stat);
}

EXTERN int asn1PD_GenericSignage_element_item (OSCTXT* pctxt, GenericSignage_element_item* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_GenericSignage_element_item: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* itis */
      case 0:
         stat = asn1PD_ITIScodes (pctxt, &pvalue->u.itis);
         if (stat != 0) return stat;

         break;

      /* text */
      case 1:
         stat = asn1PD_ITIStextPhrase (pctxt, &pvalue->u.text);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GenericSignage_element_item: end\n");

   return (stat);
}

EXTERN int asn1PD_GenericSignage_element (OSCTXT* pctxt, GenericSignage_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GenericSignage_element: start\n");

   /* decode root elements */
   /* decode item */
   stat = asn1PD_GenericSignage_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_GenericSignage_element: end\n");

   return (stat);
}

EXTERN int asn1PD_GenericSignage (OSCTXT* pctxt, GenericSignage* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GenericSignage: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      GenericSignage_element* pdata;
      rtxDListAllocNodeAndData (pctxt, GenericSignage_element, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_GenericSignage_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_GenericSignage_element (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GenericSignage: end\n");

   return (stat);
}

EXTERN int asn1PD_SpeedLimit_element_item (OSCTXT* pctxt, SpeedLimit_element_item* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedLimit_element_item: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* itis */
      case 0:
         stat = asn1PD_ITIScodes (pctxt, &pvalue->u.itis);
         if (stat != 0) return stat;

         break;

      /* text */
      case 1:
         stat = asn1PD_ITIStextPhrase (pctxt, &pvalue->u.text);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedLimit_element_item: end\n");

   return (stat);
}

EXTERN int asn1PD_SpeedLimit_element (OSCTXT* pctxt, SpeedLimit_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedLimit_element: start\n");

   /* decode root elements */
   /* decode item */
   stat = asn1PD_SpeedLimit_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedLimit_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SpeedLimit (OSCTXT* pctxt, SpeedLimit* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedLimit: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SpeedLimit_element* pdata;
      rtxDListAllocNodeAndData (pctxt, SpeedLimit_element, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_SpeedLimit_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SpeedLimit_element (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedLimit: end\n");

   return (stat);
}

EXTERN int asn1PD_ExitService_element_item (OSCTXT* pctxt, ExitService_element_item* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_ExitService_element_item: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* itis */
      case 0:
         stat = asn1PD_ITIScodes (pctxt, &pvalue->u.itis);
         if (stat != 0) return stat;

         break;

      /* text */
      case 1:
         stat = asn1PD_ITIStextPhrase (pctxt, &pvalue->u.text);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ExitService_element_item: end\n");

   return (stat);
}

EXTERN int asn1PD_ExitService_element (OSCTXT* pctxt, ExitService_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ExitService_element: start\n");

   /* decode root elements */
   /* decode item */
   stat = asn1PD_ExitService_element_item (pctxt, &pvalue->item);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_ExitService_element: end\n");

   return (stat);
}

EXTERN int asn1PD_ExitService (OSCTXT* pctxt, ExitService* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ExitService: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ExitService_element* pdata;
      rtxDListAllocNodeAndData (pctxt, ExitService_element, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_ExitService_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ExitService_element (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ExitService: end\n");

   return (stat);
}

EXTERN int asn1PD_TravelerDataFrame_content (OSCTXT* pctxt, TravelerDataFrame_content* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerDataFrame_content: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   stat = rtxDecBits (pctxt, &ui, 3);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* advisory */
      case 0:
         pvalue->u.advisory = rtxMemAllocType (pctxt, ITIScodesAndText);

         if (pvalue->u.advisory == NULL)
            return RTERR_NOMEM;

         asn1Init_ITIScodesAndText (pvalue->u.advisory);

         stat = asn1PD_ITIScodesAndText (pctxt, pvalue->u.advisory);
         if (stat != 0) return stat;

         break;

      /* workZone */
      case 1:
         pvalue->u.workZone = rtxMemAllocType (pctxt, WorkZone);

         if (pvalue->u.workZone == NULL)
            return RTERR_NOMEM;

         asn1Init_WorkZone (pvalue->u.workZone);

         stat = asn1PD_WorkZone (pctxt, pvalue->u.workZone);
         if (stat != 0) return stat;

         break;

      /* genericSign */
      case 2:
         pvalue->u.genericSign = rtxMemAllocType (pctxt, GenericSignage);

         if (pvalue->u.genericSign == NULL)
            return RTERR_NOMEM;

         asn1Init_GenericSignage (pvalue->u.genericSign);

         stat = asn1PD_GenericSignage (pctxt, pvalue->u.genericSign);
         if (stat != 0) return stat;

         break;

      /* speedLimit */
      case 3:
         pvalue->u.speedLimit = rtxMemAllocType (pctxt, SpeedLimit);

         if (pvalue->u.speedLimit == NULL)
            return RTERR_NOMEM;

         asn1Init_SpeedLimit (pvalue->u.speedLimit);

         stat = asn1PD_SpeedLimit (pctxt, pvalue->u.speedLimit);
         if (stat != 0) return stat;

         break;

      /* exitService */
      case 4:
         pvalue->u.exitService = rtxMemAllocType (pctxt, ExitService);

         if (pvalue->u.exitService == NULL)
            return RTERR_NOMEM;

         asn1Init_ExitService (pvalue->u.exitService);

         stat = asn1PD_ExitService (pctxt, pvalue->u.exitService);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerDataFrame_content: end\n");

   return (stat);
}

EXTERN int asn1PD_TravelerDataFrame (OSCTXT* pctxt, TravelerDataFrame* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerDataFrame: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode sspTimRights */
   stat = asn1PD_SSPindex (pctxt, &pvalue->sspTimRights);
   if (stat != 0) return stat;

   /* decode frameType */
   stat = asn1PD_TravelerInfoType (pctxt, &pvalue->frameType);
   if (stat != 0) return stat;

   /* decode msgId */
   stat = asn1PD_TravelerDataFrame_msgId (pctxt, &pvalue->msgId);
   if (stat != 0) return stat;

   /* decode startYear */
   if (optbits[0]) {
      pvalue->m.startYearPresent = 1;

      stat = asn1PD_DYear (pctxt, &pvalue->startYear);
      if (stat != 0) return stat;

   }

   /* decode startTime */
   stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->startTime);
   if (stat != 0) return stat;

   /* decode duratonTime */
   stat = asn1PD_MinutesDuration (pctxt, &pvalue->duratonTime);
   if (stat != 0) return stat;

   /* decode priority */
   stat = asn1PD_SignPrority (pctxt, &pvalue->priority);
   if (stat != 0) return stat;

   /* decode sspLocationRights */
   stat = asn1PD_SSPindex (pctxt, &pvalue->sspLocationRights);
   if (stat != 0) return stat;

   /* decode regions */
   stat = asn1PD_TravelerDataFrame_regions (pctxt, &pvalue->regions);
   if (stat != 0) return stat;

   /* decode sspMsgRights1 */
   stat = asn1PD_SSPindex (pctxt, &pvalue->sspMsgRights1);
   if (stat != 0) return stat;

   /* decode sspMsgRights2 */
   stat = asn1PD_SSPindex (pctxt, &pvalue->sspMsgRights2);
   if (stat != 0) return stat;

   /* decode content */
   stat = asn1PD_TravelerDataFrame_content (pctxt, &pvalue->content);
   if (stat != 0) return stat;

   /* decode url */
   if (optbits[1]) {
      pvalue->m.urlPresent = 1;

      stat = asn1PD_URL_Short (pctxt, &pvalue->url);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerDataFrame: end\n");

   return (stat);
}

EXTERN int asn1PD_TravelerDataFrameList (OSCTXT* pctxt, TravelerDataFrameList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerDataFrameList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TravelerDataFrame* pdata;
      rtxDListAllocNodeAndData (pctxt, TravelerDataFrame, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_TravelerDataFrame (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TravelerDataFrame (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerDataFrameList: end\n");

   return (stat);
}

EXTERN int asn1PD_TravelerInformation_regional (OSCTXT* pctxt, TravelerInformation_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerInformation_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerInformation_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_TravelerInformation (OSCTXT* pctxt, TravelerInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode msgCnt */
         stat = asn1PD_MsgCount (pctxt, &pvalue->msgCnt);

         break;

         case 1:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->timeStamp);

         }
         break;

         case 2:
         /* decode packetID */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.packetIDPresent = 1;

            stat = asn1PD_UniqueMSGID (pctxt, &pvalue->packetID);

         }
         break;

         case 3:
         /* decode urlB */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.urlBPresent = 1;

            stat = asn1PD_URL_Base (pctxt, &pvalue->urlB);

         }
         break;

         case 4:
         /* decode dataFrames */
         stat = asn1PD_TravelerDataFrameList (pctxt, &pvalue->dataFrames);

         break;

         case 5:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_TravelerInformation_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TravelerInformation: end\n");

   return (stat);
}

EXTERN int asn1PD_Header (OSCTXT* pctxt, Header* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Header: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode year */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.yearPresent = 1;

            stat = asn1PD_DYear (pctxt, &pvalue->year);

         }
         break;

         case 1:
         /* decode timeStamp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.timeStampPresent = 1;

            stat = asn1PD_MinuteOfTheYear (pctxt, &pvalue->timeStamp);

         }
         break;

         case 2:
         /* decode secMark */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.secMarkPresent = 1;

            stat = asn1PD_DSecond (pctxt, &pvalue->secMark);

         }
         break;

         case 3:
         /* decode msgIssueRevision */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.msgIssueRevisionPresent = 1;

            stat = asn1PD_MsgCount (pctxt, &pvalue->msgIssueRevision);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Header: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage00 (OSCTXT* pctxt, TestMessage00* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage00: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage00: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage01 (OSCTXT* pctxt, TestMessage01* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage01: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage01: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage02 (OSCTXT* pctxt, TestMessage02* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage02: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage02: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage03 (OSCTXT* pctxt, TestMessage03* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage03: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage03: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage04 (OSCTXT* pctxt, TestMessage04* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage04: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage04: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage05 (OSCTXT* pctxt, TestMessage05* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage05: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage05: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage06 (OSCTXT* pctxt, TestMessage06* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage06: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage06: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage07 (OSCTXT* pctxt, TestMessage07* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage07: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage07: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage08 (OSCTXT* pctxt, TestMessage08* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage08: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage08: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage09 (OSCTXT* pctxt, TestMessage09* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage09: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage09: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage10 (OSCTXT* pctxt, TestMessage10* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage10: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage10: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage11 (OSCTXT* pctxt, TestMessage11* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage11: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage11: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage12 (OSCTXT* pctxt, TestMessage12* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage12: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage12: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage13 (OSCTXT* pctxt, TestMessage13* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage13: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage13: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage14 (OSCTXT* pctxt, TestMessage14* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage14: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage14: end\n");

   return (stat);
}

EXTERN int asn1PD_TestMessage15 (OSCTXT* pctxt, TestMessage15* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage15: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode header */
   if (optbits[0]) {
      pvalue->m.headerPresent = 1;

      stat = asn1PD_Header (pctxt, &pvalue->header);
      if (stat != 0) return stat;

   }

   /* decode regional */
   if (optbits[1]) {
      pvalue->m.regionalPresent = 1;

      stat = asn1PD_RegionalExtension (pctxt, &pvalue->regional);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TestMessage15: end\n");

   return (stat);
}

EXTERN int asn1PD_DDate (OSCTXT* pctxt, DDate* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DDate: start\n");

   /* decode root elements */
   /* decode year */
   stat = asn1PD_DYear (pctxt, &pvalue->year);
   if (stat != 0) return stat;

   /* decode month */
   stat = asn1PD_DMonth (pctxt, &pvalue->month);
   if (stat != 0) return stat;

   /* decode day */
   stat = asn1PD_DDay (pctxt, &pvalue->day);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_DDate: end\n");

   return (stat);
}

EXTERN int asn1PD_DFullTime (OSCTXT* pctxt, DFullTime* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DFullTime: start\n");

   /* decode root elements */
   /* decode year */
   stat = asn1PD_DYear (pctxt, &pvalue->year);
   if (stat != 0) return stat;

   /* decode month */
   stat = asn1PD_DMonth (pctxt, &pvalue->month);
   if (stat != 0) return stat;

   /* decode day */
   stat = asn1PD_DDay (pctxt, &pvalue->day);
   if (stat != 0) return stat;

   /* decode hour */
   stat = asn1PD_DHour (pctxt, &pvalue->hour);
   if (stat != 0) return stat;

   /* decode minute */
   stat = asn1PD_DMinute (pctxt, &pvalue->minute);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_DFullTime: end\n");

   return (stat);
}

EXTERN int asn1PD_DMonthDay (OSCTXT* pctxt, DMonthDay* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DMonthDay: start\n");

   /* decode root elements */
   /* decode month */
   stat = asn1PD_DMonth (pctxt, &pvalue->month);
   if (stat != 0) return stat;

   /* decode day */
   stat = asn1PD_DDay (pctxt, &pvalue->day);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_DMonthDay: end\n");

   return (stat);
}

EXTERN int asn1PD_DTime (OSCTXT* pctxt, DTime* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTDIAGSTRM2 (pctxt,"asn1PD_DTime: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode hour */
   stat = asn1PD_DHour (pctxt, &pvalue->hour);
   if (stat != 0) return stat;

   /* decode minute */
   stat = asn1PD_DMinute (pctxt, &pvalue->minute);
   if (stat != 0) return stat;

   /* decode second */
   stat = asn1PD_DSecond (pctxt, &pvalue->second);
   if (stat != 0) return stat;

   /* decode offset */
   if (optbits[0]) {
      pvalue->m.offsetPresent = 1;

      stat = asn1PD_DOffset (pctxt, &pvalue->offset);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DTime: end\n");

   return (stat);
}

EXTERN int asn1PD_DYearMonth (OSCTXT* pctxt, DYearMonth* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DYearMonth: start\n");

   /* decode root elements */
   /* decode year */
   stat = asn1PD_DYear (pctxt, &pvalue->year);
   if (stat != 0) return stat;

   /* decode month */
   stat = asn1PD_DMonth (pctxt, &pvalue->month);
   if (stat != 0) return stat;

   RTDIAGSTRM2 (pctxt,"asn1PD_DYearMonth: end\n");

   return (stat);
}

EXTERN int asn1PD_DisabledVehicle (OSCTXT* pctxt, DisabledVehicle* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTDIAGSTRM2 (pctxt,"asn1PD_DisabledVehicle: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode statusDetails */
   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToUInt16 (pctxt, &pvalue->statusDetails, 5);
   if (stat != 0) return stat;

   if (pvalue->statusDetails > 18){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, 541);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pvalue->statusDetails += 523;

   PU_SETBITCOUNT (pctxt);

   /* decode locationDetails */
   if (optbits[0]) {
      pvalue->m.locationDetailsPresent = 1;

      stat = asn1PD_GenericLocations (pctxt, &pvalue->locationDetails);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DisabledVehicle: end\n");

   return (stat);
}

EXTERN int asn1PD_EventDescription_description (OSCTXT* pctxt, EventDescription_description* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EventDescription_description: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 8){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_ITIScodes (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EventDescription_description: end\n");

   return (stat);
}

EXTERN int asn1PD_EventDescription_regional (OSCTXT* pctxt, EventDescription_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EventDescription_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EventDescription_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_EventDescription (OSCTXT* pctxt, EventDescription* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EventDescription: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode typeEvent */
         stat = asn1PD_ITIScodes (pctxt, &pvalue->typeEvent);

         break;

         case 1:
         /* decode description */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.descriptionPresent = 1;

            stat = asn1PD_EventDescription_description (pctxt, &pvalue->description);

         }
         break;

         case 2:
         /* decode priority */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.priorityPresent = 1;

            stat = asn1PD_Priority (pctxt, &pvalue->priority);

         }
         break;

         case 3:
         /* decode heading */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.headingPresent = 1;

            stat = asn1PD_HeadingSlice (pctxt, &pvalue->heading);

         }
         break;

         case 4:
         /* decode extent */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.extentPresent = 1;

            stat = asn1PD_Extent (pctxt, &pvalue->extent);

         }
         break;

         case 5:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_EventDescription_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EventDescription: end\n");

   return (stat);
}

EXTERN int asn1PD_ObstacleDetection (OSCTXT* pctxt, ObstacleDetection* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ObstacleDetection: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode obDist */
         stat = asn1PD_ObstacleDistance (pctxt, &pvalue->obDist);

         break;

         case 1:
         /* decode obDirect */
         stat = asn1PD_ObstacleDirection (pctxt, &pvalue->obDirect);

         break;

         case 2:
         /* decode description */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.descriptionPresent = 1;

            PU_NEWFIELD (pctxt, "constrainted int");

            stat = rtxDecBitsToUInt16 (pctxt, &pvalue->description, 5);

            if (pvalue->description > 18){
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddUIntParm (pctxt, 541);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            pvalue->description += 523;

            PU_SETBITCOUNT (pctxt);

         }
         break;

         case 3:
         /* decode locationDetails */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.locationDetailsPresent = 1;

            stat = asn1PD_GenericLocations (pctxt, &pvalue->locationDetails);

         }
         break;

         case 4:
         /* decode dateTime */
         stat = asn1PD_DDateTime (pctxt, &pvalue->dateTime);

         break;

         case 5:
         /* decode vertEvent */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.vertEventPresent = 1;

            stat = asn1PD_VerticalAccelerationThreshold (pctxt, &pvalue->vertEvent);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ObstacleDetection: end\n");

   return (stat);
}

EXTERN int asn1PD_PivotPointDescription (OSCTXT* pctxt, PivotPointDescription* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_PivotPointDescription: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode pivotOffset */
   stat = asn1PD_Offset_B11 (pctxt, &pvalue->pivotOffset);
   if (stat != 0) return stat;

   /* decode pivotAngle */
   stat = asn1PD_Angle (pctxt, &pvalue->pivotAngle);
   if (stat != 0) return stat;

   /* decode pivots */
   stat = asn1PD_PivotingAllowed (pctxt, &pvalue->pivots);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PivotPointDescription: end\n");

   return (stat);
}

EXTERN int asn1PD_RTCMPackage (OSCTXT* pctxt, RTCMPackage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTDIAGSTRM2 (pctxt,"asn1PD_RTCMPackage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode rtcmHeader */
   if (optbits[0]) {
      pvalue->m.rtcmHeaderPresent = 1;

      stat = asn1PD_RTCMheader (pctxt, &pvalue->rtcmHeader);
      if (stat != 0) return stat;

   }

   /* decode msgs */
   stat = asn1PD_RTCMmessageList (pctxt, &pvalue->msgs);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RTCMPackage: end\n");

   return (stat);
}

EXTERN int asn1PD_TrailerHistoryPoint (OSCTXT* pctxt, TrailerHistoryPoint* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTDIAGSTRM2 (pctxt,"asn1PD_TrailerHistoryPoint: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pivotAngle */
   stat = asn1PD_Angle (pctxt, &pvalue->pivotAngle);
   if (stat != 0) return stat;

   /* decode timeOffset */
   stat = asn1PD_TimeOffset (pctxt, &pvalue->timeOffset);
   if (stat != 0) return stat;

   /* decode positionOffset */
   stat = asn1PD_Node_XY_24b (pctxt, &pvalue->positionOffset);
   if (stat != 0) return stat;

   /* decode elevationOffset */
   if (optbits[0]) {
      pvalue->m.elevationOffsetPresent = 1;

      stat = asn1PD_VertOffset_B07 (pctxt, &pvalue->elevationOffset);
      if (stat != 0) return stat;

   }

   /* decode heading */
   if (optbits[1]) {
      pvalue->m.headingPresent = 1;

      stat = asn1PD_CoarseHeading (pctxt, &pvalue->heading);
      if (stat != 0) return stat;

   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TrailerHistoryPoint: end\n");

   return (stat);
}

EXTERN int asn1PD_TrailerHistoryPointList (OSCTXT* pctxt, TrailerHistoryPointList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TrailerHistoryPointList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(23), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TrailerHistoryPoint* pdata;
      rtxDListAllocNodeAndData (pctxt, TrailerHistoryPoint, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_TrailerHistoryPoint (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TrailerHistoryPoint (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TrailerHistoryPointList: end\n");

   return (stat);
}

EXTERN int asn1PD_TrailerUnitDescription (OSCTXT* pctxt, TrailerUnitDescription* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[8];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TrailerUnitDescription: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 8; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 13; i_++) {
      switch (i_) {
         case 0:
         /* decode isDolly */
         stat = asn1PD_IsDolly (pctxt, &pvalue->isDolly);

         break;

         case 1:
         /* decode width */
         stat = asn1PD_VehicleWidth (pctxt, &pvalue->width);

         break;

         case 2:
         /* decode length */
         stat = asn1PD_VehicleLength (pctxt, &pvalue->length);

         break;

         case 3:
         /* decode height */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.heightPresent = 1;

            stat = asn1PD_VehicleHeight (pctxt, &pvalue->height);

         }
         break;

         case 4:
         /* decode mass */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.massPresent = 1;

            stat = asn1PD_TrailerMass (pctxt, &pvalue->mass);

         }
         break;

         case 5:
         /* decode bumperHeights */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.bumperHeightsPresent = 1;

            stat = asn1PD_BumperHeights (pctxt, &pvalue->bumperHeights);

         }
         break;

         case 6:
         /* decode centerOfGravity */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.centerOfGravityPresent = 1;

            stat = asn1PD_VehicleHeight (pctxt, &pvalue->centerOfGravity);

         }
         break;

         case 7:
         /* decode frontPivot */
         stat = asn1PD_PivotPointDescription (pctxt, &pvalue->frontPivot);

         break;

         case 8:
         /* decode rearPivot */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.rearPivotPresent = 1;

            stat = asn1PD_PivotPointDescription (pctxt, &pvalue->rearPivot);

         }
         break;

         case 9:
         /* decode rearWheelOffset */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.rearWheelOffsetPresent = 1;

            stat = asn1PD_Offset_B12 (pctxt, &pvalue->rearWheelOffset);

         }
         break;

         case 10:
         /* decode positionOffset */
         stat = asn1PD_Node_XY_24b (pctxt, &pvalue->positionOffset);

         break;

         case 11:
         /* decode elevationOffset */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.elevationOffsetPresent = 1;

            stat = asn1PD_VertOffset_B07 (pctxt, &pvalue->elevationOffset);

         }
         break;

         case 12:
         /* decode crumbData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.crumbDataPresent = 1;

            stat = asn1PD_TrailerHistoryPointList (pctxt, &pvalue->crumbData);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TrailerUnitDescription: end\n");

   return (stat);
}

EXTERN int asn1PD_TrailerUnitDescriptionList (OSCTXT* pctxt, TrailerUnitDescriptionList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TrailerUnitDescriptionList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TrailerUnitDescription* pdata;
      rtxDListAllocNodeAndData (pctxt, TrailerUnitDescription, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_TrailerUnitDescription (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TrailerUnitDescription (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TrailerUnitDescriptionList: end\n");

   return (stat);
}

EXTERN int asn1PD_TrailerData (OSCTXT* pctxt, TrailerData* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_TrailerData: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode sspRights */
   stat = asn1PD_SSPindex (pctxt, &pvalue->sspRights);
   if (stat != 0) return stat;

   /* decode connection */
   stat = asn1PD_PivotPointDescription (pctxt, &pvalue->connection);
   if (stat != 0) return stat;

   /* decode units */
   stat = asn1PD_TrailerUnitDescriptionList (pctxt, &pvalue->units);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TrailerData: end\n");

   return (stat);
}

EXTERN int asn1PD_SpecialVehicleExtensions (OSCTXT* pctxt, SpecialVehicleExtensions* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SpecialVehicleExtensions: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 3; i_++) {
      switch (i_) {
         case 0:
         /* decode vehicleAlerts */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.vehicleAlertsPresent = 1;

            stat = asn1PD_EmergencyDetails (pctxt, &pvalue->vehicleAlerts);

         }
         break;

         case 1:
         /* decode description */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.descriptionPresent = 1;

            stat = asn1PD_EventDescription (pctxt, &pvalue->description);

         }
         break;

         case 2:
         /* decode trailers */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.trailersPresent = 1;

            stat = asn1PD_TrailerData (pctxt, &pvalue->trailers);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SpecialVehicleExtensions: end\n");

   return (stat);
}

EXTERN int asn1PD_SpeedProfileMeasurementList (OSCTXT* pctxt, SpeedProfileMeasurementList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedProfileMeasurementList: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 5);
   if (stat != 0) return stat;
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 20){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      stat = asn1PD_SpeedProfileMeasurement (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return stat;
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedProfileMeasurementList: end\n");

   return (stat);
}

EXTERN int asn1PD_SpeedProfile (OSCTXT* pctxt, SpeedProfile* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedProfile: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode speedReports */
   stat = asn1PD_SpeedProfileMeasurementList (pctxt, &pvalue->speedReports);
   if (stat != 0) return stat;

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SpeedProfile: end\n");

   return (stat);
}

EXTERN int asn1PD_VehicleData (OSCTXT* pctxt, VehicleData* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleData: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 4; i_++) {
      switch (i_) {
         case 0:
         /* decode height */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.heightPresent = 1;

            stat = asn1PD_VehicleHeight (pctxt, &pvalue->height);

         }
         break;

         case 1:
         /* decode bumpers */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.bumpersPresent = 1;

            stat = asn1PD_BumperHeights (pctxt, &pvalue->bumpers);

         }
         break;

         case 2:
         /* decode mass */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.massPresent = 1;

            stat = asn1PD_VehicleMass (pctxt, &pvalue->mass);

         }
         break;

         case 3:
         /* decode trailerWeight */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.trailerWeightPresent = 1;

            stat = asn1PD_TrailerWeight (pctxt, &pvalue->trailerWeight);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VehicleData: end\n");

   return (stat);
}

EXTERN int asn1PD_WeatherReport (OSCTXT* pctxt, WeatherReport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_WeatherReport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 6; i_++) {
      switch (i_) {
         case 0:
         /* decode isRaining */
         stat = asn1PD_EssPrecipYesNo (pctxt, &pvalue->isRaining);

         break;

         case 1:
         /* decode rainRate */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.rainRatePresent = 1;

            stat = asn1PD_EssPrecipRate (pctxt, &pvalue->rainRate);

         }
         break;

         case 2:
         /* decode precipSituation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.precipSituationPresent = 1;

            stat = asn1PD_EssPrecipSituation (pctxt, &pvalue->precipSituation);

         }
         break;

         case 3:
         /* decode solarRadiation */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.solarRadiationPresent = 1;

            stat = asn1PD_EssSolarRadiation (pctxt, &pvalue->solarRadiation);

         }
         break;

         case 4:
         /* decode friction */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.frictionPresent = 1;

            stat = asn1PD_EssMobileFriction (pctxt, &pvalue->friction);

         }
         break;

         case 5:
         /* decode roadFriction */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.roadFrictionPresent = 1;

            stat = asn1PD_CoefficientOfFriction (pctxt, &pvalue->roadFriction);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_WeatherReport: end\n");

   return (stat);
}

EXTERN int asn1PD_WeatherProbe (OSCTXT* pctxt, WeatherProbe* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_WeatherProbe: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 3; i_++) {
      switch (i_) {
         case 0:
         /* decode airTemp */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.airTempPresent = 1;

            stat = asn1PD_AmbientAirTemperature (pctxt, &pvalue->airTemp);

         }
         break;

         case 1:
         /* decode airPressure */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.airPressurePresent = 1;

            stat = asn1PD_AmbientAirPressure (pctxt, &pvalue->airPressure);

         }
         break;

         case 2:
         /* decode rainRates */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.rainRatesPresent = 1;

            stat = asn1PD_WiperSet (pctxt, &pvalue->rainRates);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_WeatherProbe: end\n");

   return (stat);
}

EXTERN int asn1PD_SupplementalVehicleExtensions_regional (OSCTXT* pctxt, SupplementalVehicleExtensions_regional* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SupplementalVehicleExtensions_regional: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return stat;

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RegionalExtension* pdata;
      rtxDListAllocNodeAndData (pctxt, RegionalExtension, &pnode, &pdata);

      if (pnode == NULL)
         return RTERR_NOMEM;

      asn1Init_RegionalExtension (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RegionalExtension (pctxt, pdata);
      if (stat != 0) return stat;

   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SupplementalVehicleExtensions_regional: end\n");

   return (stat);
}

EXTERN int asn1PD_SupplementalVehicleExtensions (OSCTXT* pctxt, SupplementalVehicleExtensions* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[10];
   OSUINT32 j_ = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SupplementalVehicleExtensions: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return stat;

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 10; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return stat;
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   for (i_ = 0; i_ < 10; i_++) {
      switch (i_) {
         case 0:
         /* decode classification */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.classificationPresent = 1;

            stat = asn1PD_BasicVehicleClass (pctxt, &pvalue->classification);

         }
         break;

         case 1:
         /* decode classDetails */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.classDetailsPresent = 1;

            stat = asn1PD_VehicleClassification (pctxt, &pvalue->classDetails);

         }
         break;

         case 2:
         /* decode vehicleData */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.vehicleDataPresent = 1;

            stat = asn1PD_VehicleData (pctxt, &pvalue->vehicleData);

         }
         break;

         case 3:
         /* decode weatherReport */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.weatherReportPresent = 1;

            stat = asn1PD_WeatherReport (pctxt, &pvalue->weatherReport);

         }
         break;

         case 4:
         /* decode weatherProbe */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.weatherProbePresent = 1;

            stat = asn1PD_WeatherProbe (pctxt, &pvalue->weatherProbe);

         }
         break;

         case 5:
         /* decode obstacle */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.obstaclePresent = 1;

            stat = asn1PD_ObstacleDetection (pctxt, &pvalue->obstacle);

         }
         break;

         case 6:
         /* decode status */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.statusPresent = 1;

            stat = asn1PD_DisabledVehicle (pctxt, &pvalue->status);

         }
         break;

         case 7:
         /* decode speedProfile */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.speedProfilePresent = 1;

            stat = asn1PD_SpeedProfile (pctxt, &pvalue->speedProfile);

         }
         break;

         case 8:
         /* decode theRTCM */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.theRTCMPresent = 1;

            stat = asn1PD_RTCMPackage (pctxt, &pvalue->theRTCM);

         }
         break;

         case 9:
         /* decode regional */
         if (j_ < sizeof(optbits) && optbits[j_++]) {
            pvalue->m.regionalPresent = 1;

            stat = asn1PD_SupplementalVehicleExtensions_regional (pctxt, &pvalue->regional);

         }
         break;

         default: j_++;
      }
      if (0 != stat) return stat;
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return stat;

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return RTERR_NOMEM;

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return stat;
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SupplementalVehicleExtensions: end\n");

   return (stat);
}

EXTERN int asn1PD_VerticalOffset (OSCTXT* pctxt, VerticalOffset* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTDIAGSTRM2 (pctxt,"asn1PD_VerticalOffset: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   stat = rtxDecBits (pctxt, &ui, 3);
   if (stat != 0) return stat;
   else pvalue->t = ui + 1;

   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* offset1 */
      case 0:
         stat = asn1PD_VertOffset_B07 (pctxt, &pvalue->u.offset1);
         if (stat != 0) return stat;

         break;

      /* offset2 */
      case 1:
         stat = asn1PD_VertOffset_B08 (pctxt, &pvalue->u.offset2);
         if (stat != 0) return stat;

         break;

      /* offset3 */
      case 2:
         stat = asn1PD_VertOffset_B09 (pctxt, &pvalue->u.offset3);
         if (stat != 0) return stat;

         break;

      /* offset4 */
      case 3:
         stat = asn1PD_VertOffset_B10 (pctxt, &pvalue->u.offset4);
         if (stat != 0) return stat;

         break;

      /* offset5 */
      case 4:
         stat = asn1PD_VertOffset_B11 (pctxt, &pvalue->u.offset5);
         if (stat != 0) return stat;

         break;

      /* offset6 */
      case 5:
         stat = asn1PD_VertOffset_B12 (pctxt, &pvalue->u.offset6);
         if (stat != 0) return stat;

         break;

      /* elevation */
      case 6:
         stat = asn1PD_Elevation (pctxt, &pvalue->u.elevation);
         if (stat != 0) return stat;

         break;

      /* regional */
      case 7:
         pvalue->u.regional = rtxMemAllocType (pctxt, RegionalExtension);

         if (pvalue->u.regional == NULL)
            return RTERR_NOMEM;

         asn1Init_RegionalExtension (pvalue->u.regional);

         stat = asn1PD_RegionalExtension (pctxt, pvalue->u.regional);
         if (stat != 0) return stat;

         break;

      default:
         return RTERR_INVOPT;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VerticalOffset: end\n");

   return (stat);
}

