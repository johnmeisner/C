/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.2.4, Date: 06-Mar-2019.
 */
#include "DSRC.h"
#include "rtxsrc/rtxCommon.h"

/* PartII_Id */

/* Acceleration */

/* AccelerationConfidence */

static const OSEnumItem AccelerationConfidence_ENUMTAB[] = {
   { OSUTF8("accl-000-01"), 7, 11, 7 },
   { OSUTF8("accl-000-05"), 6, 11, 6 },
   { OSUTF8("accl-000-10"), 5, 11, 5 },
   { OSUTF8("accl-001-00"), 4, 11, 4 },
   { OSUTF8("accl-005-00"), 3, 11, 3 },
   { OSUTF8("accl-010-00"), 2, 11, 2 },
   { OSUTF8("accl-100-00"), 1, 11, 1 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define AccelerationConfidence_ENUMTABSIZE 8

const OSUTF8CHAR* AccelerationConfidence_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AccelerationConfidence_ENUMTABSIZE) {
      return AccelerationConfidence_ENUMTAB
         [AccelerationConfidence_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AccelerationConfidence_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AccelerationConfidence* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return AccelerationConfidence_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int AccelerationConfidence_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, AccelerationConfidence* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      AccelerationConfidence_ENUMTAB, AccelerationConfidence_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AccelerationConfidence)
         AccelerationConfidence_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* AdvisorySpeedType */

static const OSEnumItem AdvisorySpeedType_ENUMTAB[] = {
   { OSUTF8("ecoDrive"), 2, 8, 2 },
   { OSUTF8("greenwave"), 1, 9, 1 },
   { OSUTF8("none"), 0, 4, 0 },
   { OSUTF8("transit"), 3, 7, 3 }
} ;
#define AdvisorySpeedType_ENUMTABSIZE 4

const OSUTF8CHAR* AdvisorySpeedType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AdvisorySpeedType_ENUMTABSIZE) {
      return AdvisorySpeedType_ENUMTAB
         [AdvisorySpeedType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AdvisorySpeedType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AdvisorySpeedType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return AdvisorySpeedType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int AdvisorySpeedType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, AdvisorySpeedType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, AdvisorySpeedType_ENUMTAB, 
      AdvisorySpeedType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AdvisorySpeedType)AdvisorySpeedType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* AllowedManeuvers */

int asn1Init_AllowedManeuvers (AllowedManeuvers* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* AmbientAirPressure */

/* AmbientAirTemperature */

/* Angle */

/* AnimalPropelledType */

static const OSEnumItem AnimalPropelledType_ENUMTAB[] = {
   { OSUTF8("animalDrawnCarriage"), 3, 19, 3 },
   { OSUTF8("animalMounted"), 2, 13, 2 },
   { OSUTF8("otherTypes"), 1, 10, 1 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define AnimalPropelledType_ENUMTABSIZE 4

const OSUTF8CHAR* AnimalPropelledType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AnimalPropelledType_ENUMTABSIZE) {
      return AnimalPropelledType_ENUMTAB
         [AnimalPropelledType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AnimalPropelledType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AnimalPropelledType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return AnimalPropelledType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int AnimalPropelledType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, AnimalPropelledType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, AnimalPropelledType_ENUMTAB, 
      AnimalPropelledType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AnimalPropelledType)AnimalPropelledType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* AnimalType */

static const OSEnumItem AnimalType_ENUMTAB[] = {
   { OSUTF8("farm"), 3, 4, 3 },
   { OSUTF8("pet"), 2, 3, 2 },
   { OSUTF8("serviceUse"), 1, 10, 1 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define AnimalType_ENUMTABSIZE 4

const OSUTF8CHAR* AnimalType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AnimalType_ENUMTABSIZE) {
      return AnimalType_ENUMTAB[AnimalType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AnimalType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AnimalType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return AnimalType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int AnimalType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, AnimalType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, AnimalType_ENUMTAB, 
      AnimalType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AnimalType)AnimalType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* AntiLockBrakeStatus */

static const OSEnumItem AntiLockBrakeStatus_ENUMTAB[] = {
   { OSUTF8("engaged"), 3, 7, 3 },
   { OSUTF8("off"), 1, 3, 1 },
   { OSUTF8("on"), 2, 2, 2 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define AntiLockBrakeStatus_ENUMTABSIZE 4

const OSUTF8CHAR* AntiLockBrakeStatus_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AntiLockBrakeStatus_ENUMTABSIZE) {
      return AntiLockBrakeStatus_ENUMTAB
         [AntiLockBrakeStatus_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AntiLockBrakeStatus_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AntiLockBrakeStatus* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return AntiLockBrakeStatus_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int AntiLockBrakeStatus_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, AntiLockBrakeStatus* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, AntiLockBrakeStatus_ENUMTAB, 
      AntiLockBrakeStatus_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AntiLockBrakeStatus)AntiLockBrakeStatus_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* ApproachID */

/* Attachment */

static const OSEnumItem Attachment_ENUMTAB[] = {
   { OSUTF8("bicycleTrailer"), 2, 14, 5 },
   { OSUTF8("cart"), 3, 4, 4 },
   { OSUTF8("otherWalkAssistAttachments"), 5, 26, 0 },
   { OSUTF8("pet"), 6, 3, 1 },
   { OSUTF8("stroller"), 1, 8, 6 },
   { OSUTF8("unavailable"), 0, 11, 2 },
   { OSUTF8("wheelchair"), 4, 10, 3 }
} ;
#define Attachment_ENUMTABSIZE 7

const OSUTF8CHAR* Attachment_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < Attachment_ENUMTABSIZE) {
      return Attachment_ENUMTAB[Attachment_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int Attachment_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, Attachment* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return Attachment_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int Attachment_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, Attachment* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, Attachment_ENUMTAB, 
      Attachment_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (Attachment)Attachment_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* AttachmentRadius */

/* AuxiliaryBrakeStatus */

static const OSEnumItem AuxiliaryBrakeStatus_ENUMTAB[] = {
   { OSUTF8("off"), 1, 3, 3 },
   { OSUTF8("on"), 2, 2, 0 },
   { OSUTF8("reserved"), 3, 8, 1 },
   { OSUTF8("unavailable"), 0, 11, 2 }
} ;
#define AuxiliaryBrakeStatus_ENUMTABSIZE 4

const OSUTF8CHAR* AuxiliaryBrakeStatus_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AuxiliaryBrakeStatus_ENUMTABSIZE) {
      return AuxiliaryBrakeStatus_ENUMTAB
         [AuxiliaryBrakeStatus_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AuxiliaryBrakeStatus_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AuxiliaryBrakeStatus* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return AuxiliaryBrakeStatus_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int AuxiliaryBrakeStatus_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, AuxiliaryBrakeStatus* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, AuxiliaryBrakeStatus_ENUMTAB, 
      AuxiliaryBrakeStatus_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AuxiliaryBrakeStatus)AuxiliaryBrakeStatus_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* BasicVehicleClass */

/* BasicVehicleRole */

static const OSEnumItem BasicVehicleRole_ENUMTAB[] = {
   { OSUTF8("ambulance"), 14, 9, 1 },
   { OSUTF8("basicVehicle"), 0, 12, 13 },
   { OSUTF8("cyclist"), 19, 7, 19 },
   { OSUTF8("dangerousGoods"), 3, 14, 3 },
   { OSUTF8("dot"), 15, 3, 16 },
   { OSUTF8("emergency"), 6, 9, 14 },
   { OSUTF8("fire"), 13, 4, 5 },
   { OSUTF8("military"), 22, 8, 17 },
   { OSUTF8("motorcycle"), 10, 10, 10 },
   { OSUTF8("nonMotorized"), 21, 12, 22 },
   { OSUTF8("none-unknown"), 8, 12, 8 },
   { OSUTF8("pedestrian"), 20, 10, 15 },
   { OSUTF8("police"), 12, 6, 12 },
   { OSUTF8("publicTransport"), 1, 15, 6 },
   { OSUTF8("roadRescue"), 5, 10, 0 },
   { OSUTF8("roadSideSource"), 11, 14, 4 },
   { OSUTF8("roadWork"), 4, 8, 21 },
   { OSUTF8("safetyCar"), 7, 9, 18 },
   { OSUTF8("slowMoving"), 17, 10, 20 },
   { OSUTF8("specialTransport"), 2, 16, 2 },
   { OSUTF8("stopNgo"), 18, 7, 11 },
   { OSUTF8("transit"), 16, 7, 9 },
   { OSUTF8("truck"), 9, 5, 7 }
} ;
#define BasicVehicleRole_ENUMTABSIZE 23

const OSUTF8CHAR* BasicVehicleRole_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < BasicVehicleRole_ENUMTABSIZE) {
      return BasicVehicleRole_ENUMTAB
         [BasicVehicleRole_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int BasicVehicleRole_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, BasicVehicleRole* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return BasicVehicleRole_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int BasicVehicleRole_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, BasicVehicleRole* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, BasicVehicleRole_ENUMTAB, 
      BasicVehicleRole_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (BasicVehicleRole)BasicVehicleRole_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* BrakeAppliedPressure */

static const OSEnumItem BrakeAppliedPressure_ENUMTAB[] = {
   { OSUTF8("bkLvl-10"), 10, 8, 15 },
   { OSUTF8("bkLvl-11"), 11, 8, 14 },
   { OSUTF8("bkLvl-12"), 12, 8, 5 },
   { OSUTF8("bkLvl-13"), 13, 8, 6 },
   { OSUTF8("bkLvl-14"), 14, 8, 7 },
   { OSUTF8("bkLvl-2"), 2, 7, 8 },
   { OSUTF8("bkLvl-3"), 3, 7, 9 },
   { OSUTF8("bkLvl-4"), 4, 7, 10 },
   { OSUTF8("bkLvl-5"), 5, 7, 11 },
   { OSUTF8("bkLvl-6"), 6, 7, 12 },
   { OSUTF8("bkLvl-7"), 7, 7, 0 },
   { OSUTF8("bkLvl-8"), 8, 7, 1 },
   { OSUTF8("bkLvl-9"), 9, 7, 2 },
   { OSUTF8("maxPressure"), 15, 11, 3 },
   { OSUTF8("minPressure"), 1, 11, 4 },
   { OSUTF8("unavailable"), 0, 11, 13 }
} ;
#define BrakeAppliedPressure_ENUMTABSIZE 16

const OSUTF8CHAR* BrakeAppliedPressure_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < BrakeAppliedPressure_ENUMTABSIZE) {
      return BrakeAppliedPressure_ENUMTAB
         [BrakeAppliedPressure_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int BrakeAppliedPressure_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, BrakeAppliedPressure* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return BrakeAppliedPressure_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int BrakeAppliedPressure_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, BrakeAppliedPressure* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, BrakeAppliedPressure_ENUMTAB, 
      BrakeAppliedPressure_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (BrakeAppliedPressure)BrakeAppliedPressure_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* BrakeAppliedStatus */

int asn1Init_BrakeAppliedStatus (BrakeAppliedStatus* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* BrakeBoostApplied */

static const OSEnumItem BrakeBoostApplied_ENUMTAB[] = {
   { OSUTF8("off"), 1, 3, 2 },
   { OSUTF8("on"), 2, 2, 0 },
   { OSUTF8("unavailable"), 0, 11, 1 }
} ;
#define BrakeBoostApplied_ENUMTABSIZE 3

const OSUTF8CHAR* BrakeBoostApplied_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < BrakeBoostApplied_ENUMTABSIZE) {
      return BrakeBoostApplied_ENUMTAB
         [BrakeBoostApplied_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int BrakeBoostApplied_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, BrakeBoostApplied* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return BrakeBoostApplied_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int BrakeBoostApplied_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, BrakeBoostApplied* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, BrakeBoostApplied_ENUMTAB, 
      BrakeBoostApplied_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (BrakeBoostApplied)BrakeBoostApplied_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* BumperHeight */

/* CoarseHeading */

/* CodeWord */

int asn1Init_CodeWord (CodeWord* pvalue)
{
   pvalue->numocts = 0;
   return 0;
}

/* CoefficientOfFriction */

/* Confidence */

/* Count */

/* DDay */

/* DeltaAngle */

/* DeltaTime */

/* DescriptiveName */

void asn1Free_DescriptiveName (OSCTXT *pctxt, DescriptiveName pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue);
}

/* DHour */

/* DirectionOfUse */

static const OSEnumItem DirectionOfUse_ENUMTAB[] = {
   { OSUTF8("both"), 3, 4, 3 },
   { OSUTF8("forward"), 1, 7, 1 },
   { OSUTF8("reverse"), 2, 7, 2 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define DirectionOfUse_ENUMTABSIZE 4

const OSUTF8CHAR* DirectionOfUse_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < DirectionOfUse_ENUMTABSIZE) {
      return DirectionOfUse_ENUMTAB
         [DirectionOfUse_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int DirectionOfUse_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, DirectionOfUse* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return DirectionOfUse_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int DirectionOfUse_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, DirectionOfUse* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, DirectionOfUse_ENUMTAB, 
      DirectionOfUse_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (DirectionOfUse)DirectionOfUse_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* DistanceUnits */

static const OSEnumItem DistanceUnits_ENUMTAB[] = {
   { OSUTF8("centimeter"), 0, 10, 0 },
   { OSUTF8("cm2-5"), 1, 5, 1 },
   { OSUTF8("decimeter"), 2, 9, 2 },
   { OSUTF8("foot"), 5, 4, 5 },
   { OSUTF8("kilometer"), 4, 9, 4 },
   { OSUTF8("meter"), 3, 5, 3 },
   { OSUTF8("mile"), 7, 4, 7 },
   { OSUTF8("yard"), 6, 4, 6 }
} ;
#define DistanceUnits_ENUMTABSIZE 8

const OSUTF8CHAR* DistanceUnits_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < DistanceUnits_ENUMTABSIZE) {
      return DistanceUnits_ENUMTAB[DistanceUnits_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int DistanceUnits_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, DistanceUnits* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return DistanceUnits_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int DistanceUnits_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, DistanceUnits* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, DistanceUnits_ENUMTAB, 
      DistanceUnits_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (DistanceUnits)DistanceUnits_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* DMinute */

/* DMonth */

/* DOffset */

/* DrivenLineOffsetLg */

/* DrivenLineOffsetSm */

/* DrivingWheelAngle */

/* DSecond */

/* DSRCmsgID */

/* Duration */

/* DYear */

/* ElevationConfidence */

static const OSEnumItem ElevationConfidence_ENUMTAB[] = {
   { OSUTF8("elev-000-01"), 15, 11, 15 },
   { OSUTF8("elev-000-02"), 14, 11, 14 },
   { OSUTF8("elev-000-05"), 13, 11, 13 },
   { OSUTF8("elev-000-10"), 12, 11, 12 },
   { OSUTF8("elev-000-20"), 11, 11, 11 },
   { OSUTF8("elev-000-50"), 10, 11, 10 },
   { OSUTF8("elev-001-00"), 9, 11, 9 },
   { OSUTF8("elev-002-00"), 8, 11, 8 },
   { OSUTF8("elev-005-00"), 7, 11, 7 },
   { OSUTF8("elev-010-00"), 6, 11, 6 },
   { OSUTF8("elev-020-00"), 5, 11, 5 },
   { OSUTF8("elev-050-00"), 4, 11, 4 },
   { OSUTF8("elev-100-00"), 3, 11, 3 },
   { OSUTF8("elev-200-00"), 2, 11, 2 },
   { OSUTF8("elev-500-00"), 1, 11, 1 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define ElevationConfidence_ENUMTABSIZE 16

const OSUTF8CHAR* ElevationConfidence_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ElevationConfidence_ENUMTABSIZE) {
      return ElevationConfidence_ENUMTAB
         [ElevationConfidence_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ElevationConfidence_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ElevationConfidence* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ElevationConfidence_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ElevationConfidence_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ElevationConfidence* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ElevationConfidence_ENUMTAB, 
      ElevationConfidence_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ElevationConfidence)ElevationConfidence_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* Elevation */

/* Extent */

static const OSEnumItem Extent_ENUMTAB[] = {
   { OSUTF8("forever"), 15, 7, 15 },
   { OSUTF8("useFor10000000meters"), 14, 20, 8 },
   { OSUTF8("useFor1000000meters"), 12, 19, 7 },
   { OSUTF8("useFor100000meters"), 10, 18, 14 },
   { OSUTF8("useFor10000meters"), 8, 17, 6 },
   { OSUTF8("useFor1000meters"), 6, 16, 13 },
   { OSUTF8("useFor100meters"), 4, 15, 5 },
   { OSUTF8("useFor10meters"), 2, 14, 12 },
   { OSUTF8("useFor3meters"), 1, 13, 4 },
   { OSUTF8("useFor5000000meters"), 13, 19, 11 },
   { OSUTF8("useFor500000meters"), 11, 18, 3 },
   { OSUTF8("useFor50000meters"), 9, 17, 10 },
   { OSUTF8("useFor5000meters"), 7, 16, 2 },
   { OSUTF8("useFor500meters"), 5, 15, 9 },
   { OSUTF8("useFor50meters"), 3, 14, 1 },
   { OSUTF8("useInstantlyOnly"), 0, 16, 0 }
} ;
#define Extent_ENUMTABSIZE 16

const OSUTF8CHAR* Extent_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < Extent_ENUMTABSIZE) {
      return Extent_ENUMTAB[Extent_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int Extent_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, Extent* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return Extent_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int Extent_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, Extent* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, Extent_ENUMTAB, 
      Extent_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (Extent)Extent_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* ExteriorLights */

int asn1Init_ExteriorLights (ExteriorLights* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   pvalue->extdata = 0;
   return 0;
}

/* FuelType */

/* FurtherInfoID */

int asn1Init_FurtherInfoID (FurtherInfoID* pvalue)
{
   pvalue->numocts = 0;
   return 0;
}

/* GNSSstatus */

int asn1Init_GNSSstatus (GNSSstatus* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* GrossDistance */

/* GrossSpeed */

/* HeadingConfidence */

static const OSEnumItem HeadingConfidence_ENUMTAB[] = {
   { OSUTF8("prec0-0125deg"), 7, 13, 7 },
   { OSUTF8("prec0-01deg"), 6, 11, 6 },
   { OSUTF8("prec0-05deg"), 5, 11, 5 },
   { OSUTF8("prec0-1deg"), 4, 10, 4 },
   { OSUTF8("prec01deg"), 3, 9, 3 },
   { OSUTF8("prec05deg"), 2, 9, 2 },
   { OSUTF8("prec10deg"), 1, 9, 1 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define HeadingConfidence_ENUMTABSIZE 8

const OSUTF8CHAR* HeadingConfidence_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < HeadingConfidence_ENUMTABSIZE) {
      return HeadingConfidence_ENUMTAB
         [HeadingConfidence_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int HeadingConfidence_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, HeadingConfidence* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return HeadingConfidence_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int HeadingConfidence_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, HeadingConfidence* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, HeadingConfidence_ENUMTAB, 
      HeadingConfidence_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (HeadingConfidence)HeadingConfidence_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* Heading */

/* HeadingSlice */

int asn1Init_HeadingSlice (HeadingSlice* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* IntersectionID */

/* IntersectionStatusObject */

int asn1Init_IntersectionStatusObject (IntersectionStatusObject* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* IsDolly */

/* Iso3833VehicleType */

/* ITIStextPhrase */

void asn1Free_ITIStextPhrase (OSCTXT *pctxt, ITIStextPhrase pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue);
}

/* AxleLocation */

/* AxleWeight */

/* CargoWeight */

/* DriveAxleLiftAirPressure */

/* DriveAxleLocation */

/* DriveAxleLubePressure */

/* DriveAxleTemperature */

/* SteeringAxleLubePressure */

/* SteeringAxleTemperature */

/* TireLeakageRate */

/* TireLocation */

/* TirePressureThresholdDetection */

static const OSEnumItem TirePressureThresholdDetection_ENUMTAB[] = {
   { OSUTF8("errorIndicator"), 6, 14, 2 },
   { OSUTF8("extremeUnderPressure"), 4, 20, 5 },
   { OSUTF8("noData"), 0, 6, 3 },
   { OSUTF8("noWarningPressure"), 2, 17, 7 },
   { OSUTF8("notAvailable"), 7, 12, 1 },
   { OSUTF8("overPressure"), 1, 12, 6 },
   { OSUTF8("undefined"), 5, 9, 0 },
   { OSUTF8("underPressure"), 3, 13, 4 }
} ;
#define TirePressureThresholdDetection_ENUMTABSIZE 8

const OSUTF8CHAR* TirePressureThresholdDetection_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < TirePressureThresholdDetection_ENUMTABSIZE) {
      return TirePressureThresholdDetection_ENUMTAB
         [TirePressureThresholdDetection_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int TirePressureThresholdDetection_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, TirePressureThresholdDetection* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return TirePressureThresholdDetection_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int TirePressureThresholdDetection_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      TirePressureThresholdDetection* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      TirePressureThresholdDetection_ENUMTAB, 
      TirePressureThresholdDetection_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (TirePressureThresholdDetection)
         TirePressureThresholdDetection_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* TirePressure */

/* TireTemp */

/* TrailerWeight */

/* WheelEndElectFault */

static const OSEnumItem WheelEndElectFault_ENUMTAB[] = {
   { OSUTF8("isError"), 2, 7, 3 },
   { OSUTF8("isNotDefined"), 1, 12, 1 },
   { OSUTF8("isNotSupported"), 3, 14, 0 },
   { OSUTF8("isOk"), 0, 4, 2 }
} ;
#define WheelEndElectFault_ENUMTABSIZE 4

const OSUTF8CHAR* WheelEndElectFault_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < WheelEndElectFault_ENUMTABSIZE) {
      return WheelEndElectFault_ENUMTAB
         [WheelEndElectFault_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int WheelEndElectFault_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, WheelEndElectFault* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return WheelEndElectFault_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int WheelEndElectFault_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, WheelEndElectFault* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, WheelEndElectFault_ENUMTAB, 
      WheelEndElectFault_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (WheelEndElectFault)WheelEndElectFault_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* WheelSensorStatus */

static const OSEnumItem WheelSensorStatus_ENUMTAB[] = {
   { OSUTF8("notDefined"), 2, 10, 2 },
   { OSUTF8("notSupported"), 3, 12, 3 },
   { OSUTF8("off"), 0, 3, 0 },
   { OSUTF8("on"), 1, 2, 1 }
} ;
#define WheelSensorStatus_ENUMTABSIZE 4

const OSUTF8CHAR* WheelSensorStatus_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < WheelSensorStatus_ENUMTABSIZE) {
      return WheelSensorStatus_ENUMTAB
         [WheelSensorStatus_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int WheelSensorStatus_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, WheelSensorStatus* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return WheelSensorStatus_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int WheelSensorStatus_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, WheelSensorStatus* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, WheelSensorStatus_ENUMTAB, 
      WheelSensorStatus_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (WheelSensorStatus)WheelSensorStatus_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* LaneAttributes_Barrier */

int asn1Init_LaneAttributes_Barrier (LaneAttributes_Barrier* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* LaneAttributes_Bike */

int asn1Init_LaneAttributes_Bike (LaneAttributes_Bike* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* LaneAttributes_Crosswalk */

int asn1Init_LaneAttributes_Crosswalk (LaneAttributes_Crosswalk* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* LaneAttributes_Parking */

int asn1Init_LaneAttributes_Parking (LaneAttributes_Parking* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* LaneAttributes_Sidewalk */

int asn1Init_LaneAttributes_Sidewalk (LaneAttributes_Sidewalk* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* LaneAttributes_Striping */

int asn1Init_LaneAttributes_Striping (LaneAttributes_Striping* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* LaneAttributes_TrackedVehicle */

int asn1Init_LaneAttributes_TrackedVehicle (
   LaneAttributes_TrackedVehicle* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* LaneAttributes_Vehicle */

int asn1Init_LaneAttributes_Vehicle (LaneAttributes_Vehicle* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   pvalue->extdata = 0;
   return 0;
}

/* LaneConnectionID */

/* LaneDirection */

int asn1Init_LaneDirection (LaneDirection* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* LaneID */

/* LaneSharing */

int asn1Init_LaneSharing (LaneSharing* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* LaneWidth */

/* Latitude */

/* LayerID */

/* LayerType */

static const OSEnumItem LayerType_ENUMTAB[] = {
   { OSUTF8("curveData"), 4, 9, 4 },
   { OSUTF8("generalMapData"), 2, 14, 3 },
   { OSUTF8("intersectionData"), 3, 16, 1 },
   { OSUTF8("mixedContent"), 1, 12, 2 },
   { OSUTF8("none"), 0, 4, 0 },
   { OSUTF8("parkingAreaData"), 6, 15, 6 },
   { OSUTF8("roadwaySectionData"), 5, 18, 5 },
   { OSUTF8("sharedLaneData"), 7, 14, 7 }
} ;
#define LayerType_ENUMTABSIZE 8

const OSUTF8CHAR* LayerType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < LayerType_ENUMTABSIZE) {
      return LayerType_ENUMTAB[LayerType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int LayerType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, LayerType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return LayerType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int LayerType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, LayerType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, LayerType_ENUMTAB, 
      LayerType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (LayerType)LayerType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* LightbarInUse */

static const OSEnumItem LightbarInUse_ENUMTAB[] = {
   { OSUTF8("arrowSignsActive"), 5, 16, 6 },
   { OSUTF8("freqStops"), 7, 9, 3 },
   { OSUTF8("inUse"), 2, 5, 2 },
   { OSUTF8("notInUse"), 1, 8, 7 },
   { OSUTF8("schooldBusLights"), 4, 16, 4 },
   { OSUTF8("slowMovingVehicle"), 6, 17, 0 },
   { OSUTF8("unavailable"), 0, 11, 5 },
   { OSUTF8("yellowCautionLights"), 3, 19, 1 }
} ;
#define LightbarInUse_ENUMTABSIZE 8

const OSUTF8CHAR* LightbarInUse_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < LightbarInUse_ENUMTABSIZE) {
      return LightbarInUse_ENUMTAB[LightbarInUse_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int LightbarInUse_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, LightbarInUse* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return LightbarInUse_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int LightbarInUse_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, LightbarInUse* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, LightbarInUse_ENUMTAB, 
      LightbarInUse_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (LightbarInUse)LightbarInUse_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* Longitude */

/* Location_quality */

static const OSEnumItem Location_quality_ENUMTAB[] = {
   { OSUTF8("loc-qual-bt1250m"), 6, 16, 3 },
   { OSUTF8("loc-qual-bt125m"), 4, 15, 6 },
   { OSUTF8("loc-qual-bt12m"), 2, 14, 2 },
   { OSUTF8("loc-qual-bt1m"), 0, 13, 5 },
   { OSUTF8("loc-qual-bt500m"), 5, 15, 1 },
   { OSUTF8("loc-qual-bt50m"), 3, 14, 4 },
   { OSUTF8("loc-qual-bt5m"), 1, 13, 0 },
   { OSUTF8("loc-qual-unknown"), 7, 16, 7 }
} ;
#define Location_quality_ENUMTABSIZE 8

const OSUTF8CHAR* Location_quality_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < Location_quality_ENUMTABSIZE) {
      return Location_quality_ENUMTAB
         [Location_quality_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int Location_quality_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, Location_quality* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return Location_quality_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int Location_quality_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, Location_quality* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, Location_quality_ENUMTAB, 
      Location_quality_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (Location_quality)Location_quality_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* Location_tech */

static const OSEnumItem Location_tech_ENUMTAB[] = {
   { OSUTF8("loc-tech-DGPS"), 2, 13, 9 },
   { OSUTF8("loc-tech-GNSS"), 1, 13, 1 },
   { OSUTF8("loc-tech-PPP"), 4, 12, 0 },
   { OSUTF8("loc-tech-RTK"), 3, 12, 3 },
   { OSUTF8("loc-tech-dr"), 7, 11, 2 },
   { OSUTF8("loc-tech-drDGPS"), 6, 15, 6 },
   { OSUTF8("loc-tech-drGPS"), 5, 14, 5 },
   { OSUTF8("loc-tech-fault"), 9, 14, 4 },
   { OSUTF8("loc-tech-nav"), 8, 12, 8 },
   { OSUTF8("loc-tech-unknown"), 0, 16, 7 }
} ;
#define Location_tech_ENUMTABSIZE 10

const OSUTF8CHAR* Location_tech_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < Location_tech_ENUMTABSIZE) {
      return Location_tech_ENUMTAB[Location_tech_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int Location_tech_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, Location_tech* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return Location_tech_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int Location_tech_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, Location_tech* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, Location_tech_ENUMTAB, 
      Location_tech_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (Location_tech)Location_tech_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* MergeDivergeNodeAngle */

/* MessageBLOB */

int asn1Init_MessageBLOB (MessageBLOB* pvalue)
{
   pvalue->numocts = 0;
   return 0;
}

/* MinuteOfTheYear */

/* MinutesDuration */

/* MotorizedPropelledType */

static const OSEnumItem MotorizedPropelledType_ENUMTAB[] = {
   { OSUTF8("bicycle"), 3, 7, 4 },
   { OSUTF8("otherTypes"), 1, 10, 1 },
   { OSUTF8("scooter"), 4, 7, 5 },
   { OSUTF8("selfBalancingDevice"), 5, 19, 0 },
   { OSUTF8("unavailable"), 0, 11, 2 },
   { OSUTF8("wheelChair"), 2, 10, 3 }
} ;
#define MotorizedPropelledType_ENUMTABSIZE 6

const OSUTF8CHAR* MotorizedPropelledType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MotorizedPropelledType_ENUMTABSIZE) {
      return MotorizedPropelledType_ENUMTAB
         [MotorizedPropelledType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MotorizedPropelledType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, MotorizedPropelledType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MotorizedPropelledType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MotorizedPropelledType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, MotorizedPropelledType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      MotorizedPropelledType_ENUMTAB, MotorizedPropelledType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MotorizedPropelledType)
         MotorizedPropelledType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* MovementPhaseState */

static const OSEnumItem MovementPhaseState_ENUMTAB[] = {
   { OSUTF8("caution-Conflicting-Traffic"), 9, 27, 9 },
   { OSUTF8("dark"), 1, 4, 1 },
   { OSUTF8("permissive-Movement-Allowed"), 5, 27, 8 },
   { OSUTF8("permissive-clearance"), 7, 20, 7 },
   { OSUTF8("pre-Movement"), 4, 12, 4 },
   { OSUTF8("protected-Movement-Allowed"), 6, 26, 2 },
   { OSUTF8("protected-clearance"), 8, 19, 5 },
   { OSUTF8("stop-And-Remain"), 3, 15, 3 },
   { OSUTF8("stop-Then-Proceed"), 2, 17, 6 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define MovementPhaseState_ENUMTABSIZE 10

const OSUTF8CHAR* MovementPhaseState_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MovementPhaseState_ENUMTABSIZE) {
      return MovementPhaseState_ENUMTAB
         [MovementPhaseState_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MovementPhaseState_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, MovementPhaseState* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MovementPhaseState_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MovementPhaseState_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, MovementPhaseState* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, MovementPhaseState_ENUMTAB, 
      MovementPhaseState_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MovementPhaseState)MovementPhaseState_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* MsgCount */

/* MsgCRC */

int asn1Init_MsgCRC (MsgCRC* pvalue)
{
   pvalue->numocts = 0;
   return 0;
}

/* MultiVehicleResponse */

static const OSEnumItem MultiVehicleResponse_ENUMTAB[] = {
   { OSUTF8("multiVehicle"), 2, 12, 3 },
   { OSUTF8("reserved"), 3, 8, 2 },
   { OSUTF8("singleVehicle"), 1, 13, 0 },
   { OSUTF8("unavailable"), 0, 11, 1 }
} ;
#define MultiVehicleResponse_ENUMTABSIZE 4

const OSUTF8CHAR* MultiVehicleResponse_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MultiVehicleResponse_ENUMTABSIZE) {
      return MultiVehicleResponse_ENUMTAB
         [MultiVehicleResponse_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MultiVehicleResponse_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, MultiVehicleResponse* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MultiVehicleResponse_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MultiVehicleResponse_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, MultiVehicleResponse* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, MultiVehicleResponse_ENUMTAB, 
      MultiVehicleResponse_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MultiVehicleResponse)MultiVehicleResponse_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* MUTCDCode */

static const OSEnumItem MUTCDCode_ENUMTAB[] = {
   { OSUTF8("guide"), 5, 5, 3 },
   { OSUTF8("maintenance"), 3, 11, 5 },
   { OSUTF8("motoristService"), 4, 15, 6 },
   { OSUTF8("none"), 0, 4, 1 },
   { OSUTF8("rec"), 6, 3, 2 },
   { OSUTF8("regulatory"), 1, 10, 0 },
   { OSUTF8("warning"), 2, 7, 4 }
} ;
#define MUTCDCode_ENUMTABSIZE 7

const OSUTF8CHAR* MUTCDCode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MUTCDCode_ENUMTABSIZE) {
      return MUTCDCode_ENUMTAB[MUTCDCode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MUTCDCode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, MUTCDCode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return MUTCDCode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int MUTCDCode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, MUTCDCode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, MUTCDCode_ENUMTAB, 
      MUTCDCode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MUTCDCode)MUTCDCode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* NMEA_MsgType */

/* NMEA_Payload */

int asn1Init_NMEA_Payload (NMEA_Payload* pvalue)
{
   pvalue->numocts = 0;
   return 0;
}

/* NMEA_Revision */

static const OSEnumItem NMEA_Revision_ENUMTAB[] = {
   { OSUTF8("reserved"), 1, 8, 6 },
   { OSUTF8("rev1"), 2, 4, 0 },
   { OSUTF8("rev2"), 3, 4, 1 },
   { OSUTF8("rev3"), 4, 4, 2 },
   { OSUTF8("rev4"), 5, 4, 3 },
   { OSUTF8("rev5"), 6, 4, 4 },
   { OSUTF8("unknown"), 0, 7, 5 }
} ;
#define NMEA_Revision_ENUMTABSIZE 7

const OSUTF8CHAR* NMEA_Revision_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < NMEA_Revision_ENUMTABSIZE) {
      return NMEA_Revision_ENUMTAB[NMEA_Revision_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int NMEA_Revision_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, NMEA_Revision* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return NMEA_Revision_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int NMEA_Revision_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, NMEA_Revision* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, NMEA_Revision_ENUMTAB, 
      NMEA_Revision_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (NMEA_Revision)NMEA_Revision_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* NodeAttributeLL */

static const OSEnumItem NodeAttributeLL_ENUMTAB[] = {
   { OSUTF8("closedToTraffic"), 8, 15, 7 },
   { OSUTF8("curbPresentAtStepOff"), 10, 20, 11 },
   { OSUTF8("divergePoint"), 5, 12, 8 },
   { OSUTF8("downstreamStartNode"), 7, 19, 9 },
   { OSUTF8("downstreamStopLine"), 6, 18, 6 },
   { OSUTF8("hydrantPresent"), 11, 14, 2 },
   { OSUTF8("mergePoint"), 4, 10, 4 },
   { OSUTF8("reserved"), 0, 8, 3 },
   { OSUTF8("roundedCapStyleA"), 2, 16, 0 },
   { OSUTF8("roundedCapStyleB"), 3, 16, 10 },
   { OSUTF8("safeIsland"), 9, 10, 1 },
   { OSUTF8("stopLine"), 1, 8, 5 }
} ;
#define NodeAttributeLL_ENUMTABSIZE 12

const OSUTF8CHAR* NodeAttributeLL_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < NodeAttributeLL_ENUMTABSIZE) {
      return NodeAttributeLL_ENUMTAB
         [NodeAttributeLL_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int NodeAttributeLL_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, NodeAttributeLL* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return NodeAttributeLL_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int NodeAttributeLL_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, NodeAttributeLL* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, NodeAttributeLL_ENUMTAB, 
      NodeAttributeLL_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (NodeAttributeLL)NodeAttributeLL_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* NodeAttributeXY */

static const OSEnumItem NodeAttributeXY_ENUMTAB[] = {
   { OSUTF8("closedToTraffic"), 8, 15, 7 },
   { OSUTF8("curbPresentAtStepOff"), 10, 20, 11 },
   { OSUTF8("divergePoint"), 5, 12, 8 },
   { OSUTF8("downstreamStartNode"), 7, 19, 9 },
   { OSUTF8("downstreamStopLine"), 6, 18, 6 },
   { OSUTF8("hydrantPresent"), 11, 14, 2 },
   { OSUTF8("mergePoint"), 4, 10, 4 },
   { OSUTF8("reserved"), 0, 8, 3 },
   { OSUTF8("roundedCapStyleA"), 2, 16, 0 },
   { OSUTF8("roundedCapStyleB"), 3, 16, 10 },
   { OSUTF8("safeIsland"), 9, 10, 1 },
   { OSUTF8("stopLine"), 1, 8, 5 }
} ;
#define NodeAttributeXY_ENUMTABSIZE 12

const OSUTF8CHAR* NodeAttributeXY_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < NodeAttributeXY_ENUMTABSIZE) {
      return NodeAttributeXY_ENUMTAB
         [NodeAttributeXY_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int NodeAttributeXY_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, NodeAttributeXY* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return NodeAttributeXY_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int NodeAttributeXY_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, NodeAttributeXY* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, NodeAttributeXY_ENUMTAB, 
      NodeAttributeXY_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (NodeAttributeXY)NodeAttributeXY_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* NumberOfParticipantsInCluster */

static const OSEnumItem NumberOfParticipantsInCluster_ENUMTAB[] = {
   { OSUTF8("large"), 3, 5, 3 },
   { OSUTF8("medium"), 2, 6, 2 },
   { OSUTF8("small"), 1, 5, 1 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define NumberOfParticipantsInCluster_ENUMTABSIZE 4

const OSUTF8CHAR* NumberOfParticipantsInCluster_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < NumberOfParticipantsInCluster_ENUMTABSIZE) {
      return NumberOfParticipantsInCluster_ENUMTAB
         [NumberOfParticipantsInCluster_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int NumberOfParticipantsInCluster_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, NumberOfParticipantsInCluster* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return NumberOfParticipantsInCluster_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int NumberOfParticipantsInCluster_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      NumberOfParticipantsInCluster* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      NumberOfParticipantsInCluster_ENUMTAB, 
      NumberOfParticipantsInCluster_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (NumberOfParticipantsInCluster)
         NumberOfParticipantsInCluster_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* ObjectCount */

/* ObstacleDirection */

/* ObstacleDistance */

/* Offset_B09 */

/* Offset_B10 */

/* Offset_B11 */

/* Offset_B12 */

/* Offset_B13 */

/* Offset_B14 */

/* Offset_B16 */

/* OffsetLL_B12 */

/* OffsetLL_B14 */

/* OffsetLL_B16 */

/* OffsetLL_B18 */

/* OffsetLL_B22 */

/* OffsetLL_B24 */

/* PayloadData */

int asn1Init_PayloadData (PayloadData* pvalue)
{
   pvalue->numocts = 0;
   return 0;
}

/* PedestrianBicycleDetect */

/* HumanPropelledType */

static const OSEnumItem HumanPropelledType_ENUMTAB[] = {
   { OSUTF8("onFoot"), 2, 6, 4 },
   { OSUTF8("otherTypes"), 1, 10, 1 },
   { OSUTF8("pushOrKickScooter"), 4, 17, 0 },
   { OSUTF8("skateboard"), 3, 10, 3 },
   { OSUTF8("unavailable"), 0, 11, 2 },
   { OSUTF8("wheelchair"), 5, 10, 5 }
} ;
#define HumanPropelledType_ENUMTABSIZE 6

const OSUTF8CHAR* HumanPropelledType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < HumanPropelledType_ENUMTABSIZE) {
      return HumanPropelledType_ENUMTAB
         [HumanPropelledType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int HumanPropelledType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, HumanPropelledType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return HumanPropelledType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int HumanPropelledType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, HumanPropelledType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, HumanPropelledType_ENUMTAB, 
      HumanPropelledType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (HumanPropelledType)HumanPropelledType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* PersonalAssistive */

int asn1Init_PersonalAssistive (PersonalAssistive* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   pvalue->extdata = 0;
   return 0;
}

/* PersonalClusterRadius */

/* PersonalCrossingInProgress */

/* PersonalCrossingRequest */

/* PersonalDeviceUsageState */

int asn1Init_PersonalDeviceUsageState (PersonalDeviceUsageState* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   pvalue->extdata = 0;
   return 0;
}

/* PersonalDeviceUserType */

static const OSEnumItem PersonalDeviceUserType_ENUMTAB[] = {
   { OSUTF8("aPEDALCYCLIST"), 2, 13, 4 },
   { OSUTF8("aPEDESTRIAN"), 1, 11, 1 },
   { OSUTF8("aPUBLICSAFETYWORKER"), 3, 19, 0 },
   { OSUTF8("anANIMAL"), 4, 8, 2 },
   { OSUTF8("unavailable"), 0, 11, 3 }
} ;
#define PersonalDeviceUserType_ENUMTABSIZE 5

const OSUTF8CHAR* PersonalDeviceUserType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PersonalDeviceUserType_ENUMTABSIZE) {
      return PersonalDeviceUserType_ENUMTAB
         [PersonalDeviceUserType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PersonalDeviceUserType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PersonalDeviceUserType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PersonalDeviceUserType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PersonalDeviceUserType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, PersonalDeviceUserType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PersonalDeviceUserType_ENUMTAB, PersonalDeviceUserType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PersonalDeviceUserType)
         PersonalDeviceUserType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* PivotingAllowed */

/* PositionConfidence */

static const OSEnumItem PositionConfidence_ENUMTAB[] = {
   { OSUTF8("a100m"), 3, 5, 15 },
   { OSUTF8("a10cm"), 12, 5, 10 },
   { OSUTF8("a10m"), 6, 4, 5 },
   { OSUTF8("a1cm"), 15, 4, 0 },
   { OSUTF8("a1m"), 9, 3, 12 },
   { OSUTF8("a200m"), 2, 5, 7 },
   { OSUTF8("a20cm"), 11, 5, 2 },
   { OSUTF8("a20m"), 5, 4, 14 },
   { OSUTF8("a2cm"), 14, 4, 9 },
   { OSUTF8("a2m"), 8, 3, 4 },
   { OSUTF8("a500m"), 1, 5, 11 },
   { OSUTF8("a50cm"), 10, 5, 6 },
   { OSUTF8("a50m"), 4, 4, 1 },
   { OSUTF8("a5cm"), 13, 4, 13 },
   { OSUTF8("a5m"), 7, 3, 8 },
   { OSUTF8("unavailable"), 0, 11, 3 }
} ;
#define PositionConfidence_ENUMTABSIZE 16

const OSUTF8CHAR* PositionConfidence_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PositionConfidence_ENUMTABSIZE) {
      return PositionConfidence_ENUMTAB
         [PositionConfidence_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PositionConfidence_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PositionConfidence* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PositionConfidence_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PositionConfidence_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, PositionConfidence* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, PositionConfidence_ENUMTAB, 
      PositionConfidence_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PositionConfidence)PositionConfidence_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* PrioritizationResponseStatus */

static const OSEnumItem PrioritizationResponseStatus_ENUMTAB[] = {
   { OSUTF8("granted"), 4, 7, 6 },
   { OSUTF8("maxPresence"), 6, 11, 4 },
   { OSUTF8("processing"), 2, 10, 2 },
   { OSUTF8("rejected"), 5, 8, 7 },
   { OSUTF8("requested"), 1, 9, 0 },
   { OSUTF8("reserviceLocked"), 7, 15, 3 },
   { OSUTF8("unknown"), 0, 7, 1 },
   { OSUTF8("watchOtherTraffic"), 3, 17, 5 }
} ;
#define PrioritizationResponseStatus_ENUMTABSIZE 8

const OSUTF8CHAR* PrioritizationResponseStatus_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PrioritizationResponseStatus_ENUMTABSIZE) {
      return PrioritizationResponseStatus_ENUMTAB
         [PrioritizationResponseStatus_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PrioritizationResponseStatus_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PrioritizationResponseStatus* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PrioritizationResponseStatus_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PrioritizationResponseStatus_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      PrioritizationResponseStatus* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PrioritizationResponseStatus_ENUMTAB, 
      PrioritizationResponseStatus_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PrioritizationResponseStatus)
         PrioritizationResponseStatus_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* Priority */

int asn1Init_Priority (Priority* pvalue)
{
   pvalue->numocts = 0;
   return 0;
}

/* PriorityRequestType */

static const OSEnumItem PriorityRequestType_ENUMTAB[] = {
   { OSUTF8("priorityCancellation"), 3, 20, 2 },
   { OSUTF8("priorityRequest"), 1, 15, 1 },
   { OSUTF8("priorityRequestTypeReserved"), 0, 27, 3 },
   { OSUTF8("priorityRequestUpdate"), 2, 21, 0 }
} ;
#define PriorityRequestType_ENUMTABSIZE 4

const OSUTF8CHAR* PriorityRequestType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PriorityRequestType_ENUMTABSIZE) {
      return PriorityRequestType_ENUMTAB
         [PriorityRequestType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PriorityRequestType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PriorityRequestType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PriorityRequestType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PriorityRequestType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, PriorityRequestType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, PriorityRequestType_ENUMTAB, 
      PriorityRequestType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PriorityRequestType)PriorityRequestType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* PrivilegedEventFlags */

int asn1Init_PrivilegedEventFlags (PrivilegedEventFlags* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* ProbeSegmentNumber */

/* PublicSafetyAndRoadWorkerActivity */

int asn1Init_PublicSafetyAndRoadWorkerActivity (
   PublicSafetyAndRoadWorkerActivity* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   pvalue->extdata = 0;
   return 0;
}

/* PublicSafetyDirectingTrafficSubType */

int asn1Init_PublicSafetyDirectingTrafficSubType (
   PublicSafetyDirectingTrafficSubType* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   pvalue->extdata = 0;
   return 0;
}

/* PublicSafetyEventResponderWorkerType */

static const OSEnumItem PublicSafetyEventResponderWorkerType_ENUMTAB[] = {
   { OSUTF8("aDOTWorker"), 3, 10, 7 },
   { OSUTF8("animalControlWorker"), 6, 19, 6 },
   { OSUTF8("fireAndEMSWorker"), 2, 16, 2 },
   { OSUTF8("hazmatResponder"), 5, 15, 0 },
   { OSUTF8("lawEnforcement"), 4, 14, 4 },
   { OSUTF8("otherPersonnel"), 7, 14, 3 },
   { OSUTF8("towOperater"), 1, 11, 1 },
   { OSUTF8("unavailable"), 0, 11, 5 }
} ;
#define PublicSafetyEventResponderWorkerType_ENUMTABSIZE 8

const OSUTF8CHAR* PublicSafetyEventResponderWorkerType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < PublicSafetyEventResponderWorkerType_ENUMTABSIZE) {
      return PublicSafetyEventResponderWorkerType_ENUMTAB
         [PublicSafetyEventResponderWorkerType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int PublicSafetyEventResponderWorkerType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, PublicSafetyEventResponderWorkerType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return PublicSafetyEventResponderWorkerType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int PublicSafetyEventResponderWorkerType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      PublicSafetyEventResponderWorkerType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      PublicSafetyEventResponderWorkerType_ENUMTAB, 
      PublicSafetyEventResponderWorkerType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (PublicSafetyEventResponderWorkerType)
         PublicSafetyEventResponderWorkerType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* RadiusOfCurvature */

/* Radius_B12 */

/* RainSensor */

static const OSEnumItem RainSensor_ENUMTAB[] = {
   { OSUTF8("heavyDownpour"), 7, 13, 6 },
   { OSUTF8("heavyMist"), 2, 9, 3 },
   { OSUTF8("heavyRain"), 6, 9, 1 },
   { OSUTF8("lightMist"), 1, 9, 4 },
   { OSUTF8("lightRainOrDrizzle"), 3, 18, 7 },
   { OSUTF8("moderateRain"), 5, 12, 5 },
   { OSUTF8("none"), 0, 4, 2 },
   { OSUTF8("rain"), 4, 4, 0 }
} ;
#define RainSensor_ENUMTABSIZE 8

const OSUTF8CHAR* RainSensor_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RainSensor_ENUMTABSIZE) {
      return RainSensor_ENUMTAB[RainSensor_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RainSensor_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, RainSensor* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RainSensor_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RainSensor_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, RainSensor* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, RainSensor_ENUMTAB, 
      RainSensor_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RainSensor)RainSensor_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* RegionId */

/* RequestedItem */

static const OSEnumItem RequestedItem_ENUMTAB[] = {
   { OSUTF8("itemA"), 1, 5, 16 },
   { OSUTF8("itemB"), 2, 5, 0 },
   { OSUTF8("itemC"), 3, 5, 1 },
   { OSUTF8("itemD"), 4, 5, 2 },
   { OSUTF8("itemE"), 5, 5, 3 },
   { OSUTF8("itemF"), 6, 5, 4 },
   { OSUTF8("itemG"), 7, 5, 5 },
   { OSUTF8("itemI"), 8, 5, 6 },
   { OSUTF8("itemJ"), 9, 5, 7 },
   { OSUTF8("itemK"), 10, 5, 8 },
   { OSUTF8("itemL"), 11, 5, 9 },
   { OSUTF8("itemM"), 12, 5, 10 },
   { OSUTF8("itemN"), 13, 5, 11 },
   { OSUTF8("itemO"), 14, 5, 12 },
   { OSUTF8("itemP"), 15, 5, 13 },
   { OSUTF8("itemQ"), 16, 5, 14 },
   { OSUTF8("reserved"), 0, 8, 15 }
} ;
#define RequestedItem_ENUMTABSIZE 17

const OSUTF8CHAR* RequestedItem_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RequestedItem_ENUMTABSIZE) {
      return RequestedItem_ENUMTAB[RequestedItem_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RequestedItem_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, RequestedItem* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RequestedItem_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RequestedItem_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, RequestedItem* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, RequestedItem_ENUMTAB, 
      RequestedItem_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RequestedItem)RequestedItem_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* RequestID */

/* RequestImportanceLevel */

static const OSEnumItem RequestImportanceLevel_ENUMTAB[] = {
   { OSUTF8("requestImportanceLevel1"), 1, 23, 14 },
   { OSUTF8("requestImportanceLevel10"), 10, 24, 0 },
   { OSUTF8("requestImportanceLevel11"), 11, 24, 6 },
   { OSUTF8("requestImportanceLevel12"), 12, 24, 7 },
   { OSUTF8("requestImportanceLevel13"), 13, 24, 8 },
   { OSUTF8("requestImportanceLevel14"), 14, 24, 9 },
   { OSUTF8("requestImportanceLevel2"), 2, 23, 10 },
   { OSUTF8("requestImportanceLevel3"), 3, 23, 11 },
   { OSUTF8("requestImportanceLevel4"), 4, 23, 12 },
   { OSUTF8("requestImportanceLevel5"), 5, 23, 13 },
   { OSUTF8("requestImportanceLevel6"), 6, 23, 1 },
   { OSUTF8("requestImportanceLevel7"), 7, 23, 2 },
   { OSUTF8("requestImportanceLevel8"), 8, 23, 3 },
   { OSUTF8("requestImportanceLevel9"), 9, 23, 4 },
   { OSUTF8("requestImportanceLevelUnKnown"), 0, 29, 5 },
   { OSUTF8("requestImportanceReserved"), 15, 25, 15 }
} ;
#define RequestImportanceLevel_ENUMTABSIZE 16

const OSUTF8CHAR* RequestImportanceLevel_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RequestImportanceLevel_ENUMTABSIZE) {
      return RequestImportanceLevel_ENUMTAB
         [RequestImportanceLevel_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RequestImportanceLevel_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, RequestImportanceLevel* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RequestImportanceLevel_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RequestImportanceLevel_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, RequestImportanceLevel* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      RequestImportanceLevel_ENUMTAB, RequestImportanceLevel_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RequestImportanceLevel)
         RequestImportanceLevel_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* RequestSubRole */

static const OSEnumItem RequestSubRole_ENUMTAB[] = {
   { OSUTF8("requestSubRole1"), 1, 15, 15 },
   { OSUTF8("requestSubRole10"), 10, 16, 0 },
   { OSUTF8("requestSubRole11"), 11, 16, 6 },
   { OSUTF8("requestSubRole12"), 12, 16, 7 },
   { OSUTF8("requestSubRole13"), 13, 16, 8 },
   { OSUTF8("requestSubRole14"), 14, 16, 9 },
   { OSUTF8("requestSubRole2"), 2, 15, 10 },
   { OSUTF8("requestSubRole3"), 3, 15, 11 },
   { OSUTF8("requestSubRole4"), 4, 15, 12 },
   { OSUTF8("requestSubRole5"), 5, 15, 13 },
   { OSUTF8("requestSubRole6"), 6, 15, 1 },
   { OSUTF8("requestSubRole7"), 7, 15, 2 },
   { OSUTF8("requestSubRole8"), 8, 15, 3 },
   { OSUTF8("requestSubRole9"), 9, 15, 4 },
   { OSUTF8("requestSubRoleReserved"), 15, 22, 5 },
   { OSUTF8("requestSubRoleUnKnown"), 0, 21, 14 }
} ;
#define RequestSubRole_ENUMTABSIZE 16

const OSUTF8CHAR* RequestSubRole_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RequestSubRole_ENUMTABSIZE) {
      return RequestSubRole_ENUMTAB
         [RequestSubRole_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RequestSubRole_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, RequestSubRole* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RequestSubRole_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RequestSubRole_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, RequestSubRole* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, RequestSubRole_ENUMTAB, 
      RequestSubRole_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RequestSubRole)RequestSubRole_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* ResponseType */

static const OSEnumItem ResponseType_ENUMTAB[] = {
   { OSUTF8("emergency"), 1, 9, 2 },
   { OSUTF8("nonEmergency"), 2, 12, 0 },
   { OSUTF8("notInUseOrNotEquipped"), 0, 21, 1 },
   { OSUTF8("pursuit"), 3, 7, 3 },
   { OSUTF8("slowMoving"), 5, 10, 5 },
   { OSUTF8("stationary"), 4, 10, 4 },
   { OSUTF8("stopAndGoMovement"), 6, 17, 6 }
} ;
#define ResponseType_ENUMTABSIZE 7

const OSUTF8CHAR* ResponseType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ResponseType_ENUMTABSIZE) {
      return ResponseType_ENUMTAB[ResponseType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ResponseType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ResponseType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ResponseType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ResponseType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ResponseType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ResponseType_ENUMTAB, 
      ResponseType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ResponseType)ResponseType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* RestrictionAppliesTo */

static const OSEnumItem RestrictionAppliesTo_ENUMTAB[] = {
   { OSUTF8("audioDisabilities"), 12, 17, 7 },
   { OSUTF8("emissionCompliant"), 4, 17, 5 },
   { OSUTF8("equippedBicycle"), 5, 15, 4 },
   { OSUTF8("equippedOther"), 3, 13, 3 },
   { OSUTF8("equippedTaxis"), 2, 13, 1 },
   { OSUTF8("equippedTransit"), 1, 15, 2 },
   { OSUTF8("heightCompliant"), 7, 15, 12 },
   { OSUTF8("none"), 0, 4, 6 },
   { OSUTF8("otherUnknownDisabilities"), 13, 24, 9 },
   { OSUTF8("pedestrians"), 8, 11, 10 },
   { OSUTF8("slowMovingPersons"), 9, 17, 13 },
   { OSUTF8("visualDisabilities"), 11, 18, 11 },
   { OSUTF8("weightCompliant"), 6, 15, 0 },
   { OSUTF8("wheelchairUsers"), 10, 15, 8 }
} ;
#define RestrictionAppliesTo_ENUMTABSIZE 14

const OSUTF8CHAR* RestrictionAppliesTo_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RestrictionAppliesTo_ENUMTABSIZE) {
      return RestrictionAppliesTo_ENUMTAB
         [RestrictionAppliesTo_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RestrictionAppliesTo_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, RestrictionAppliesTo* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RestrictionAppliesTo_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RestrictionAppliesTo_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, RestrictionAppliesTo* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, RestrictionAppliesTo_ENUMTAB, 
      RestrictionAppliesTo_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RestrictionAppliesTo)RestrictionAppliesTo_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* RestrictionClassID */

/* RoadRegulatorID */

/* RoadSegmentID */

/* RoadwayCrownAngle */

/* RTCM_Revision */

static const OSEnumItem RTCM_Revision_ENUMTAB[] = {
   { OSUTF8("reserved"), 3, 8, 3 },
   { OSUTF8("rtcmRev2"), 1, 8, 1 },
   { OSUTF8("rtcmRev3"), 2, 8, 2 },
   { OSUTF8("unknown"), 0, 7, 0 }
} ;
#define RTCM_Revision_ENUMTABSIZE 4

const OSUTF8CHAR* RTCM_Revision_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < RTCM_Revision_ENUMTABSIZE) {
      return RTCM_Revision_ENUMTAB[RTCM_Revision_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int RTCM_Revision_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, RTCM_Revision* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return RTCM_Revision_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int RTCM_Revision_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, RTCM_Revision* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, RTCM_Revision_ENUMTAB, 
      RTCM_Revision_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (RTCM_Revision)RTCM_Revision_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* RTCMmessage */

int asn1Init_RTCMmessage (RTCMmessage* pvalue)
{
   pvalue->numocts = 0;
   return 0;
}

/* Scale_B12 */

/* SecondOfTime */

/* SegmentAttributeLL */

static const OSEnumItem SegmentAttributeLL_ENUMTAB[] = {
   { OSUTF8("adaptiveTimingPresent"), 25, 21, 21 },
   { OSUTF8("adjacentBikeLaneOnLeft"), 13, 22, 10 },
   { OSUTF8("adjacentBikeLaneOnRight"), 14, 23, 37 },
   { OSUTF8("adjacentParkingOnLeft"), 11, 21, 16 },
   { OSUTF8("adjacentParkingOnRight"), 12, 22, 17 },
   { OSUTF8("audibleSignalingPresent"), 24, 23, 8 },
   { OSUTF8("bikeBoxInFront"), 16, 14, 9 },
   { OSUTF8("costToPark"), 35, 10, 13 },
   { OSUTF8("curbOnLeft"), 5, 10, 14 },
   { OSUTF8("curbOnRight"), 6, 11, 34 },
   { OSUTF8("doNotBlock"), 1, 10, 35 },
   { OSUTF8("freeParking"), 33, 11, 3 },
   { OSUTF8("headInParking"), 32, 13, 4 },
   { OSUTF8("loadingzoneOnLeft"), 7, 17, 1 },
   { OSUTF8("loadingzoneOnRight"), 8, 18, 2 },
   { OSUTF8("lowCurbsPresent"), 22, 15, 25 },
   { OSUTF8("mergingLaneLeft"), 3, 15, 6 },
   { OSUTF8("mergingLaneRight"), 4, 16, 32 },
   { OSUTF8("midBlockCurbPresent"), 36, 19, 33 },
   { OSUTF8("parallelParking"), 31, 15, 31 },
   { OSUTF8("partialCurbIntrusion"), 27, 20, 26 },
   { OSUTF8("reserved"), 0, 8, 24 },
   { OSUTF8("rfSignalRequestPresent"), 26, 22, 15 },
   { OSUTF8("rumbleStripPresent"), 23, 18, 23 },
   { OSUTF8("safeIsland"), 21, 10, 5 },
   { OSUTF8("sharedBikeLane"), 15, 14, 0 },
   { OSUTF8("sharedWithTrackedVehicle"), 20, 24, 22 },
   { OSUTF8("taperToCenterLine"), 30, 17, 20 },
   { OSUTF8("taperToLeft"), 28, 11, 28 },
   { OSUTF8("taperToRight"), 29, 12, 29 },
   { OSUTF8("timeRestrictionsOnParking"), 34, 25, 27 },
   { OSUTF8("transitStopInLane"), 19, 17, 19 },
   { OSUTF8("transitStopOnLeft"), 17, 17, 12 },
   { OSUTF8("transitStopOnRight"), 18, 18, 11 },
   { OSUTF8("turnOutPointOnLeft"), 9, 18, 30 },
   { OSUTF8("turnOutPointOnRight"), 10, 19, 7 },
   { OSUTF8("unEvenPavementPresent"), 37, 21, 18 },
   { OSUTF8("whiteLine"), 2, 9, 36 }
} ;
#define SegmentAttributeLL_ENUMTABSIZE 38

const OSUTF8CHAR* SegmentAttributeLL_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SegmentAttributeLL_ENUMTABSIZE) {
      return SegmentAttributeLL_ENUMTAB
         [SegmentAttributeLL_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SegmentAttributeLL_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SegmentAttributeLL* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SegmentAttributeLL_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SegmentAttributeLL_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, SegmentAttributeLL* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, SegmentAttributeLL_ENUMTAB, 
      SegmentAttributeLL_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SegmentAttributeLL)SegmentAttributeLL_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* SegmentAttributeXY */

static const OSEnumItem SegmentAttributeXY_ENUMTAB[] = {
   { OSUTF8("adaptiveTimingPresent"), 25, 21, 21 },
   { OSUTF8("adjacentBikeLaneOnLeft"), 13, 22, 10 },
   { OSUTF8("adjacentBikeLaneOnRight"), 14, 23, 37 },
   { OSUTF8("adjacentParkingOnLeft"), 11, 21, 16 },
   { OSUTF8("adjacentParkingOnRight"), 12, 22, 17 },
   { OSUTF8("audibleSignalingPresent"), 24, 23, 8 },
   { OSUTF8("bikeBoxInFront"), 16, 14, 9 },
   { OSUTF8("costToPark"), 35, 10, 13 },
   { OSUTF8("curbOnLeft"), 5, 10, 14 },
   { OSUTF8("curbOnRight"), 6, 11, 34 },
   { OSUTF8("doNotBlock"), 1, 10, 35 },
   { OSUTF8("freeParking"), 33, 11, 3 },
   { OSUTF8("headInParking"), 32, 13, 4 },
   { OSUTF8("loadingzoneOnLeft"), 7, 17, 1 },
   { OSUTF8("loadingzoneOnRight"), 8, 18, 2 },
   { OSUTF8("lowCurbsPresent"), 22, 15, 25 },
   { OSUTF8("mergingLaneLeft"), 3, 15, 6 },
   { OSUTF8("mergingLaneRight"), 4, 16, 32 },
   { OSUTF8("midBlockCurbPresent"), 36, 19, 33 },
   { OSUTF8("parallelParking"), 31, 15, 31 },
   { OSUTF8("partialCurbIntrusion"), 27, 20, 26 },
   { OSUTF8("reserved"), 0, 8, 24 },
   { OSUTF8("rfSignalRequestPresent"), 26, 22, 15 },
   { OSUTF8("rumbleStripPresent"), 23, 18, 23 },
   { OSUTF8("safeIsland"), 21, 10, 5 },
   { OSUTF8("sharedBikeLane"), 15, 14, 0 },
   { OSUTF8("sharedWithTrackedVehicle"), 20, 24, 22 },
   { OSUTF8("taperToCenterLine"), 30, 17, 20 },
   { OSUTF8("taperToLeft"), 28, 11, 28 },
   { OSUTF8("taperToRight"), 29, 12, 29 },
   { OSUTF8("timeRestrictionsOnParking"), 34, 25, 27 },
   { OSUTF8("transitStopInLane"), 19, 17, 19 },
   { OSUTF8("transitStopOnLeft"), 17, 17, 12 },
   { OSUTF8("transitStopOnRight"), 18, 18, 11 },
   { OSUTF8("turnOutPointOnLeft"), 9, 18, 30 },
   { OSUTF8("turnOutPointOnRight"), 10, 19, 7 },
   { OSUTF8("unEvenPavementPresent"), 37, 21, 18 },
   { OSUTF8("whiteLine"), 2, 9, 36 }
} ;
#define SegmentAttributeXY_ENUMTABSIZE 38

const OSUTF8CHAR* SegmentAttributeXY_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SegmentAttributeXY_ENUMTABSIZE) {
      return SegmentAttributeXY_ENUMTAB
         [SegmentAttributeXY_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SegmentAttributeXY_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SegmentAttributeXY* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SegmentAttributeXY_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SegmentAttributeXY_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, SegmentAttributeXY* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, SegmentAttributeXY_ENUMTAB, 
      SegmentAttributeXY_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SegmentAttributeXY)SegmentAttributeXY_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* SemiMajorAxisAccuracy */

/* SemiMajorAxisOrientation */

/* SemiMinorAxisAccuracy */

/* SignalGroupID */

/* SignalReqScheme */

int asn1Init_SignalReqScheme (SignalReqScheme* pvalue)
{
   pvalue->numocts = 0;
   return 0;
}

/* SignPrority */

/* SirenInUse */

static const OSEnumItem SirenInUse_ENUMTAB[] = {
   { OSUTF8("inUse"), 2, 5, 3 },
   { OSUTF8("notInUse"), 1, 8, 1 },
   { OSUTF8("reserved"), 3, 8, 0 },
   { OSUTF8("unavailable"), 0, 11, 2 }
} ;
#define SirenInUse_ENUMTABSIZE 4

const OSUTF8CHAR* SirenInUse_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SirenInUse_ENUMTABSIZE) {
      return SirenInUse_ENUMTAB[SirenInUse_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SirenInUse_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SirenInUse* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SirenInUse_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SirenInUse_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, SirenInUse* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, SirenInUse_ENUMTAB, 
      SirenInUse_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SirenInUse)SirenInUse_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* SpeedAdvice */

/* SpeedConfidence */

static const OSEnumItem SpeedConfidence_ENUMTAB[] = {
   { OSUTF8("prec0-01ms"), 7, 10, 7 },
   { OSUTF8("prec0-05ms"), 6, 10, 3 },
   { OSUTF8("prec0-1ms"), 5, 9, 4 },
   { OSUTF8("prec100ms"), 1, 9, 6 },
   { OSUTF8("prec10ms"), 2, 8, 5 },
   { OSUTF8("prec1ms"), 4, 7, 2 },
   { OSUTF8("prec5ms"), 3, 7, 1 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define SpeedConfidence_ENUMTABSIZE 8

const OSUTF8CHAR* SpeedConfidence_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SpeedConfidence_ENUMTABSIZE) {
      return SpeedConfidence_ENUMTAB
         [SpeedConfidence_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SpeedConfidence_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SpeedConfidence* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SpeedConfidence_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SpeedConfidence_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, SpeedConfidence* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, SpeedConfidence_ENUMTAB, 
      SpeedConfidence_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SpeedConfidence)SpeedConfidence_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* SpeedLimitType */

static const OSEnumItem SpeedLimitType_ENUMTAB[] = {
   { OSUTF8("maxSpeedInConstructionZone"), 3, 26, 6 },
   { OSUTF8("maxSpeedInSchoolZone"), 1, 20, 1 },
   { OSUTF8("maxSpeedInSchoolZoneWhenChildrenArePresent"), 2, 42, 2 },
   { OSUTF8("truckMaxSpeed"), 8, 13, 0 },
   { OSUTF8("truckMinSpeed"), 7, 13, 8 },
   { OSUTF8("truckNightMaxSpeed"), 9, 18, 7 },
   { OSUTF8("unknown"), 0, 7, 9 },
   { OSUTF8("vehicleMaxSpeed"), 5, 15, 4 },
   { OSUTF8("vehicleMinSpeed"), 4, 15, 3 },
   { OSUTF8("vehicleNightMaxSpeed"), 6, 20, 5 },
   { OSUTF8("vehiclesWithTrailersMaxSpeed"), 11, 28, 11 },
   { OSUTF8("vehiclesWithTrailersMinSpeed"), 10, 28, 10 },
   { OSUTF8("vehiclesWithTrailersNightMaxSpeed"), 12, 33, 12 }
} ;
#define SpeedLimitType_ENUMTABSIZE 13

const OSUTF8CHAR* SpeedLimitType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SpeedLimitType_ENUMTABSIZE) {
      return SpeedLimitType_ENUMTAB
         [SpeedLimitType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SpeedLimitType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SpeedLimitType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SpeedLimitType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SpeedLimitType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, SpeedLimitType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, SpeedLimitType_ENUMTAB, 
      SpeedLimitType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SpeedLimitType)SpeedLimitType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* SpeedProfileMeasurement */

/* Speed */

/* SSPindex */

/* StabilityControlStatus */

static const OSEnumItem StabilityControlStatus_ENUMTAB[] = {
   { OSUTF8("engaged"), 3, 7, 3 },
   { OSUTF8("off"), 1, 3, 1 },
   { OSUTF8("on"), 2, 2, 2 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define StabilityControlStatus_ENUMTABSIZE 4

const OSUTF8CHAR* StabilityControlStatus_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < StabilityControlStatus_ENUMTABSIZE) {
      return StabilityControlStatus_ENUMTAB
         [StabilityControlStatus_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int StabilityControlStatus_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, StabilityControlStatus* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return StabilityControlStatus_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int StabilityControlStatus_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, StabilityControlStatus* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      StabilityControlStatus_ENUMTAB, StabilityControlStatus_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (StabilityControlStatus)
         StabilityControlStatus_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* StationID */

/* SteeringWheelAngleConfidence */

static const OSEnumItem SteeringWheelAngleConfidence_ENUMTAB[] = {
   { OSUTF8("prec0-02deg"), 3, 11, 3 },
   { OSUTF8("prec1deg"), 2, 8, 2 },
   { OSUTF8("prec2deg"), 1, 8, 1 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define SteeringWheelAngleConfidence_ENUMTABSIZE 4

const OSUTF8CHAR* SteeringWheelAngleConfidence_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < SteeringWheelAngleConfidence_ENUMTABSIZE) {
      return SteeringWheelAngleConfidence_ENUMTAB
         [SteeringWheelAngleConfidence_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int SteeringWheelAngleConfidence_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, SteeringWheelAngleConfidence* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return SteeringWheelAngleConfidence_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int SteeringWheelAngleConfidence_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      SteeringWheelAngleConfidence* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      SteeringWheelAngleConfidence_ENUMTAB, 
      SteeringWheelAngleConfidence_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (SteeringWheelAngleConfidence)
         SteeringWheelAngleConfidence_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* SteeringWheelAngleRateOfChange */

/* SteeringWheelAngle */

/* SunSensor */

/* TemporaryID */

int asn1Init_TemporaryID (TemporaryID* pvalue)
{
   pvalue->numocts = 0;
   return 0;
}

/* TermDistance */

/* TermTime */

/* ThrottleConfidence */

static const OSEnumItem ThrottleConfidence_ENUMTAB[] = {
   { OSUTF8("prec0-5percent"), 3, 14, 3 },
   { OSUTF8("prec10percent"), 1, 13, 1 },
   { OSUTF8("prec1percent"), 2, 12, 2 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define ThrottleConfidence_ENUMTABSIZE 4

const OSUTF8CHAR* ThrottleConfidence_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ThrottleConfidence_ENUMTABSIZE) {
      return ThrottleConfidence_ENUMTAB
         [ThrottleConfidence_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ThrottleConfidence_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ThrottleConfidence* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ThrottleConfidence_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ThrottleConfidence_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ThrottleConfidence* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ThrottleConfidence_ENUMTAB, 
      ThrottleConfidence_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ThrottleConfidence)ThrottleConfidence_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* ThrottlePosition */

/* TimeConfidence */

static const OSEnumItem TimeConfidence_ENUMTAB[] = {
   { OSUTF8("time-000-000-000-000-01"), 39, 23, 39 },
   { OSUTF8("time-000-000-000-000-02"), 38, 23, 38 },
   { OSUTF8("time-000-000-000-000-05"), 37, 23, 37 },
   { OSUTF8("time-000-000-000-000-1"), 36, 22, 36 },
   { OSUTF8("time-000-000-000-000-2"), 35, 22, 35 },
   { OSUTF8("time-000-000-000-000-5"), 34, 22, 34 },
   { OSUTF8("time-000-000-000-001"), 33, 20, 33 },
   { OSUTF8("time-000-000-000-002"), 32, 20, 32 },
   { OSUTF8("time-000-000-000-005"), 31, 20, 31 },
   { OSUTF8("time-000-000-000-01"), 30, 19, 30 },
   { OSUTF8("time-000-000-000-02"), 29, 19, 29 },
   { OSUTF8("time-000-000-000-05"), 28, 19, 28 },
   { OSUTF8("time-000-000-000-1"), 27, 18, 27 },
   { OSUTF8("time-000-000-000-2"), 26, 18, 26 },
   { OSUTF8("time-000-000-000-5"), 25, 18, 25 },
   { OSUTF8("time-000-000-001"), 24, 16, 24 },
   { OSUTF8("time-000-000-002"), 23, 16, 23 },
   { OSUTF8("time-000-000-005"), 22, 16, 22 },
   { OSUTF8("time-000-000-01"), 21, 15, 21 },
   { OSUTF8("time-000-000-02"), 20, 15, 20 },
   { OSUTF8("time-000-000-05"), 19, 15, 19 },
   { OSUTF8("time-000-000-1"), 18, 14, 18 },
   { OSUTF8("time-000-000-2"), 17, 14, 17 },
   { OSUTF8("time-000-000-5"), 16, 14, 16 },
   { OSUTF8("time-000-001"), 15, 12, 15 },
   { OSUTF8("time-000-002"), 14, 12, 14 },
   { OSUTF8("time-000-005"), 13, 12, 13 },
   { OSUTF8("time-000-010"), 12, 12, 12 },
   { OSUTF8("time-000-020"), 11, 12, 11 },
   { OSUTF8("time-000-050"), 10, 12, 10 },
   { OSUTF8("time-000-100"), 9, 12, 9 },
   { OSUTF8("time-000-200"), 8, 12, 8 },
   { OSUTF8("time-000-500"), 7, 12, 7 },
   { OSUTF8("time-001-000"), 6, 12, 6 },
   { OSUTF8("time-002-000"), 5, 12, 5 },
   { OSUTF8("time-010-000"), 4, 12, 4 },
   { OSUTF8("time-020-000"), 3, 12, 3 },
   { OSUTF8("time-050-000"), 2, 12, 2 },
   { OSUTF8("time-100-000"), 1, 12, 1 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define TimeConfidence_ENUMTABSIZE 40

const OSUTF8CHAR* TimeConfidence_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < TimeConfidence_ENUMTABSIZE) {
      return TimeConfidence_ENUMTAB
         [TimeConfidence_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int TimeConfidence_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, TimeConfidence* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return TimeConfidence_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int TimeConfidence_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, TimeConfidence* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, TimeConfidence_ENUMTAB, 
      TimeConfidence_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (TimeConfidence)TimeConfidence_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* TimeIntervalConfidence */

/* TimeMark */

/* TimeOffset */

/* TractionControlStatus */

static const OSEnumItem TractionControlStatus_ENUMTAB[] = {
   { OSUTF8("engaged"), 3, 7, 3 },
   { OSUTF8("off"), 1, 3, 1 },
   { OSUTF8("on"), 2, 2, 2 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define TractionControlStatus_ENUMTABSIZE 4

const OSUTF8CHAR* TractionControlStatus_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < TractionControlStatus_ENUMTABSIZE) {
      return TractionControlStatus_ENUMTAB
         [TractionControlStatus_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int TractionControlStatus_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, TractionControlStatus* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return TractionControlStatus_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int TractionControlStatus_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, TractionControlStatus* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      TractionControlStatus_ENUMTAB, TractionControlStatus_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (TractionControlStatus)
         TractionControlStatus_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* TrailerMass */

/* TransitStatus */

int asn1Init_TransitStatus (TransitStatus* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* TransitVehicleOccupancy */

static const OSEnumItem TransitVehicleOccupancy_ENUMTAB[] = {
   { OSUTF8("occupancyEmpty"), 1, 14, 6 },
   { OSUTF8("occupancyFull"), 7, 13, 0 },
   { OSUTF8("occupancyHigh"), 5, 13, 7 },
   { OSUTF8("occupancyLow"), 3, 12, 3 },
   { OSUTF8("occupancyMed"), 4, 12, 4 },
   { OSUTF8("occupancyNearlyFull"), 6, 19, 2 },
   { OSUTF8("occupancyUnknown"), 0, 16, 5 },
   { OSUTF8("occupancyVeryLow"), 2, 16, 1 }
} ;
#define TransitVehicleOccupancy_ENUMTABSIZE 8

const OSUTF8CHAR* TransitVehicleOccupancy_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < TransitVehicleOccupancy_ENUMTABSIZE) {
      return TransitVehicleOccupancy_ENUMTAB
         [TransitVehicleOccupancy_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int TransitVehicleOccupancy_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, TransitVehicleOccupancy* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return TransitVehicleOccupancy_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int TransitVehicleOccupancy_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, TransitVehicleOccupancy* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      TransitVehicleOccupancy_ENUMTAB, TransitVehicleOccupancy_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (TransitVehicleOccupancy)
         TransitVehicleOccupancy_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* TransitVehicleStatus */

int asn1Init_TransitVehicleStatus (TransitVehicleStatus* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* TransmissionState */

static const OSEnumItem TransmissionState_ENUMTAB[] = {
   { OSUTF8("forwardGears"), 2, 12, 1 },
   { OSUTF8("neutral"), 0, 7, 2 },
   { OSUTF8("park"), 1, 4, 0 },
   { OSUTF8("reserved1"), 4, 9, 6 },
   { OSUTF8("reserved2"), 5, 9, 3 },
   { OSUTF8("reserved3"), 6, 9, 4 },
   { OSUTF8("reverseGears"), 3, 12, 5 },
   { OSUTF8("unavailable"), 7, 11, 7 }
} ;
#define TransmissionState_ENUMTABSIZE 8

const OSUTF8CHAR* TransmissionState_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < TransmissionState_ENUMTABSIZE) {
      return TransmissionState_ENUMTAB
         [TransmissionState_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int TransmissionState_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, TransmissionState* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return TransmissionState_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int TransmissionState_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, TransmissionState* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, TransmissionState_ENUMTAB, 
      TransmissionState_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (TransmissionState)TransmissionState_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* TravelerInfoType */

static const OSEnumItem TravelerInfoType_ENUMTAB[] = {
   { OSUTF8("advisory"), 1, 8, 3 },
   { OSUTF8("commercialSignage"), 3, 17, 0 },
   { OSUTF8("roadSignage"), 2, 11, 2 },
   { OSUTF8("unknown"), 0, 7, 1 }
} ;
#define TravelerInfoType_ENUMTABSIZE 4

const OSUTF8CHAR* TravelerInfoType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < TravelerInfoType_ENUMTABSIZE) {
      return TravelerInfoType_ENUMTAB
         [TravelerInfoType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int TravelerInfoType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, TravelerInfoType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return TravelerInfoType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int TravelerInfoType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, TravelerInfoType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, TravelerInfoType_ENUMTAB, 
      TravelerInfoType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (TravelerInfoType)TravelerInfoType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* UniqueMSGID */

int asn1Init_UniqueMSGID (UniqueMSGID* pvalue)
{
   pvalue->numocts = 0;
   return 0;
}

/* URL_Base */

void asn1Free_URL_Base (OSCTXT *pctxt, URL_Base pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue);
}

/* URL_Link */

void asn1Free_URL_Link (OSCTXT *pctxt, URL_Link pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue);
}

/* URL_Short */

void asn1Free_URL_Short (OSCTXT *pctxt, URL_Short pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue);
}

/* UserSizeAndBehaviour */

int asn1Init_UserSizeAndBehaviour (UserSizeAndBehaviour* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   pvalue->extdata = 0;
   return 0;
}

/* VehicleEventFlags */

int asn1Init_VehicleEventFlags (VehicleEventFlags* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   pvalue->extdata = 0;
   return 0;
}

/* VehicleHeight */

/* VehicleLength */

/* VehicleMass */

/* VehicleStatusDeviceTypeTag */

static const OSEnumItem VehicleStatusDeviceTypeTag_ENUMTAB[] = {
   { OSUTF8("abs"), 6, 3, 22 },
   { OSUTF8("accel4way"), 16, 9, 10 },
   { OSUTF8("airTemp"), 9, 7, 26 },
   { OSUTF8("brakes"), 3, 6, 3 },
   { OSUTF8("confidenceSet"), 17, 13, 18 },
   { OSUTF8("dateTime"), 22, 8, 21 },
   { OSUTF8("fullPos"), 23, 7, 0 },
   { OSUTF8("hozAccelCon"), 15, 11, 20 },
   { OSUTF8("hozAccelLat"), 14, 11, 15 },
   { OSUTF8("hozAccelLong"), 13, 12, 2 },
   { OSUTF8("lights"), 1, 6, 19 },
   { OSUTF8("obDirect"), 19, 8, 25 },
   { OSUTF8("obDist"), 18, 6, 24 },
   { OSUTF8("position2D"), 24, 10, 9 },
   { OSUTF8("position3D"), 25, 10, 8 },
   { OSUTF8("rainS"), 8, 5, 7 },
   { OSUTF8("speedC"), 28, 6, 1 },
   { OSUTF8("speedHeadC"), 27, 10, 4 },
   { OSUTF8("stab"), 4, 4, 12 },
   { OSUTF8("steering"), 10, 8, 11 },
   { OSUTF8("sunS"), 7, 4, 27 },
   { OSUTF8("trac"), 5, 4, 28 },
   { OSUTF8("unknown"), 0, 7, 5 },
   { OSUTF8("vehicle"), 26, 7, 6 },
   { OSUTF8("vertAccel"), 12, 9, 13 },
   { OSUTF8("vertAccelThres"), 11, 14, 14 },
   { OSUTF8("wipers"), 2, 6, 23 },
   { OSUTF8("yaw"), 20, 3, 17 },
   { OSUTF8("yawRateCon"), 21, 10, 16 }
} ;
#define VehicleStatusDeviceTypeTag_ENUMTABSIZE 29

const OSUTF8CHAR* VehicleStatusDeviceTypeTag_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < VehicleStatusDeviceTypeTag_ENUMTABSIZE) {
      return VehicleStatusDeviceTypeTag_ENUMTAB
         [VehicleStatusDeviceTypeTag_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int VehicleStatusDeviceTypeTag_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, VehicleStatusDeviceTypeTag* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return VehicleStatusDeviceTypeTag_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int VehicleStatusDeviceTypeTag_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      VehicleStatusDeviceTypeTag* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      VehicleStatusDeviceTypeTag_ENUMTAB, 
      VehicleStatusDeviceTypeTag_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (VehicleStatusDeviceTypeTag)
         VehicleStatusDeviceTypeTag_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* VehicleType */

static const OSEnumItem VehicleType_ENUMTAB[] = {
   { OSUTF8("axleCnt2"), 7, 8, 13 },
   { OSUTF8("axleCnt3"), 8, 8, 15 },
   { OSUTF8("axleCnt4"), 9, 8, 14 },
   { OSUTF8("axleCnt4Trailer"), 10, 15, 12 },
   { OSUTF8("axleCnt5MultiTrailer"), 13, 20, 10 },
   { OSUTF8("axleCnt5Trailer"), 11, 15, 11 },
   { OSUTF8("axleCnt6MultiTrailer"), 14, 20, 9 },
   { OSUTF8("axleCnt6Trailer"), 12, 15, 0 },
   { OSUTF8("axleCnt7MultiTrailer"), 15, 20, 1 },
   { OSUTF8("bus"), 6, 3, 2 },
   { OSUTF8("car"), 4, 3, 3 },
   { OSUTF8("carOther"), 5, 8, 5 },
   { OSUTF8("moto"), 3, 4, 7 },
   { OSUTF8("none"), 0, 4, 4 },
   { OSUTF8("special"), 2, 7, 6 },
   { OSUTF8("unknown"), 1, 7, 8 }
} ;
#define VehicleType_ENUMTABSIZE 16

const OSUTF8CHAR* VehicleType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < VehicleType_ENUMTABSIZE) {
      return VehicleType_ENUMTAB[VehicleType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int VehicleType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, VehicleType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return VehicleType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int VehicleType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, VehicleType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, VehicleType_ENUMTAB, 
      VehicleType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (VehicleType)VehicleType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* VehicleWidth */

/* Velocity */

/* VerticalAccelerationThreshold */

int asn1Init_VerticalAccelerationThreshold (
   VerticalAccelerationThreshold* pvalue)
{
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
   return 0;
}

/* VerticalAcceleration */

/* VertOffset_B07 */

/* VertOffset_B08 */

/* VertOffset_B09 */

/* VertOffset_B10 */

/* VertOffset_B11 */

/* VertOffset_B12 */

/* VINstring */

int asn1Init_VINstring (VINstring* pvalue)
{
   pvalue->numocts = 0;
   return 0;
}

/* WaitOnStopline */

/* WiperRate */

/* WiperStatus */

static const OSEnumItem WiperStatus_ENUMTAB[] = {
   { OSUTF8("automaticPresent"), 6, 16, 5 },
   { OSUTF8("high"), 4, 4, 4 },
   { OSUTF8("intermittent"), 2, 12, 2 },
   { OSUTF8("low"), 3, 3, 3 },
   { OSUTF8("off"), 1, 3, 1 },
   { OSUTF8("unavailable"), 0, 11, 6 },
   { OSUTF8("washerInUse"), 5, 11, 0 }
} ;
#define WiperStatus_ENUMTABSIZE 7

const OSUTF8CHAR* WiperStatus_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < WiperStatus_ENUMTABSIZE) {
      return WiperStatus_ENUMTAB[WiperStatus_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int WiperStatus_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, WiperStatus* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return WiperStatus_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int WiperStatus_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, WiperStatus* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, WiperStatus_ENUMTAB, 
      WiperStatus_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (WiperStatus)WiperStatus_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* YawRateConfidence */

static const OSEnumItem YawRateConfidence_ENUMTAB[] = {
   { OSUTF8("degSec-000-01"), 7, 13, 7 },
   { OSUTF8("degSec-000-05"), 6, 13, 6 },
   { OSUTF8("degSec-000-10"), 5, 13, 5 },
   { OSUTF8("degSec-001-00"), 4, 13, 4 },
   { OSUTF8("degSec-005-00"), 3, 13, 3 },
   { OSUTF8("degSec-010-00"), 2, 13, 2 },
   { OSUTF8("degSec-100-00"), 1, 13, 1 },
   { OSUTF8("unavailable"), 0, 11, 0 }
} ;
#define YawRateConfidence_ENUMTABSIZE 8

const OSUTF8CHAR* YawRateConfidence_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < YawRateConfidence_ENUMTABSIZE) {
      return YawRateConfidence_ENUMTAB
         [YawRateConfidence_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int YawRateConfidence_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, YawRateConfidence* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return YawRateConfidence_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int YawRateConfidence_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, YawRateConfidence* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, YawRateConfidence_ENUMTAB, 
      YawRateConfidence_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (YawRateConfidence)YawRateConfidence_ENUMTAB[idx].value;
      return 0;
   }
   else {
      return RTERR_INVENUM;
   }
}

/* YawRate */

/* ZoneLength */

/* Zoom */

/* MessageFrame */

int asn1Init_MessageFrame (MessageFrame* pvalue)
{
   pvalue->value.numocts = 0;
   pvalue->value.data = 0;
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_MessageFrame (OSCTXT *pctxt, MessageFrame* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->value.data);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* PositionalAccuracy */

/* AccelerationSet4Way */

/* BrakeSystemStatus */

int asn1Init_BrakeSystemStatus (BrakeSystemStatus* pvalue)
{
   asn1Init_BrakeAppliedStatus (&pvalue->wheelBrakes);
   return 0;
}

/* VehicleSize */

/* BSMcoreData */

int asn1Init_BSMcoreData (BSMcoreData* pvalue)
{
   asn1Init_TemporaryID (&pvalue->id);
   asn1Init_BrakeSystemStatus (&pvalue->brakes);
   return 0;
}

/* PartIIcontent */

int asn1Init_PartIIcontent (PartIIcontent* pvalue)
{
   pvalue->partII_Value.numocts = 0;
   pvalue->partII_Value.data = 0;
   return 0;
}

void asn1Free_PartIIcontent (OSCTXT *pctxt, PartIIcontent* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->partII_Value.data);
   }
}

/* BasicSafetyMessage_partII */

int asn1Init_BasicSafetyMessage_partII (BasicSafetyMessage_partII* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_BasicSafetyMessage_partII (OSCTXT *pctxt, 
   BasicSafetyMessage_partII* pvalue)
{
   if (0 == pvalue) return;
   { PartIIcontent* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (PartIIcontent*)pnode->data;
      asn1Free_PartIIcontent (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* RegionalExtension */

int asn1Init_RegionalExtension (RegionalExtension* pvalue)
{
   pvalue->regExtValue.numocts = 0;
   pvalue->regExtValue.data = 0;
   return 0;
}

void asn1Free_RegionalExtension (OSCTXT *pctxt, RegionalExtension* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->regExtValue.data);
   }
}

/* BasicSafetyMessage_regional */

int asn1Init_BasicSafetyMessage_regional (BasicSafetyMessage_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_BasicSafetyMessage_regional (OSCTXT *pctxt, 
   BasicSafetyMessage_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* BasicSafetyMessage */

int asn1Init_BasicSafetyMessage (BasicSafetyMessage* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_BSMcoreData (&pvalue->coreData);
   asn1Init_BasicSafetyMessage_partII (&pvalue->partII);
   asn1Init_BasicSafetyMessage_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_BasicSafetyMessage (OSCTXT *pctxt, BasicSafetyMessage* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.partIIPresent) {
      asn1Free_BasicSafetyMessage_partII (pctxt, &pvalue->partII);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_BasicSafetyMessage_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* RequestedItemList */

int asn1Init_RequestedItemList (RequestedItemList* pvalue)
{
   pvalue->n = 0;
   return 0;
}

/* CommonSafetyRequest_regional */

int asn1Init_CommonSafetyRequest_regional (
   CommonSafetyRequest_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_CommonSafetyRequest_regional (OSCTXT *pctxt, 
   CommonSafetyRequest_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* CommonSafetyRequest */

int asn1Init_CommonSafetyRequest (CommonSafetyRequest* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_TemporaryID (&pvalue->id);
   asn1Init_RequestedItemList (&pvalue->requests);
   asn1Init_CommonSafetyRequest_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_CommonSafetyRequest (OSCTXT *pctxt, CommonSafetyRequest* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.regionalPresent) {
      asn1Free_CommonSafetyRequest_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* RoadSideAlert_description */

int asn1Init_RoadSideAlert_description (RoadSideAlert_description* pvalue)
{
   pvalue->n = 0;
   return 0;
}

/* DDateTime */

int asn1Init_DDateTime (DDateTime* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   return 0;
}

/* TransmissionAndSpeed */

/* PositionConfidenceSet */

/* SpeedandHeadingandThrottleConfidence */

/* FullPositionVector */

int asn1Init_FullPositionVector (FullPositionVector* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_DDateTime (&pvalue->utcTime);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_FullPositionVector (OSCTXT *pctxt, FullPositionVector* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* RoadSideAlert_regional */

int asn1Init_RoadSideAlert_regional (RoadSideAlert_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_RoadSideAlert_regional (OSCTXT *pctxt, 
   RoadSideAlert_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* RoadSideAlert */

int asn1Init_RoadSideAlert (RoadSideAlert* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RoadSideAlert_description (&pvalue->description);
   asn1Init_Priority (&pvalue->priority);
   asn1Init_HeadingSlice (&pvalue->heading);
   asn1Init_FullPositionVector (&pvalue->position);
   asn1Init_FurtherInfoID (&pvalue->furtherInfoID);
   asn1Init_RoadSideAlert_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_RoadSideAlert (OSCTXT *pctxt, RoadSideAlert* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.positionPresent) {
      asn1Free_FullPositionVector (pctxt, &pvalue->position);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RoadSideAlert_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* PrivilegedEvents */

int asn1Init_PrivilegedEvents (PrivilegedEvents* pvalue)
{
   asn1Init_PrivilegedEventFlags (&pvalue->event);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_PrivilegedEvents (OSCTXT *pctxt, PrivilegedEvents* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* EmergencyDetails */

int asn1Init_EmergencyDetails (EmergencyDetails* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PrivilegedEvents (&pvalue->events);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_EmergencyDetails (OSCTXT *pctxt, EmergencyDetails* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.eventsPresent) {
      asn1Free_PrivilegedEvents (pctxt, &pvalue->events);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* EmergencyVehicleAlert_regional */

int asn1Init_EmergencyVehicleAlert_regional (
   EmergencyVehicleAlert_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_EmergencyVehicleAlert_regional (OSCTXT *pctxt, 
   EmergencyVehicleAlert_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* EmergencyVehicleAlert */

int asn1Init_EmergencyVehicleAlert (EmergencyVehicleAlert* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_TemporaryID (&pvalue->id);
   asn1Init_RoadSideAlert (&pvalue->rsaMsg);
   asn1Init_EmergencyDetails (&pvalue->details);
   asn1Init_EmergencyVehicleAlert_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_EmergencyVehicleAlert (OSCTXT *pctxt, 
   EmergencyVehicleAlert* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_RoadSideAlert (pctxt, &pvalue->rsaMsg);
   if (pvalue->m.detailsPresent) {
      asn1Free_EmergencyDetails (pctxt, &pvalue->details);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_EmergencyVehicleAlert_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* PathHistoryPoint */

int asn1Init_PathHistoryPoint (PathHistoryPoint* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_PathHistoryPoint (OSCTXT *pctxt, PathHistoryPoint* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* PathHistoryPointList */

int asn1Init_PathHistoryPointList (PathHistoryPointList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_PathHistoryPointList (OSCTXT *pctxt, 
   PathHistoryPointList* pvalue)
{
   if (0 == pvalue) return;
   { PathHistoryPoint* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (PathHistoryPoint*)pnode->data;
      asn1Free_PathHistoryPoint (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* PathHistory */

int asn1Init_PathHistory (PathHistory* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_FullPositionVector (&pvalue->initialPosition);
   asn1Init_GNSSstatus (&pvalue->currGNSSstatus);
   asn1Init_PathHistoryPointList (&pvalue->crumbData);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_PathHistory (OSCTXT *pctxt, PathHistory* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.initialPositionPresent) {
      asn1Free_FullPositionVector (pctxt, &pvalue->initialPosition);
   }
   asn1Free_PathHistoryPointList (pctxt, &pvalue->crumbData);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* PathPrediction */

int asn1Init_PathPrediction (PathPrediction* pvalue)
{
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_PathPrediction (OSCTXT *pctxt, PathPrediction* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* IntersectionReferenceID */

int asn1Init_IntersectionReferenceID (IntersectionReferenceID* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   return 0;
}

/* ApproachOrLane */

int asn1Init_ApproachOrLane (ApproachOrLane* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

/* IntersectionCollision_regional */

int asn1Init_IntersectionCollision_regional (
   IntersectionCollision_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_IntersectionCollision_regional (OSCTXT *pctxt, 
   IntersectionCollision_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* IntersectionCollision */

int asn1Init_IntersectionCollision (IntersectionCollision* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_TemporaryID (&pvalue->id);
   asn1Init_BSMcoreData (&pvalue->partOne);
   asn1Init_PathHistory (&pvalue->path);
   asn1Init_PathPrediction (&pvalue->pathPrediction);
   asn1Init_IntersectionReferenceID (&pvalue->intersectionID);
   asn1Init_ApproachOrLane (&pvalue->laneNumber);
   asn1Init_VehicleEventFlags (&pvalue->eventFlag);
   asn1Init_IntersectionCollision_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_IntersectionCollision (OSCTXT *pctxt, 
   IntersectionCollision* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pathPresent) {
      asn1Free_PathHistory (pctxt, &pvalue->path);
   }
   if (pvalue->m.pathPredictionPresent) {
      asn1Free_PathPrediction (pctxt, &pvalue->pathPrediction);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_IntersectionCollision_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* Position3D_regional */

int asn1Init_Position3D_regional (Position3D_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_Position3D_regional (OSCTXT *pctxt, Position3D_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* Position3D */

int asn1Init_Position3D (Position3D* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Position3D_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_Position3D (OSCTXT *pctxt, Position3D* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.regionalPresent) {
      asn1Free_Position3D_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* RegulatorySpeedLimit */

/* SpeedLimitList */

int asn1Init_SpeedLimitList (SpeedLimitList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_SpeedLimitList (OSCTXT *pctxt, SpeedLimitList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

/* LaneTypeAttributes */

int asn1Init_LaneTypeAttributes (LaneTypeAttributes* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_LaneTypeAttributes (OSCTXT *pctxt, LaneTypeAttributes* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.vehicle) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.vehicle);
            pvalue->u.vehicle = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.crosswalk) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.crosswalk);
            pvalue->u.crosswalk = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.bikeLane) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.bikeLane);
            pvalue->u.bikeLane = 0;
         }
         break;

      case 4:
         if (0 != pvalue->u.sidewalk) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sidewalk);
            pvalue->u.sidewalk = 0;
         }
         break;

      case 5:
         if (0 != pvalue->u.median) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.median);
            pvalue->u.median = 0;
         }
         break;

      case 6:
         if (0 != pvalue->u.striping) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.striping);
            pvalue->u.striping = 0;
         }
         break;

      case 7:
         if (0 != pvalue->u.trackedVehicle) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.trackedVehicle);
            pvalue->u.trackedVehicle = 0;
         }
         break;

      case 8:
         if (0 != pvalue->u.parking) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.parking);
            pvalue->u.parking = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

/* LaneAttributes */

int asn1Init_LaneAttributes (LaneAttributes* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_LaneDirection (&pvalue->directionalUse);
   asn1Init_LaneSharing (&pvalue->sharedWith);
   asn1Init_LaneTypeAttributes (&pvalue->laneType);
   asn1Init_RegionalExtension (&pvalue->regional);
   return 0;
}

void asn1Free_LaneAttributes (OSCTXT *pctxt, LaneAttributes* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_LaneTypeAttributes (pctxt, &pvalue->laneType);
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
}

/* Node_XY_20b */

/* Node_XY_22b */

/* Node_XY_24b */

/* Node_XY_26b */

/* Node_XY_28b */

/* Node_XY_32b */

/* Node_LLmD_64b */

/* NodeOffsetPointXY */

int asn1Init_NodeOffsetPointXY (NodeOffsetPointXY* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_NodeOffsetPointXY (OSCTXT *pctxt, NodeOffsetPointXY* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.node_XY1) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.node_XY1);
            pvalue->u.node_XY1 = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.node_XY2) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.node_XY2);
            pvalue->u.node_XY2 = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.node_XY3) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.node_XY3);
            pvalue->u.node_XY3 = 0;
         }
         break;

      case 4:
         if (0 != pvalue->u.node_XY4) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.node_XY4);
            pvalue->u.node_XY4 = 0;
         }
         break;

      case 5:
         if (0 != pvalue->u.node_XY5) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.node_XY5);
            pvalue->u.node_XY5 = 0;
         }
         break;

      case 6:
         if (0 != pvalue->u.node_XY6) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.node_XY6);
            pvalue->u.node_XY6 = 0;
         }
         break;

      case 7:
         if (0 != pvalue->u.node_LatLon) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.node_LatLon);
            pvalue->u.node_LatLon = 0;
         }
         break;

      case 8:
         if (0 != pvalue->u.regional) {
            asn1Free_RegionalExtension (pctxt, pvalue->u.regional);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.regional);
            pvalue->u.regional = 0;
         }
         break;

   }
}

/* NodeAttributeXYList */

int asn1Init_NodeAttributeXYList (NodeAttributeXYList* pvalue)
{
   pvalue->n = 0;
   return 0;
}

/* SegmentAttributeXYList */

int asn1Init_SegmentAttributeXYList (SegmentAttributeXYList* pvalue)
{
   pvalue->n = 0;
   return 0;
}

/* LaneDataAttribute_regional */

int asn1Init_LaneDataAttribute_regional (LaneDataAttribute_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_LaneDataAttribute_regional (OSCTXT *pctxt, 
   LaneDataAttribute_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* LaneDataAttribute */

int asn1Init_LaneDataAttribute (LaneDataAttribute* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_LaneDataAttribute (OSCTXT *pctxt, LaneDataAttribute* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         break;

      case 4:
         break;

      case 5:
         break;

      case 6:
         if (0 != pvalue->u.speedLimits) {
            asn1Free_SpeedLimitList (pctxt, pvalue->u.speedLimits);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.speedLimits);
            pvalue->u.speedLimits = 0;
         }
         break;

      case 7:
         if (0 != pvalue->u.regional) {
            asn1Free_LaneDataAttribute_regional (pctxt, pvalue->u.regional);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.regional);
            pvalue->u.regional = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

/* LaneDataAttributeList */

int asn1Init_LaneDataAttributeList (LaneDataAttributeList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_LaneDataAttributeList (OSCTXT *pctxt, 
   LaneDataAttributeList* pvalue)
{
   if (0 == pvalue) return;
   { LaneDataAttribute* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (LaneDataAttribute*)pnode->data;
      asn1Free_LaneDataAttribute (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* NodeAttributeSetXY_regional */

int asn1Init_NodeAttributeSetXY_regional (NodeAttributeSetXY_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_NodeAttributeSetXY_regional (OSCTXT *pctxt, 
   NodeAttributeSetXY_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* NodeAttributeSetXY */

int asn1Init_NodeAttributeSetXY (NodeAttributeSetXY* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_NodeAttributeXYList (&pvalue->localNode);
   asn1Init_SegmentAttributeXYList (&pvalue->disabled);
   asn1Init_SegmentAttributeXYList (&pvalue->enabled);
   asn1Init_LaneDataAttributeList (&pvalue->data);
   asn1Init_NodeAttributeSetXY_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_NodeAttributeSetXY (OSCTXT *pctxt, NodeAttributeSetXY* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dataPresent) {
      asn1Free_LaneDataAttributeList (pctxt, &pvalue->data);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_NodeAttributeSetXY_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* NodeXY */

int asn1Init_NodeXY (NodeXY* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_NodeOffsetPointXY (&pvalue->delta);
   asn1Init_NodeAttributeSetXY (&pvalue->attributes);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_NodeXY (OSCTXT *pctxt, NodeXY* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_NodeOffsetPointXY (pctxt, &pvalue->delta);
   if (pvalue->m.attributesPresent) {
      asn1Free_NodeAttributeSetXY (pctxt, &pvalue->attributes);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* NodeSetXY */

int asn1Init_NodeSetXY (NodeSetXY* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_NodeSetXY (OSCTXT *pctxt, NodeSetXY* pvalue)
{
   if (0 == pvalue) return;
   { NodeXY* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (NodeXY*)pnode->data;
      asn1Free_NodeXY (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* ComputedLane_offsetXaxis */

int asn1Init_ComputedLane_offsetXaxis (ComputedLane_offsetXaxis* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

/* ComputedLane_offsetYaxis */

int asn1Init_ComputedLane_offsetYaxis (ComputedLane_offsetYaxis* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

/* ComputedLane_regional */

int asn1Init_ComputedLane_regional (ComputedLane_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ComputedLane_regional (OSCTXT *pctxt, 
   ComputedLane_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* ComputedLane */

int asn1Init_ComputedLane (ComputedLane* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ComputedLane_offsetXaxis (&pvalue->offsetXaxis);
   asn1Init_ComputedLane_offsetYaxis (&pvalue->offsetYaxis);
   asn1Init_ComputedLane_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ComputedLane (OSCTXT *pctxt, ComputedLane* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.regionalPresent) {
      asn1Free_ComputedLane_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* NodeListXY */

int asn1Init_NodeListXY (NodeListXY* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_NodeListXY (OSCTXT *pctxt, NodeListXY* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.nodes) {
            asn1Free_NodeSetXY (pctxt, pvalue->u.nodes);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.nodes);
            pvalue->u.nodes = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.computed) {
            asn1Free_ComputedLane (pctxt, pvalue->u.computed);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.computed);
            pvalue->u.computed = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

/* ConnectingLane */

int asn1Init_ConnectingLane (ConnectingLane* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_AllowedManeuvers (&pvalue->maneuver);
   return 0;
}

/* Connection */

int asn1Init_Connection (Connection* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ConnectingLane (&pvalue->connectingLane);
   asn1Init_IntersectionReferenceID (&pvalue->remoteIntersection);
   return 0;
}

/* ConnectsToList */

int asn1Init_ConnectsToList (ConnectsToList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ConnectsToList (OSCTXT *pctxt, ConnectsToList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

/* OverlayLaneList */

int asn1Init_OverlayLaneList (OverlayLaneList* pvalue)
{
   pvalue->n = 0;
   return 0;
}

/* GenericLane_regional */

int asn1Init_GenericLane_regional (GenericLane_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_GenericLane_regional (OSCTXT *pctxt, 
   GenericLane_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* GenericLane */

int asn1Init_GenericLane (GenericLane* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->name = 0;
   asn1Init_LaneAttributes (&pvalue->laneAttributes);
   asn1Init_AllowedManeuvers (&pvalue->maneuvers);
   asn1Init_NodeListXY (&pvalue->nodeList);
   asn1Init_ConnectsToList (&pvalue->connectsTo);
   asn1Init_OverlayLaneList (&pvalue->overlays);
   asn1Init_GenericLane_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_GenericLane (OSCTXT *pctxt, GenericLane* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.namePresent) {
      asn1Free_DescriptiveName (pctxt, pvalue->name);
   }
   asn1Free_LaneAttributes (pctxt, &pvalue->laneAttributes);
   asn1Free_NodeListXY (pctxt, &pvalue->nodeList);
   if (pvalue->m.connectsToPresent) {
      asn1Free_ConnectsToList (pctxt, &pvalue->connectsTo);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_GenericLane_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* LaneList */

int asn1Init_LaneList (LaneList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_LaneList (OSCTXT *pctxt, LaneList* pvalue)
{
   if (0 == pvalue) return;
   { GenericLane* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (GenericLane*)pnode->data;
      asn1Free_GenericLane (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* SignalControlZone */

int asn1Init_SignalControlZone (SignalControlZone* pvalue)
{
   asn1Init_RegionalExtension (&pvalue->zone);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_SignalControlZone (OSCTXT *pctxt, SignalControlZone* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_RegionalExtension (pctxt, &pvalue->zone);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* PreemptPriorityList */

int asn1Init_PreemptPriorityList (PreemptPriorityList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_PreemptPriorityList (OSCTXT *pctxt, PreemptPriorityList* pvalue)
{
   if (0 == pvalue) return;
   { SignalControlZone* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (SignalControlZone*)pnode->data;
      asn1Free_SignalControlZone (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* IntersectionGeometry_regional */

int asn1Init_IntersectionGeometry_regional (
   IntersectionGeometry_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_IntersectionGeometry_regional (OSCTXT *pctxt, 
   IntersectionGeometry_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* IntersectionGeometry */

int asn1Init_IntersectionGeometry (IntersectionGeometry* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->name = 0;
   asn1Init_IntersectionReferenceID (&pvalue->id);
   asn1Init_Position3D (&pvalue->refPoint);
   asn1Init_SpeedLimitList (&pvalue->speedLimits);
   asn1Init_LaneList (&pvalue->laneSet);
   asn1Init_PreemptPriorityList (&pvalue->preemptPriorityData);
   asn1Init_IntersectionGeometry_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_IntersectionGeometry (OSCTXT *pctxt, 
   IntersectionGeometry* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.namePresent) {
      asn1Free_DescriptiveName (pctxt, pvalue->name);
   }
   asn1Free_Position3D (pctxt, &pvalue->refPoint);
   if (pvalue->m.speedLimitsPresent) {
      asn1Free_SpeedLimitList (pctxt, &pvalue->speedLimits);
   }
   asn1Free_LaneList (pctxt, &pvalue->laneSet);
   if (pvalue->m.preemptPriorityDataPresent) {
      asn1Free_PreemptPriorityList (pctxt, &pvalue->preemptPriorityData);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_IntersectionGeometry_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* IntersectionGeometryList */

int asn1Init_IntersectionGeometryList (IntersectionGeometryList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_IntersectionGeometryList (OSCTXT *pctxt, 
   IntersectionGeometryList* pvalue)
{
   if (0 == pvalue) return;
   { IntersectionGeometry* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (IntersectionGeometry*)pnode->data;
      asn1Free_IntersectionGeometry (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* RoadSegmentReferenceID */

int asn1Init_RoadSegmentReferenceID (RoadSegmentReferenceID* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   return 0;
}

/* RoadLaneSetList */

int asn1Init_RoadLaneSetList (RoadLaneSetList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_RoadLaneSetList (OSCTXT *pctxt, RoadLaneSetList* pvalue)
{
   if (0 == pvalue) return;
   { GenericLane* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (GenericLane*)pnode->data;
      asn1Free_GenericLane (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* RoadSegment_regional */

int asn1Init_RoadSegment_regional (RoadSegment_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_RoadSegment_regional (OSCTXT *pctxt, 
   RoadSegment_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* RoadSegment */

int asn1Init_RoadSegment (RoadSegment* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->name = 0;
   asn1Init_RoadSegmentReferenceID (&pvalue->id);
   asn1Init_Position3D (&pvalue->refPoint);
   asn1Init_SpeedLimitList (&pvalue->speedLimits);
   asn1Init_RoadLaneSetList (&pvalue->roadLaneSet);
   asn1Init_RoadSegment_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_RoadSegment (OSCTXT *pctxt, RoadSegment* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.namePresent) {
      asn1Free_DescriptiveName (pctxt, pvalue->name);
   }
   asn1Free_Position3D (pctxt, &pvalue->refPoint);
   if (pvalue->m.speedLimitsPresent) {
      asn1Free_SpeedLimitList (pctxt, &pvalue->speedLimits);
   }
   asn1Free_RoadLaneSetList (pctxt, &pvalue->roadLaneSet);
   if (pvalue->m.regionalPresent) {
      asn1Free_RoadSegment_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* RoadSegmentList */

int asn1Init_RoadSegmentList (RoadSegmentList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_RoadSegmentList (OSCTXT *pctxt, RoadSegmentList* pvalue)
{
   if (0 == pvalue) return;
   { RoadSegment* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RoadSegment*)pnode->data;
      asn1Free_RoadSegment (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* DataParameters */

int asn1Init_DataParameters (DataParameters* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->processMethod = 0;
   pvalue->processAgency = 0;
   pvalue->lastCheckedDate = 0;
   pvalue->geoidUsed = 0;
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_DataParameters (OSCTXT *pctxt, DataParameters* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.processMethodPresent) {
      rtxMemFreePtr (pctxt, (void*)pvalue->processMethod);
   }
   if (pvalue->m.processAgencyPresent) {
      rtxMemFreePtr (pctxt, (void*)pvalue->processAgency);
   }
   if (pvalue->m.lastCheckedDatePresent) {
      rtxMemFreePtr (pctxt, (void*)pvalue->lastCheckedDate);
   }
   if (pvalue->m.geoidUsedPresent) {
      rtxMemFreePtr (pctxt, (void*)pvalue->geoidUsed);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* RestrictionUserType_regional */

int asn1Init_RestrictionUserType_regional (
   RestrictionUserType_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_RestrictionUserType_regional (OSCTXT *pctxt, 
   RestrictionUserType_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* RestrictionUserType */

int asn1Init_RestrictionUserType (RestrictionUserType* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_RestrictionUserType (OSCTXT *pctxt, RestrictionUserType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.regional) {
            asn1Free_RestrictionUserType_regional (pctxt, pvalue->u.regional);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.regional);
            pvalue->u.regional = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

/* RestrictionUserTypeList */

int asn1Init_RestrictionUserTypeList (RestrictionUserTypeList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_RestrictionUserTypeList (OSCTXT *pctxt, 
   RestrictionUserTypeList* pvalue)
{
   if (0 == pvalue) return;
   { RestrictionUserType* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RestrictionUserType*)pnode->data;
      asn1Free_RestrictionUserType (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* RestrictionClassAssignment */

int asn1Init_RestrictionClassAssignment (RestrictionClassAssignment* pvalue)
{
   asn1Init_RestrictionUserTypeList (&pvalue->users);
   return 0;
}

void asn1Free_RestrictionClassAssignment (OSCTXT *pctxt, 
   RestrictionClassAssignment* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_RestrictionUserTypeList (pctxt, &pvalue->users);
}

/* RestrictionClassList */

int asn1Init_RestrictionClassList (RestrictionClassList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_RestrictionClassList (OSCTXT *pctxt, 
   RestrictionClassList* pvalue)
{
   if (0 == pvalue) return;
   { RestrictionClassAssignment* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RestrictionClassAssignment*)pnode->data;
      asn1Free_RestrictionClassAssignment (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* MapData_regional */

int asn1Init_MapData_regional (MapData_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_MapData_regional (OSCTXT *pctxt, MapData_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* MapData */

int asn1Init_MapData (MapData* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_IntersectionGeometryList (&pvalue->intersections);
   asn1Init_RoadSegmentList (&pvalue->roadSegments);
   asn1Init_DataParameters (&pvalue->dataParameters);
   asn1Init_RestrictionClassList (&pvalue->restrictionList);
   asn1Init_MapData_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_MapData (OSCTXT *pctxt, MapData* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.intersectionsPresent) {
      asn1Free_IntersectionGeometryList (pctxt, &pvalue->intersections);
   }
   if (pvalue->m.roadSegmentsPresent) {
      asn1Free_RoadSegmentList (pctxt, &pvalue->roadSegments);
   }
   if (pvalue->m.dataParametersPresent) {
      asn1Free_DataParameters (pctxt, &pvalue->dataParameters);
   }
   if (pvalue->m.restrictionListPresent) {
      asn1Free_RestrictionClassList (pctxt, &pvalue->restrictionList);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_MapData_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* NMEAcorrections_regional */

int asn1Init_NMEAcorrections_regional (NMEAcorrections_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_NMEAcorrections_regional (OSCTXT *pctxt, 
   NMEAcorrections_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* NMEAcorrections */

int asn1Init_NMEAcorrections (NMEAcorrections* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_NMEA_Payload (&pvalue->payload);
   asn1Init_NMEAcorrections_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_NMEAcorrections (OSCTXT *pctxt, NMEAcorrections* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.regionalPresent) {
      asn1Free_NMEAcorrections_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* PropelledInformation */

int asn1Init_PropelledInformation (PropelledInformation* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_PropelledInformation (OSCTXT *pctxt, 
   PropelledInformation* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

/* PersonalSafetyMessage_regional */

int asn1Init_PersonalSafetyMessage_regional (
   PersonalSafetyMessage_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_PersonalSafetyMessage_regional (OSCTXT *pctxt, 
   PersonalSafetyMessage_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* PersonalSafetyMessage */

int asn1Init_PersonalSafetyMessage (PersonalSafetyMessage* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_TemporaryID (&pvalue->id);
   asn1Init_Position3D (&pvalue->position);
   asn1Init_PathHistory (&pvalue->pathHistory);
   asn1Init_PathPrediction (&pvalue->pathPrediction);
   asn1Init_PropelledInformation (&pvalue->propulsion);
   asn1Init_PersonalDeviceUsageState (&pvalue->useState);
   asn1Init_PublicSafetyAndRoadWorkerActivity (&pvalue->activityType);
   asn1Init_PublicSafetyDirectingTrafficSubType (&pvalue->activitySubType);
   asn1Init_PersonalAssistive (&pvalue->assistType);
   asn1Init_UserSizeAndBehaviour (&pvalue->sizing);
   asn1Init_PersonalSafetyMessage_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_PersonalSafetyMessage (OSCTXT *pctxt, 
   PersonalSafetyMessage* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_Position3D (pctxt, &pvalue->position);
   if (pvalue->m.pathHistoryPresent) {
      asn1Free_PathHistory (pctxt, &pvalue->pathHistory);
   }
   if (pvalue->m.pathPredictionPresent) {
      asn1Free_PathPrediction (pctxt, &pvalue->pathPrediction);
   }
   if (pvalue->m.propulsionPresent) {
      asn1Free_PropelledInformation (pctxt, &pvalue->propulsion);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_PersonalSafetyMessage_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* Sample */

/* ProbeDataManagement_term */

int asn1Init_ProbeDataManagement_term (ProbeDataManagement_term* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

/* SnapshotTime */

/* SnapshotDistance */

/* ProbeDataManagement_snapshot */

int asn1Init_ProbeDataManagement_snapshot (
   ProbeDataManagement_snapshot* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ProbeDataManagement_snapshot (OSCTXT *pctxt, 
   ProbeDataManagement_snapshot* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.snapshotTime) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.snapshotTime);
            pvalue->u.snapshotTime = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.snapshotDistance) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.snapshotDistance);
            pvalue->u.snapshotDistance = 0;
         }
         break;

   }
}

/* VehicleStatusRequest */

int asn1Init_VehicleStatusRequest (VehicleStatusRequest* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_VehicleStatusRequest (OSCTXT *pctxt, 
   VehicleStatusRequest* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* VehicleStatusRequestList */

int asn1Init_VehicleStatusRequestList (VehicleStatusRequestList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_VehicleStatusRequestList (OSCTXT *pctxt, 
   VehicleStatusRequestList* pvalue)
{
   if (0 == pvalue) return;
   { VehicleStatusRequest* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (VehicleStatusRequest*)pnode->data;
      asn1Free_VehicleStatusRequest (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* ProbeDataManagement_regional */

int asn1Init_ProbeDataManagement_regional (
   ProbeDataManagement_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ProbeDataManagement_regional (OSCTXT *pctxt, 
   ProbeDataManagement_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* ProbeDataManagement */

int asn1Init_ProbeDataManagement (ProbeDataManagement* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_HeadingSlice (&pvalue->directions);
   asn1Init_ProbeDataManagement_term (&pvalue->term);
   asn1Init_ProbeDataManagement_snapshot (&pvalue->snapshot);
   asn1Init_VehicleStatusRequestList (&pvalue->dataElements);
   asn1Init_ProbeDataManagement_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ProbeDataManagement (OSCTXT *pctxt, ProbeDataManagement* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ProbeDataManagement_snapshot (pctxt, &pvalue->snapshot);
   if (pvalue->m.dataElementsPresent) {
      asn1Free_VehicleStatusRequestList (pctxt, &pvalue->dataElements);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_ProbeDataManagement_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* VehicleID */

int asn1Init_VehicleID (VehicleID* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_VehicleID (OSCTXT *pctxt, VehicleID* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.entityID) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.entityID);
            pvalue->u.entityID = 0;
         }
         break;

      case 2:
         break;

   }
}

/* VehicleIdent_vehicleClass */

int asn1Init_VehicleIdent_vehicleClass (VehicleIdent_vehicleClass* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

/* VehicleIdent */

int asn1Init_VehicleIdent (VehicleIdent* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->name = 0;
   asn1Init_VINstring (&pvalue->vin);
   pvalue->ownerCode = 0;
   asn1Init_VehicleID (&pvalue->id);
   asn1Init_VehicleIdent_vehicleClass (&pvalue->vehicleClass);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_VehicleIdent (OSCTXT *pctxt, VehicleIdent* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.namePresent) {
      asn1Free_DescriptiveName (pctxt, pvalue->name);
   }
   if (pvalue->m.ownerCodePresent) {
      rtxMemFreePtr (pctxt, (void*)pvalue->ownerCode);
   }
   if (pvalue->m.idPresent) {
      asn1Free_VehicleID (pctxt, &pvalue->id);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* VehicleClassification_regional */

int asn1Init_VehicleClassification_regional (
   VehicleClassification_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_VehicleClassification_regional (OSCTXT *pctxt, 
   VehicleClassification_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* VehicleClassification */

int asn1Init_VehicleClassification (VehicleClassification* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_VehicleClassification_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_VehicleClassification (OSCTXT *pctxt, 
   VehicleClassification* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.regionalPresent) {
      asn1Free_VehicleClassification_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* VehicleSafetyExtensions */

int asn1Init_VehicleSafetyExtensions (VehicleSafetyExtensions* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_VehicleEventFlags (&pvalue->events);
   asn1Init_PathHistory (&pvalue->pathHistory);
   asn1Init_PathPrediction (&pvalue->pathPrediction);
   asn1Init_ExteriorLights (&pvalue->lights);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_VehicleSafetyExtensions (OSCTXT *pctxt, 
   VehicleSafetyExtensions* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pathHistoryPresent) {
      asn1Free_PathHistory (pctxt, &pvalue->pathHistory);
   }
   if (pvalue->m.pathPredictionPresent) {
      asn1Free_PathPrediction (pctxt, &pvalue->pathPrediction);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* WiperSet */

int asn1Init_WiperSet (WiperSet* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   return 0;
}

/* VehicleStatus_steering */

int asn1Init_VehicleStatus_steering (VehicleStatus_steering* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   return 0;
}

/* AccelSteerYawRateConfidence */

/* ConfidenceSet */

int asn1Init_ConfidenceSet (ConfidenceSet* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ConfidenceSet (OSCTXT *pctxt, ConfidenceSet* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* VehicleStatus_accelSets */

int asn1Init_VehicleStatus_accelSets (VehicleStatus_accelSets* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_VerticalAccelerationThreshold (&pvalue->vertAccelThres);
   asn1Init_ConfidenceSet (&pvalue->confidenceSet);
   return 0;
}

void asn1Free_VehicleStatus_accelSets (OSCTXT *pctxt, 
   VehicleStatus_accelSets* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.confidenceSetPresent) {
      asn1Free_ConfidenceSet (pctxt, &pvalue->confidenceSet);
   }
}

/* VehicleStatus_object */

int asn1Init_VehicleStatus_object (VehicleStatus_object* pvalue)
{
   asn1Init_DDateTime (&pvalue->dateTime);
   return 0;
}

/* BumperHeights */

/* VehicleStatus_vehicleData */

/* TireData */

int asn1Init_TireData (TireData* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TireData (OSCTXT *pctxt, TireData* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TireDataList */

int asn1Init_TireDataList (TireDataList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_TireDataList (OSCTXT *pctxt, TireDataList* pvalue)
{
   if (0 == pvalue) return;
   { TireData* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (TireData*)pnode->data;
      asn1Free_TireData (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* AxleWeightSet */

int asn1Init_AxleWeightSet (AxleWeightSet* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_AxleWeightSet (OSCTXT *pctxt, AxleWeightSet* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* AxleWeightList */

int asn1Init_AxleWeightList (AxleWeightList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_AxleWeightList (OSCTXT *pctxt, AxleWeightList* pvalue)
{
   if (0 == pvalue) return;
   { AxleWeightSet* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (AxleWeightSet*)pnode->data;
      asn1Free_AxleWeightSet (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* J1939data */

int asn1Init_J1939data (J1939data* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_TireDataList (&pvalue->tires);
   asn1Init_AxleWeightList (&pvalue->axles);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_J1939data (OSCTXT *pctxt, J1939data* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.tiresPresent) {
      asn1Free_TireDataList (pctxt, &pvalue->tires);
   }
   if (pvalue->m.axlesPresent) {
      asn1Free_AxleWeightList (pctxt, &pvalue->axles);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* VehicleStatus_weatherReport */

int asn1Init_VehicleStatus_weatherReport (VehicleStatus_weatherReport* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   return 0;
}

/* VehicleStatus */

int asn1Init_VehicleStatus (VehicleStatus* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ExteriorLights (&pvalue->lights);
   asn1Init_WiperSet (&pvalue->wipers);
   asn1Init_BrakeSystemStatus (&pvalue->brakeStatus);
   asn1Init_VehicleStatus_steering (&pvalue->steering);
   asn1Init_VehicleStatus_accelSets (&pvalue->accelSets);
   asn1Init_VehicleStatus_object (&pvalue->object);
   asn1Init_FullPositionVector (&pvalue->fullPos);
   asn1Init_VehicleIdent (&pvalue->vehicleIdent);
   asn1Init_J1939data (&pvalue->j1939data);
   asn1Init_VehicleStatus_weatherReport (&pvalue->weatherReport);
   asn1Init_GNSSstatus (&pvalue->gnssStatus);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_VehicleStatus (OSCTXT *pctxt, VehicleStatus* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.accelSetsPresent) {
      asn1Free_VehicleStatus_accelSets (pctxt, &pvalue->accelSets);
   }
   if (pvalue->m.fullPosPresent) {
      asn1Free_FullPositionVector (pctxt, &pvalue->fullPos);
   }
   if (pvalue->m.vehicleIdentPresent) {
      asn1Free_VehicleIdent (pctxt, &pvalue->vehicleIdent);
   }
   if (pvalue->m.j1939dataPresent) {
      asn1Free_J1939data (pctxt, &pvalue->j1939data);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* Snapshot */

int asn1Init_Snapshot (Snapshot* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_FullPositionVector (&pvalue->thePosition);
   asn1Init_VehicleSafetyExtensions (&pvalue->safetyExt);
   asn1Init_VehicleStatus (&pvalue->dataSet);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_Snapshot (OSCTXT *pctxt, Snapshot* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_FullPositionVector (pctxt, &pvalue->thePosition);
   if (pvalue->m.safetyExtPresent) {
      asn1Free_VehicleSafetyExtensions (pctxt, &pvalue->safetyExt);
   }
   if (pvalue->m.dataSetPresent) {
      asn1Free_VehicleStatus (pctxt, &pvalue->dataSet);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* ProbeVehicleData_snapshots */

int asn1Init_ProbeVehicleData_snapshots (ProbeVehicleData_snapshots* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ProbeVehicleData_snapshots (OSCTXT *pctxt, 
   ProbeVehicleData_snapshots* pvalue)
{
   if (0 == pvalue) return;
   { Snapshot* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (Snapshot*)pnode->data;
      asn1Free_Snapshot (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* ProbeVehicleData_regional */

int asn1Init_ProbeVehicleData_regional (ProbeVehicleData_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ProbeVehicleData_regional (OSCTXT *pctxt, 
   ProbeVehicleData_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* ProbeVehicleData */

int asn1Init_ProbeVehicleData (ProbeVehicleData* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_VehicleIdent (&pvalue->probeID);
   asn1Init_FullPositionVector (&pvalue->startVector);
   asn1Init_VehicleClassification (&pvalue->vehicleType);
   asn1Init_ProbeVehicleData_snapshots (&pvalue->snapshots);
   asn1Init_ProbeVehicleData_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ProbeVehicleData (OSCTXT *pctxt, ProbeVehicleData* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.probeIDPresent) {
      asn1Free_VehicleIdent (pctxt, &pvalue->probeID);
   }
   asn1Free_FullPositionVector (pctxt, &pvalue->startVector);
   asn1Free_VehicleClassification (pctxt, &pvalue->vehicleType);
   asn1Free_ProbeVehicleData_snapshots (pctxt, &pvalue->snapshots);
   if (pvalue->m.regionalPresent) {
      asn1Free_ProbeVehicleData_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* AntennaOffsetSet */

/* RTCMheader */

int asn1Init_RTCMheader (RTCMheader* pvalue)
{
   asn1Init_GNSSstatus (&pvalue->status);
   return 0;
}

/* RTCMmessageList */

int asn1Init_RTCMmessageList (RTCMmessageList* pvalue)
{
   pvalue->n = 0;
   return 0;
}

/* RTCMcorrections_regional */

int asn1Init_RTCMcorrections_regional (RTCMcorrections_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_RTCMcorrections_regional (OSCTXT *pctxt, 
   RTCMcorrections_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* RTCMcorrections */

int asn1Init_RTCMcorrections (RTCMcorrections* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_FullPositionVector (&pvalue->anchorPoint);
   asn1Init_RTCMheader (&pvalue->rtcmHeader);
   asn1Init_RTCMmessageList (&pvalue->msgs);
   asn1Init_RTCMcorrections_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_RTCMcorrections (OSCTXT *pctxt, RTCMcorrections* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.anchorPointPresent) {
      asn1Free_FullPositionVector (pctxt, &pvalue->anchorPoint);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RTCMcorrections_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* EnabledLaneList */

int asn1Init_EnabledLaneList (EnabledLaneList* pvalue)
{
   pvalue->n = 0;
   return 0;
}

/* TimeChangeDetails */

int asn1Init_TimeChangeDetails (TimeChangeDetails* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   return 0;
}

/* AdvisorySpeed_regional */

int asn1Init_AdvisorySpeed_regional (AdvisorySpeed_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_AdvisorySpeed_regional (OSCTXT *pctxt, 
   AdvisorySpeed_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* AdvisorySpeed */

int asn1Init_AdvisorySpeed (AdvisorySpeed* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_AdvisorySpeed_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_AdvisorySpeed (OSCTXT *pctxt, AdvisorySpeed* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.regionalPresent) {
      asn1Free_AdvisorySpeed_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* AdvisorySpeedList */

int asn1Init_AdvisorySpeedList (AdvisorySpeedList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_AdvisorySpeedList (OSCTXT *pctxt, AdvisorySpeedList* pvalue)
{
   if (0 == pvalue) return;
   { AdvisorySpeed* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (AdvisorySpeed*)pnode->data;
      asn1Free_AdvisorySpeed (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* MovementEvent_regional */

int asn1Init_MovementEvent_regional (MovementEvent_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_MovementEvent_regional (OSCTXT *pctxt, 
   MovementEvent_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* MovementEvent */

int asn1Init_MovementEvent (MovementEvent* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_TimeChangeDetails (&pvalue->timing);
   asn1Init_AdvisorySpeedList (&pvalue->speeds);
   asn1Init_MovementEvent_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_MovementEvent (OSCTXT *pctxt, MovementEvent* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.speedsPresent) {
      asn1Free_AdvisorySpeedList (pctxt, &pvalue->speeds);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_MovementEvent_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* MovementEventList */

int asn1Init_MovementEventList (MovementEventList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_MovementEventList (OSCTXT *pctxt, MovementEventList* pvalue)
{
   if (0 == pvalue) return;
   { MovementEvent* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (MovementEvent*)pnode->data;
      asn1Free_MovementEvent (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* ConnectionManeuverAssist_regional */

int asn1Init_ConnectionManeuverAssist_regional (
   ConnectionManeuverAssist_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ConnectionManeuverAssist_regional (OSCTXT *pctxt, 
   ConnectionManeuverAssist_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* ConnectionManeuverAssist */

int asn1Init_ConnectionManeuverAssist (ConnectionManeuverAssist* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ConnectionManeuverAssist_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ConnectionManeuverAssist (OSCTXT *pctxt, 
   ConnectionManeuverAssist* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.regionalPresent) {
      asn1Free_ConnectionManeuverAssist_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* ManeuverAssistList */

int asn1Init_ManeuverAssistList (ManeuverAssistList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ManeuverAssistList (OSCTXT *pctxt, ManeuverAssistList* pvalue)
{
   if (0 == pvalue) return;
   { ConnectionManeuverAssist* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ConnectionManeuverAssist*)pnode->data;
      asn1Free_ConnectionManeuverAssist (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* MovementState_regional */

int asn1Init_MovementState_regional (MovementState_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_MovementState_regional (OSCTXT *pctxt, 
   MovementState_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* MovementState */

int asn1Init_MovementState (MovementState* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->movementName = 0;
   asn1Init_MovementEventList (&pvalue->state_time_speed);
   asn1Init_ManeuverAssistList (&pvalue->maneuverAssistList);
   asn1Init_MovementState_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_MovementState (OSCTXT *pctxt, MovementState* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.movementNamePresent) {
      asn1Free_DescriptiveName (pctxt, pvalue->movementName);
   }
   asn1Free_MovementEventList (pctxt, &pvalue->state_time_speed);
   if (pvalue->m.maneuverAssistListPresent) {
      asn1Free_ManeuverAssistList (pctxt, &pvalue->maneuverAssistList);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_MovementState_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* MovementList */

int asn1Init_MovementList (MovementList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_MovementList (OSCTXT *pctxt, MovementList* pvalue)
{
   if (0 == pvalue) return;
   { MovementState* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (MovementState*)pnode->data;
      asn1Free_MovementState (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* IntersectionState_regional */

int asn1Init_IntersectionState_regional (IntersectionState_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_IntersectionState_regional (OSCTXT *pctxt, 
   IntersectionState_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* IntersectionState */

int asn1Init_IntersectionState (IntersectionState* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->name = 0;
   asn1Init_IntersectionReferenceID (&pvalue->id);
   asn1Init_IntersectionStatusObject (&pvalue->status);
   asn1Init_EnabledLaneList (&pvalue->enabledLanes);
   asn1Init_MovementList (&pvalue->states);
   asn1Init_ManeuverAssistList (&pvalue->maneuverAssistList);
   asn1Init_IntersectionState_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_IntersectionState (OSCTXT *pctxt, IntersectionState* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.namePresent) {
      asn1Free_DescriptiveName (pctxt, pvalue->name);
   }
   asn1Free_MovementList (pctxt, &pvalue->states);
   if (pvalue->m.maneuverAssistListPresent) {
      asn1Free_ManeuverAssistList (pctxt, &pvalue->maneuverAssistList);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_IntersectionState_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* IntersectionStateList */

int asn1Init_IntersectionStateList (IntersectionStateList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_IntersectionStateList (OSCTXT *pctxt, 
   IntersectionStateList* pvalue)
{
   if (0 == pvalue) return;
   { IntersectionState* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (IntersectionState*)pnode->data;
      asn1Free_IntersectionState (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* SPAT_regional */

int asn1Init_SPAT_regional (SPAT_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_SPAT_regional (OSCTXT *pctxt, SPAT_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* SPAT */

int asn1Init_SPAT (SPAT* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->name = 0;
   asn1Init_IntersectionStateList (&pvalue->intersections);
   asn1Init_SPAT_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_SPAT (OSCTXT *pctxt, SPAT* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.namePresent) {
      asn1Free_DescriptiveName (pctxt, pvalue->name);
   }
   asn1Free_IntersectionStateList (pctxt, &pvalue->intersections);
   if (pvalue->m.regionalPresent) {
      asn1Free_SPAT_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* IntersectionAccessPoint */

int asn1Init_IntersectionAccessPoint (IntersectionAccessPoint* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_IntersectionAccessPoint (OSCTXT *pctxt, 
   IntersectionAccessPoint* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

/* SignalRequest_regional */

int asn1Init_SignalRequest_regional (SignalRequest_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_SignalRequest_regional (OSCTXT *pctxt, 
   SignalRequest_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* SignalRequest */

int asn1Init_SignalRequest (SignalRequest* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_IntersectionReferenceID (&pvalue->id);
   asn1Init_IntersectionAccessPoint (&pvalue->inBoundLane);
   asn1Init_IntersectionAccessPoint (&pvalue->outBoundLane);
   asn1Init_SignalRequest_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_SignalRequest (OSCTXT *pctxt, SignalRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_IntersectionAccessPoint (pctxt, &pvalue->inBoundLane);
   if (pvalue->m.outBoundLanePresent) {
      asn1Free_IntersectionAccessPoint (pctxt, &pvalue->outBoundLane);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_SignalRequest_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* SignalRequestPackage_regional */

int asn1Init_SignalRequestPackage_regional (
   SignalRequestPackage_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_SignalRequestPackage_regional (OSCTXT *pctxt, 
   SignalRequestPackage_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* SignalRequestPackage */

int asn1Init_SignalRequestPackage (SignalRequestPackage* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SignalRequest (&pvalue->request);
   asn1Init_SignalRequestPackage_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_SignalRequestPackage (OSCTXT *pctxt, 
   SignalRequestPackage* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_SignalRequest (pctxt, &pvalue->request);
   if (pvalue->m.regionalPresent) {
      asn1Free_SignalRequestPackage_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* SignalRequestList */

int asn1Init_SignalRequestList (SignalRequestList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_SignalRequestList (OSCTXT *pctxt, SignalRequestList* pvalue)
{
   if (0 == pvalue) return;
   { SignalRequestPackage* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (SignalRequestPackage*)pnode->data;
      asn1Free_SignalRequestPackage (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* RequestorType */

int asn1Init_RequestorType (RequestorType* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_RequestorType (OSCTXT *pctxt, RequestorType* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* RequestorPositionVector */

int asn1Init_RequestorPositionVector (RequestorPositionVector* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Position3D (&pvalue->position);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_RequestorPositionVector (OSCTXT *pctxt, 
   RequestorPositionVector* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_Position3D (pctxt, &pvalue->position);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* RequestorDescription_regional */

int asn1Init_RequestorDescription_regional (
   RequestorDescription_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_RequestorDescription_regional (OSCTXT *pctxt, 
   RequestorDescription_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* RequestorDescription */

int asn1Init_RequestorDescription (RequestorDescription* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_VehicleID (&pvalue->id);
   asn1Init_RequestorType (&pvalue->type);
   asn1Init_RequestorPositionVector (&pvalue->position);
   pvalue->name = 0;
   pvalue->routeName = 0;
   asn1Init_TransitVehicleStatus (&pvalue->transitStatus);
   asn1Init_RequestorDescription_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_RequestorDescription (OSCTXT *pctxt, 
   RequestorDescription* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_VehicleID (pctxt, &pvalue->id);
   if (pvalue->m.typePresent) {
      asn1Free_RequestorType (pctxt, &pvalue->type);
   }
   if (pvalue->m.positionPresent) {
      asn1Free_RequestorPositionVector (pctxt, &pvalue->position);
   }
   if (pvalue->m.namePresent) {
      asn1Free_DescriptiveName (pctxt, pvalue->name);
   }
   if (pvalue->m.routeNamePresent) {
      asn1Free_DescriptiveName (pctxt, pvalue->routeName);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RequestorDescription_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* SignalRequestMessage_regional */

int asn1Init_SignalRequestMessage_regional (
   SignalRequestMessage_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_SignalRequestMessage_regional (OSCTXT *pctxt, 
   SignalRequestMessage_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* SignalRequestMessage */

int asn1Init_SignalRequestMessage (SignalRequestMessage* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SignalRequestList (&pvalue->requests);
   asn1Init_RequestorDescription (&pvalue->requestor);
   asn1Init_SignalRequestMessage_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_SignalRequestMessage (OSCTXT *pctxt, 
   SignalRequestMessage* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.requestsPresent) {
      asn1Free_SignalRequestList (pctxt, &pvalue->requests);
   }
   asn1Free_RequestorDescription (pctxt, &pvalue->requestor);
   if (pvalue->m.regionalPresent) {
      asn1Free_SignalRequestMessage_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* SignalRequesterInfo */

int asn1Init_SignalRequesterInfo (SignalRequesterInfo* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_VehicleID (&pvalue->id);
   asn1Init_RequestorType (&pvalue->typeData);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_SignalRequesterInfo (OSCTXT *pctxt, SignalRequesterInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_VehicleID (pctxt, &pvalue->id);
   if (pvalue->m.typeDataPresent) {
      asn1Free_RequestorType (pctxt, &pvalue->typeData);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* SignalStatusPackage_regional */

int asn1Init_SignalStatusPackage_regional (
   SignalStatusPackage_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_SignalStatusPackage_regional (OSCTXT *pctxt, 
   SignalStatusPackage_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* SignalStatusPackage */

int asn1Init_SignalStatusPackage (SignalStatusPackage* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SignalRequesterInfo (&pvalue->requester);
   asn1Init_IntersectionAccessPoint (&pvalue->inboundOn);
   asn1Init_IntersectionAccessPoint (&pvalue->outboundOn);
   asn1Init_SignalStatusPackage_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_SignalStatusPackage (OSCTXT *pctxt, SignalStatusPackage* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.requesterPresent) {
      asn1Free_SignalRequesterInfo (pctxt, &pvalue->requester);
   }
   asn1Free_IntersectionAccessPoint (pctxt, &pvalue->inboundOn);
   if (pvalue->m.outboundOnPresent) {
      asn1Free_IntersectionAccessPoint (pctxt, &pvalue->outboundOn);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_SignalStatusPackage_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* SignalStatusPackageList */

int asn1Init_SignalStatusPackageList (SignalStatusPackageList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_SignalStatusPackageList (OSCTXT *pctxt, 
   SignalStatusPackageList* pvalue)
{
   if (0 == pvalue) return;
   { SignalStatusPackage* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (SignalStatusPackage*)pnode->data;
      asn1Free_SignalStatusPackage (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* SignalStatus_regional */

int asn1Init_SignalStatus_regional (SignalStatus_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_SignalStatus_regional (OSCTXT *pctxt, 
   SignalStatus_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* SignalStatus */

int asn1Init_SignalStatus (SignalStatus* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_IntersectionReferenceID (&pvalue->id);
   asn1Init_SignalStatusPackageList (&pvalue->sigStatus);
   asn1Init_SignalStatus_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_SignalStatus (OSCTXT *pctxt, SignalStatus* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_SignalStatusPackageList (pctxt, &pvalue->sigStatus);
   if (pvalue->m.regionalPresent) {
      asn1Free_SignalStatus_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* SignalStatusList */

int asn1Init_SignalStatusList (SignalStatusList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_SignalStatusList (OSCTXT *pctxt, SignalStatusList* pvalue)
{
   if (0 == pvalue) return;
   { SignalStatus* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (SignalStatus*)pnode->data;
      asn1Free_SignalStatus (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* SignalStatusMessage_regional */

int asn1Init_SignalStatusMessage_regional (
   SignalStatusMessage_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_SignalStatusMessage_regional (OSCTXT *pctxt, 
   SignalStatusMessage_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* SignalStatusMessage */

int asn1Init_SignalStatusMessage (SignalStatusMessage* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SignalStatusList (&pvalue->status);
   asn1Init_SignalStatusMessage_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_SignalStatusMessage (OSCTXT *pctxt, SignalStatusMessage* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_SignalStatusList (pctxt, &pvalue->status);
   if (pvalue->m.regionalPresent) {
      asn1Free_SignalStatusMessage_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* RoadSignID */

int asn1Init_RoadSignID (RoadSignID* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Position3D (&pvalue->position);
   asn1Init_HeadingSlice (&pvalue->viewAngle);
   asn1Init_MsgCRC (&pvalue->crc);
   return 0;
}

void asn1Free_RoadSignID (OSCTXT *pctxt, RoadSignID* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_Position3D (pctxt, &pvalue->position);
}

/* TravelerDataFrame_msgId */

int asn1Init_TravelerDataFrame_msgId (TravelerDataFrame_msgId* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_TravelerDataFrame_msgId (OSCTXT *pctxt, 
   TravelerDataFrame_msgId* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.furtherInfoID) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.furtherInfoID);
            pvalue->u.furtherInfoID = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.roadSignID) {
            asn1Free_RoadSignID (pctxt, pvalue->u.roadSignID);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.roadSignID);
            pvalue->u.roadSignID = 0;
         }
         break;

   }
}

/* Node_LL_24B */

/* Node_LL_28B */

/* Node_LL_32B */

/* Node_LL_36B */

/* Node_LL_44B */

/* Node_LL_48B */

/* NodeOffsetPointLL */

int asn1Init_NodeOffsetPointLL (NodeOffsetPointLL* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_NodeOffsetPointLL (OSCTXT *pctxt, NodeOffsetPointLL* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.node_LL1) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.node_LL1);
            pvalue->u.node_LL1 = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.node_LL2) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.node_LL2);
            pvalue->u.node_LL2 = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.node_LL3) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.node_LL3);
            pvalue->u.node_LL3 = 0;
         }
         break;

      case 4:
         if (0 != pvalue->u.node_LL4) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.node_LL4);
            pvalue->u.node_LL4 = 0;
         }
         break;

      case 5:
         if (0 != pvalue->u.node_LL5) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.node_LL5);
            pvalue->u.node_LL5 = 0;
         }
         break;

      case 6:
         if (0 != pvalue->u.node_LL6) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.node_LL6);
            pvalue->u.node_LL6 = 0;
         }
         break;

      case 7:
         if (0 != pvalue->u.node_LatLon) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.node_LatLon);
            pvalue->u.node_LatLon = 0;
         }
         break;

      case 8:
         if (0 != pvalue->u.regional) {
            asn1Free_RegionalExtension (pctxt, pvalue->u.regional);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.regional);
            pvalue->u.regional = 0;
         }
         break;

   }
}

/* NodeAttributeLLList */

int asn1Init_NodeAttributeLLList (NodeAttributeLLList* pvalue)
{
   pvalue->n = 0;
   return 0;
}

/* SegmentAttributeLLList */

int asn1Init_SegmentAttributeLLList (SegmentAttributeLLList* pvalue)
{
   pvalue->n = 0;
   return 0;
}

/* NodeAttributeSetLL_regional */

int asn1Init_NodeAttributeSetLL_regional (NodeAttributeSetLL_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_NodeAttributeSetLL_regional (OSCTXT *pctxt, 
   NodeAttributeSetLL_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* NodeAttributeSetLL */

int asn1Init_NodeAttributeSetLL (NodeAttributeSetLL* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_NodeAttributeLLList (&pvalue->localNode);
   asn1Init_SegmentAttributeLLList (&pvalue->disabled);
   asn1Init_SegmentAttributeLLList (&pvalue->enabled);
   asn1Init_LaneDataAttributeList (&pvalue->data);
   asn1Init_NodeAttributeSetLL_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_NodeAttributeSetLL (OSCTXT *pctxt, NodeAttributeSetLL* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dataPresent) {
      asn1Free_LaneDataAttributeList (pctxt, &pvalue->data);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_NodeAttributeSetLL_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* NodeLL */

int asn1Init_NodeLL (NodeLL* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_NodeOffsetPointLL (&pvalue->delta);
   asn1Init_NodeAttributeSetLL (&pvalue->attributes);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_NodeLL (OSCTXT *pctxt, NodeLL* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_NodeOffsetPointLL (pctxt, &pvalue->delta);
   if (pvalue->m.attributesPresent) {
      asn1Free_NodeAttributeSetLL (pctxt, &pvalue->attributes);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* NodeSetLL */

int asn1Init_NodeSetLL (NodeSetLL* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_NodeSetLL (OSCTXT *pctxt, NodeSetLL* pvalue)
{
   if (0 == pvalue) return;
   { NodeLL* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (NodeLL*)pnode->data;
      asn1Free_NodeLL (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* NodeListLL */

int asn1Init_NodeListLL (NodeListLL* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_NodeListLL (OSCTXT *pctxt, NodeListLL* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.nodes) {
            asn1Free_NodeSetLL (pctxt, pvalue->u.nodes);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.nodes);
            pvalue->u.nodes = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

/* OffsetSystem_offset */

int asn1Init_OffsetSystem_offset (OffsetSystem_offset* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_OffsetSystem_offset (OSCTXT *pctxt, OffsetSystem_offset* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.xy) {
            asn1Free_NodeListXY (pctxt, pvalue->u.xy);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.xy);
            pvalue->u.xy = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.ll) {
            asn1Free_NodeListLL (pctxt, pvalue->u.ll);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ll);
            pvalue->u.ll = 0;
         }
         break;

   }
}

/* OffsetSystem */

int asn1Init_OffsetSystem (OffsetSystem* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_OffsetSystem_offset (&pvalue->offset);
   return 0;
}

void asn1Free_OffsetSystem (OSCTXT *pctxt, OffsetSystem* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_OffsetSystem_offset (pctxt, &pvalue->offset);
}

/* Circle */

int asn1Init_Circle (Circle* pvalue)
{
   asn1Init_Position3D (&pvalue->center);
   return 0;
}

void asn1Free_Circle (OSCTXT *pctxt, Circle* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_Position3D (pctxt, &pvalue->center);
}

/* GeometricProjection_regional */

int asn1Init_GeometricProjection_regional (
   GeometricProjection_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_GeometricProjection_regional (OSCTXT *pctxt, 
   GeometricProjection_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* GeometricProjection */

int asn1Init_GeometricProjection (GeometricProjection* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_HeadingSlice (&pvalue->direction);
   asn1Init_Circle (&pvalue->circle);
   asn1Init_GeometricProjection_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_GeometricProjection (OSCTXT *pctxt, GeometricProjection* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_Circle (pctxt, &pvalue->circle);
   if (pvalue->m.regionalPresent) {
      asn1Free_GeometricProjection_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* ShapePointSet */

int asn1Init_ShapePointSet (ShapePointSet* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Position3D (&pvalue->anchor);
   asn1Init_NodeListXY (&pvalue->nodeList);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ShapePointSet (OSCTXT *pctxt, ShapePointSet* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.anchorPresent) {
      asn1Free_Position3D (pctxt, &pvalue->anchor);
   }
   asn1Free_NodeListXY (pctxt, &pvalue->nodeList);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* RegionOffsets */

int asn1Init_RegionOffsets (RegionOffsets* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   return 0;
}

/* RegionList */

int asn1Init_RegionList (RegionList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_RegionList (OSCTXT *pctxt, RegionList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

/* RegionPointSet */

int asn1Init_RegionPointSet (RegionPointSet* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Position3D (&pvalue->anchor);
   asn1Init_RegionList (&pvalue->nodeList);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_RegionPointSet (OSCTXT *pctxt, RegionPointSet* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.anchorPresent) {
      asn1Free_Position3D (pctxt, &pvalue->anchor);
   }
   asn1Free_RegionList (pctxt, &pvalue->nodeList);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* ValidRegion_area */

int asn1Init_ValidRegion_area (ValidRegion_area* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ValidRegion_area (OSCTXT *pctxt, ValidRegion_area* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.shapePointSet) {
            asn1Free_ShapePointSet (pctxt, pvalue->u.shapePointSet);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.shapePointSet);
            pvalue->u.shapePointSet = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.circle) {
            asn1Free_Circle (pctxt, pvalue->u.circle);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.circle);
            pvalue->u.circle = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.regionPointSet) {
            asn1Free_RegionPointSet (pctxt, pvalue->u.regionPointSet);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.regionPointSet);
            pvalue->u.regionPointSet = 0;
         }
         break;

   }
}

/* ValidRegion */

int asn1Init_ValidRegion (ValidRegion* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_HeadingSlice (&pvalue->direction);
   asn1Init_ValidRegion_area (&pvalue->area);
   return 0;
}

void asn1Free_ValidRegion (OSCTXT *pctxt, ValidRegion* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ValidRegion_area (pctxt, &pvalue->area);
}

/* GeographicalPath_description */

int asn1Init_GeographicalPath_description (
   GeographicalPath_description* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_GeographicalPath_description (OSCTXT *pctxt, 
   GeographicalPath_description* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.path) {
            asn1Free_OffsetSystem (pctxt, pvalue->u.path);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.path);
            pvalue->u.path = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.geometry) {
            asn1Free_GeometricProjection (pctxt, pvalue->u.geometry);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.geometry);
            pvalue->u.geometry = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.oldRegion) {
            asn1Free_ValidRegion (pctxt, pvalue->u.oldRegion);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.oldRegion);
            pvalue->u.oldRegion = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

/* GeographicalPath_regional */

int asn1Init_GeographicalPath_regional (GeographicalPath_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_GeographicalPath_regional (OSCTXT *pctxt, 
   GeographicalPath_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* GeographicalPath */

int asn1Init_GeographicalPath (GeographicalPath* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->name = 0;
   asn1Init_RoadSegmentReferenceID (&pvalue->id);
   asn1Init_Position3D (&pvalue->anchor);
   asn1Init_HeadingSlice (&pvalue->direction);
   asn1Init_GeographicalPath_description (&pvalue->description);
   asn1Init_GeographicalPath_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_GeographicalPath (OSCTXT *pctxt, GeographicalPath* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.namePresent) {
      asn1Free_DescriptiveName (pctxt, pvalue->name);
   }
   if (pvalue->m.anchorPresent) {
      asn1Free_Position3D (pctxt, &pvalue->anchor);
   }
   if (pvalue->m.descriptionPresent) {
      asn1Free_GeographicalPath_description (pctxt, &pvalue->description);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_GeographicalPath_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TravelerDataFrame_regions */

int asn1Init_TravelerDataFrame_regions (TravelerDataFrame_regions* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_TravelerDataFrame_regions (OSCTXT *pctxt, 
   TravelerDataFrame_regions* pvalue)
{
   if (0 == pvalue) return;
   { GeographicalPath* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (GeographicalPath*)pnode->data;
      asn1Free_GeographicalPath (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* WorkZone_element_item */

int asn1Init_WorkZone_element_item (WorkZone_element_item* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_WorkZone_element_item (OSCTXT *pctxt, 
   WorkZone_element_item* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         asn1Free_ITIStextPhrase (pctxt, pvalue->u.text);
         break;

   }
}

/* WorkZone_element */

int asn1Init_WorkZone_element (WorkZone_element* pvalue)
{
   asn1Init_WorkZone_element_item (&pvalue->item);
   return 0;
}

void asn1Free_WorkZone_element (OSCTXT *pctxt, WorkZone_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_WorkZone_element_item (pctxt, &pvalue->item);
}

/* WorkZone */

int asn1Init_WorkZone (WorkZone* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_WorkZone (OSCTXT *pctxt, WorkZone* pvalue)
{
   if (0 == pvalue) return;
   { WorkZone_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (WorkZone_element*)pnode->data;
      asn1Free_WorkZone_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* GenericSignage_element_item */

int asn1Init_GenericSignage_element_item (GenericSignage_element_item* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_GenericSignage_element_item (OSCTXT *pctxt, 
   GenericSignage_element_item* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         asn1Free_ITIStextPhrase (pctxt, pvalue->u.text);
         break;

   }
}

/* GenericSignage_element */

int asn1Init_GenericSignage_element (GenericSignage_element* pvalue)
{
   asn1Init_GenericSignage_element_item (&pvalue->item);
   return 0;
}

void asn1Free_GenericSignage_element (OSCTXT *pctxt, 
   GenericSignage_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_GenericSignage_element_item (pctxt, &pvalue->item);
}

/* GenericSignage */

int asn1Init_GenericSignage (GenericSignage* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_GenericSignage (OSCTXT *pctxt, GenericSignage* pvalue)
{
   if (0 == pvalue) return;
   { GenericSignage_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (GenericSignage_element*)pnode->data;
      asn1Free_GenericSignage_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* SpeedLimit_element_item */

int asn1Init_SpeedLimit_element_item (SpeedLimit_element_item* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_SpeedLimit_element_item (OSCTXT *pctxt, 
   SpeedLimit_element_item* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         asn1Free_ITIStextPhrase (pctxt, pvalue->u.text);
         break;

   }
}

/* SpeedLimit_element */

int asn1Init_SpeedLimit_element (SpeedLimit_element* pvalue)
{
   asn1Init_SpeedLimit_element_item (&pvalue->item);
   return 0;
}

void asn1Free_SpeedLimit_element (OSCTXT *pctxt, SpeedLimit_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_SpeedLimit_element_item (pctxt, &pvalue->item);
}

/* SpeedLimit */

int asn1Init_SpeedLimit (SpeedLimit* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_SpeedLimit (OSCTXT *pctxt, SpeedLimit* pvalue)
{
   if (0 == pvalue) return;
   { SpeedLimit_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (SpeedLimit_element*)pnode->data;
      asn1Free_SpeedLimit_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* ExitService_element_item */

int asn1Init_ExitService_element_item (ExitService_element_item* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ExitService_element_item (OSCTXT *pctxt, 
   ExitService_element_item* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         asn1Free_ITIStextPhrase (pctxt, pvalue->u.text);
         break;

   }
}

/* ExitService_element */

int asn1Init_ExitService_element (ExitService_element* pvalue)
{
   asn1Init_ExitService_element_item (&pvalue->item);
   return 0;
}

void asn1Free_ExitService_element (OSCTXT *pctxt, ExitService_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ExitService_element_item (pctxt, &pvalue->item);
}

/* ExitService */

int asn1Init_ExitService (ExitService* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ExitService (OSCTXT *pctxt, ExitService* pvalue)
{
   if (0 == pvalue) return;
   { ExitService_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ExitService_element*)pnode->data;
      asn1Free_ExitService_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* TravelerDataFrame_content */

int asn1Init_TravelerDataFrame_content (TravelerDataFrame_content* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_TravelerDataFrame_content (OSCTXT *pctxt, 
   TravelerDataFrame_content* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.advisory) {
            asn1Free_ITIScodesAndText (pctxt, pvalue->u.advisory);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.advisory);
            pvalue->u.advisory = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.workZone) {
            asn1Free_WorkZone (pctxt, pvalue->u.workZone);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.workZone);
            pvalue->u.workZone = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.genericSign) {
            asn1Free_GenericSignage (pctxt, pvalue->u.genericSign);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.genericSign);
            pvalue->u.genericSign = 0;
         }
         break;

      case 4:
         if (0 != pvalue->u.speedLimit) {
            asn1Free_SpeedLimit (pctxt, pvalue->u.speedLimit);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.speedLimit);
            pvalue->u.speedLimit = 0;
         }
         break;

      case 5:
         if (0 != pvalue->u.exitService) {
            asn1Free_ExitService (pctxt, pvalue->u.exitService);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.exitService);
            pvalue->u.exitService = 0;
         }
         break;

   }
}

/* TravelerDataFrame */

int asn1Init_TravelerDataFrame (TravelerDataFrame* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_TravelerDataFrame_msgId (&pvalue->msgId);
   asn1Init_TravelerDataFrame_regions (&pvalue->regions);
   asn1Init_TravelerDataFrame_content (&pvalue->content);
   pvalue->url = 0;
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TravelerDataFrame (OSCTXT *pctxt, TravelerDataFrame* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_TravelerDataFrame_msgId (pctxt, &pvalue->msgId);
   asn1Free_TravelerDataFrame_regions (pctxt, &pvalue->regions);
   asn1Free_TravelerDataFrame_content (pctxt, &pvalue->content);
   if (pvalue->m.urlPresent) {
      asn1Free_URL_Short (pctxt, pvalue->url);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TravelerDataFrameList */

int asn1Init_TravelerDataFrameList (TravelerDataFrameList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_TravelerDataFrameList (OSCTXT *pctxt, 
   TravelerDataFrameList* pvalue)
{
   if (0 == pvalue) return;
   { TravelerDataFrame* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (TravelerDataFrame*)pnode->data;
      asn1Free_TravelerDataFrame (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* TravelerInformation_regional */

int asn1Init_TravelerInformation_regional (
   TravelerInformation_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_TravelerInformation_regional (OSCTXT *pctxt, 
   TravelerInformation_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* TravelerInformation */

int asn1Init_TravelerInformation (TravelerInformation* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_UniqueMSGID (&pvalue->packetID);
   pvalue->urlB = 0;
   asn1Init_TravelerDataFrameList (&pvalue->dataFrames);
   asn1Init_TravelerInformation_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TravelerInformation (OSCTXT *pctxt, TravelerInformation* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.urlBPresent) {
      asn1Free_URL_Base (pctxt, pvalue->urlB);
   }
   asn1Free_TravelerDataFrameList (pctxt, &pvalue->dataFrames);
   if (pvalue->m.regionalPresent) {
      asn1Free_TravelerInformation_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* Header */

int asn1Init_Header (Header* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_Header (OSCTXT *pctxt, Header* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage00 */

int asn1Init_TestMessage00 (TestMessage00* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage00 (OSCTXT *pctxt, TestMessage00* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage01 */

int asn1Init_TestMessage01 (TestMessage01* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage01 (OSCTXT *pctxt, TestMessage01* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage02 */

int asn1Init_TestMessage02 (TestMessage02* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage02 (OSCTXT *pctxt, TestMessage02* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage03 */

int asn1Init_TestMessage03 (TestMessage03* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage03 (OSCTXT *pctxt, TestMessage03* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage04 */

int asn1Init_TestMessage04 (TestMessage04* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage04 (OSCTXT *pctxt, TestMessage04* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage05 */

int asn1Init_TestMessage05 (TestMessage05* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage05 (OSCTXT *pctxt, TestMessage05* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage06 */

int asn1Init_TestMessage06 (TestMessage06* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage06 (OSCTXT *pctxt, TestMessage06* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage07 */

int asn1Init_TestMessage07 (TestMessage07* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage07 (OSCTXT *pctxt, TestMessage07* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage08 */

int asn1Init_TestMessage08 (TestMessage08* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage08 (OSCTXT *pctxt, TestMessage08* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage09 */

int asn1Init_TestMessage09 (TestMessage09* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage09 (OSCTXT *pctxt, TestMessage09* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage10 */

int asn1Init_TestMessage10 (TestMessage10* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage10 (OSCTXT *pctxt, TestMessage10* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage11 */

int asn1Init_TestMessage11 (TestMessage11* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage11 (OSCTXT *pctxt, TestMessage11* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage12 */

int asn1Init_TestMessage12 (TestMessage12* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage12 (OSCTXT *pctxt, TestMessage12* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage13 */

int asn1Init_TestMessage13 (TestMessage13* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage13 (OSCTXT *pctxt, TestMessage13* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage14 */

int asn1Init_TestMessage14 (TestMessage14* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage14 (OSCTXT *pctxt, TestMessage14* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TestMessage15 */

int asn1Init_TestMessage15 (TestMessage15* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_Header (&pvalue->header);
   asn1Init_RegionalExtension (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TestMessage15 (OSCTXT *pctxt, TestMessage15* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerPresent) {
      asn1Free_Header (pctxt, &pvalue->header);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_RegionalExtension (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* DDate */

/* DFullTime */

/* DMonthDay */

/* DTime */

int asn1Init_DTime (DTime* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   return 0;
}

/* DYearMonth */

/* DisabledVehicle */

int asn1Init_DisabledVehicle (DisabledVehicle* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_DisabledVehicle (OSCTXT *pctxt, DisabledVehicle* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* EventDescription_description */

int asn1Init_EventDescription_description (
   EventDescription_description* pvalue)
{
   pvalue->n = 0;
   return 0;
}

/* EventDescription_regional */

int asn1Init_EventDescription_regional (EventDescription_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_EventDescription_regional (OSCTXT *pctxt, 
   EventDescription_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* EventDescription */

int asn1Init_EventDescription (EventDescription* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_EventDescription_description (&pvalue->description);
   asn1Init_Priority (&pvalue->priority);
   asn1Init_HeadingSlice (&pvalue->heading);
   asn1Init_EventDescription_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_EventDescription (OSCTXT *pctxt, EventDescription* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.regionalPresent) {
      asn1Free_EventDescription_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* ObstacleDetection */

int asn1Init_ObstacleDetection (ObstacleDetection* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_DDateTime (&pvalue->dateTime);
   asn1Init_VerticalAccelerationThreshold (&pvalue->vertEvent);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ObstacleDetection (OSCTXT *pctxt, ObstacleDetection* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* PivotPointDescription */

int asn1Init_PivotPointDescription (PivotPointDescription* pvalue)
{
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_PivotPointDescription (OSCTXT *pctxt, 
   PivotPointDescription* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* RTCMPackage */

int asn1Init_RTCMPackage (RTCMPackage* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_RTCMheader (&pvalue->rtcmHeader);
   asn1Init_RTCMmessageList (&pvalue->msgs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_RTCMPackage (OSCTXT *pctxt, RTCMPackage* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TrailerHistoryPoint */

int asn1Init_TrailerHistoryPoint (TrailerHistoryPoint* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TrailerHistoryPoint (OSCTXT *pctxt, TrailerHistoryPoint* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TrailerHistoryPointList */

int asn1Init_TrailerHistoryPointList (TrailerHistoryPointList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_TrailerHistoryPointList (OSCTXT *pctxt, 
   TrailerHistoryPointList* pvalue)
{
   if (0 == pvalue) return;
   { TrailerHistoryPoint* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (TrailerHistoryPoint*)pnode->data;
      asn1Free_TrailerHistoryPoint (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* TrailerUnitDescription */

int asn1Init_TrailerUnitDescription (TrailerUnitDescription* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_PivotPointDescription (&pvalue->frontPivot);
   asn1Init_PivotPointDescription (&pvalue->rearPivot);
   asn1Init_TrailerHistoryPointList (&pvalue->crumbData);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TrailerUnitDescription (OSCTXT *pctxt, 
   TrailerUnitDescription* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_PivotPointDescription (pctxt, &pvalue->frontPivot);
   if (pvalue->m.rearPivotPresent) {
      asn1Free_PivotPointDescription (pctxt, &pvalue->rearPivot);
   }
   if (pvalue->m.crumbDataPresent) {
      asn1Free_TrailerHistoryPointList (pctxt, &pvalue->crumbData);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* TrailerUnitDescriptionList */

int asn1Init_TrailerUnitDescriptionList (TrailerUnitDescriptionList* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_TrailerUnitDescriptionList (OSCTXT *pctxt, 
   TrailerUnitDescriptionList* pvalue)
{
   if (0 == pvalue) return;
   { TrailerUnitDescription* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (TrailerUnitDescription*)pnode->data;
      asn1Free_TrailerUnitDescription (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* TrailerData */

int asn1Init_TrailerData (TrailerData* pvalue)
{
   asn1Init_PivotPointDescription (&pvalue->connection);
   asn1Init_TrailerUnitDescriptionList (&pvalue->units);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_TrailerData (OSCTXT *pctxt, TrailerData* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_PivotPointDescription (pctxt, &pvalue->connection);
   asn1Free_TrailerUnitDescriptionList (pctxt, &pvalue->units);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* SpecialVehicleExtensions */

int asn1Init_SpecialVehicleExtensions (SpecialVehicleExtensions* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_EmergencyDetails (&pvalue->vehicleAlerts);
   asn1Init_EventDescription (&pvalue->description);
   asn1Init_TrailerData (&pvalue->trailers);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_SpecialVehicleExtensions (OSCTXT *pctxt, 
   SpecialVehicleExtensions* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.vehicleAlertsPresent) {
      asn1Free_EmergencyDetails (pctxt, &pvalue->vehicleAlerts);
   }
   if (pvalue->m.descriptionPresent) {
      asn1Free_EventDescription (pctxt, &pvalue->description);
   }
   if (pvalue->m.trailersPresent) {
      asn1Free_TrailerData (pctxt, &pvalue->trailers);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* SpeedProfileMeasurementList */

int asn1Init_SpeedProfileMeasurementList (SpeedProfileMeasurementList* pvalue)
{
   pvalue->n = 0;
   return 0;
}

/* SpeedProfile */

int asn1Init_SpeedProfile (SpeedProfile* pvalue)
{
   asn1Init_SpeedProfileMeasurementList (&pvalue->speedReports);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_SpeedProfile (OSCTXT *pctxt, SpeedProfile* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* VehicleData */

int asn1Init_VehicleData (VehicleData* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_VehicleData (OSCTXT *pctxt, VehicleData* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* WeatherReport */

int asn1Init_WeatherReport (WeatherReport* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_WeatherReport (OSCTXT *pctxt, WeatherReport* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* WeatherProbe */

int asn1Init_WeatherProbe (WeatherProbe* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_WiperSet (&pvalue->rainRates);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_WeatherProbe (OSCTXT *pctxt, WeatherProbe* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* SupplementalVehicleExtensions_regional */

int asn1Init_SupplementalVehicleExtensions_regional (
   SupplementalVehicleExtensions_regional* pvalue)
{
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_SupplementalVehicleExtensions_regional (OSCTXT *pctxt, 
   SupplementalVehicleExtensions_regional* pvalue)
{
   if (0 == pvalue) return;
   { RegionalExtension* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (RegionalExtension*)pnode->data;
      asn1Free_RegionalExtension (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

/* SupplementalVehicleExtensions */

int asn1Init_SupplementalVehicleExtensions (
   SupplementalVehicleExtensions* pvalue)
{
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_VehicleClassification (&pvalue->classDetails);
   asn1Init_VehicleData (&pvalue->vehicleData);
   asn1Init_WeatherReport (&pvalue->weatherReport);
   asn1Init_WeatherProbe (&pvalue->weatherProbe);
   asn1Init_ObstacleDetection (&pvalue->obstacle);
   asn1Init_DisabledVehicle (&pvalue->status);
   asn1Init_SpeedProfile (&pvalue->speedProfile);
   asn1Init_RTCMPackage (&pvalue->theRTCM);
   asn1Init_SupplementalVehicleExtensions_regional (&pvalue->regional);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_SupplementalVehicleExtensions (OSCTXT *pctxt, 
   SupplementalVehicleExtensions* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.classDetailsPresent) {
      asn1Free_VehicleClassification (pctxt, &pvalue->classDetails);
   }
   if (pvalue->m.vehicleDataPresent) {
      asn1Free_VehicleData (pctxt, &pvalue->vehicleData);
   }
   if (pvalue->m.weatherReportPresent) {
      asn1Free_WeatherReport (pctxt, &pvalue->weatherReport);
   }
   if (pvalue->m.weatherProbePresent) {
      asn1Free_WeatherProbe (pctxt, &pvalue->weatherProbe);
   }
   if (pvalue->m.obstaclePresent) {
      asn1Free_ObstacleDetection (pctxt, &pvalue->obstacle);
   }
   if (pvalue->m.statusPresent) {
      asn1Free_DisabledVehicle (pctxt, &pvalue->status);
   }
   if (pvalue->m.speedProfilePresent) {
      asn1Free_SpeedProfile (pctxt, &pvalue->speedProfile);
   }
   if (pvalue->m.theRTCMPresent) {
      asn1Free_RTCMPackage (pctxt, &pvalue->theRTCM);
   }
   if (pvalue->m.regionalPresent) {
      asn1Free_SupplementalVehicleExtensions_regional (pctxt, &pvalue->regional);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

/* VerticalOffset */

int asn1Init_VerticalOffset (VerticalOffset* pvalue)
{
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_VerticalOffset (OSCTXT *pctxt, VerticalOffset* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         break;

      case 4:
         break;

      case 5:
         break;

      case 6:
         break;

      case 7:
         break;

      case 8:
         if (0 != pvalue->u.regional) {
            asn1Free_RegionalExtension (pctxt, pvalue->u.regional);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.regional);
            pvalue->u.regional = 0;
         }
         break;

   }
}

